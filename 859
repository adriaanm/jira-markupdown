I could fix the immediate type checking problem, which had to do with a 
too eager skolemization in the subtype checking routine for existentials.
However, I now get 
```scala
t1053.scala:1: error: name clash between defined and inherited member:
value T$$U$$$$$$outer:(()T[_53.type]) forSome { val _53: java.lang.Object{type V = T[this.type]} } and
value T$$U$$$$$$outer:(()T[_62.type]) forSome { val _63: AnyRef{type V = T[this.type]}; val _62: AnyRef{type V = T[_63.type]} } in trait U
have same type after erasure: ()T
trait T[A] { trait U { type W = A; val x = 3 } }
                   ^
one error found
```
The compiler got confused at explicit outer phase. Clearly the combination of
structural type members and existentials still needs work. Maybe do it with the calculus first, and then get back to the compiler once we know what we are doing.
