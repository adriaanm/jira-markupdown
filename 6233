The trait version ComEntity's getId()'s bytecode is:

{code}
0 aload_0
1 invokestatic #32 <com/toto/RefDataEntity$class.getId>
4 areturn
{code}

and it's id() like so:

{code}
0 aload_0
1 getfield #23 <com/toto/ComEntity.id>
4 areturn
{code}

and the trait's RefDataEntity$class's getId()'s like so (it has no id()):

{code}
0 aload_0
1 invokeinterface #21 <com/toto/RefDataEntity.id> count 1
6 areturn
{code}

While the abstract version's ComEntity has no mention of id/getId (since it uses it's parents), and the RefDataEntity's getId():

{code}
0 aload_0
1 invokevirtual #26 <com/toto/RefDataEntity.id>
4 areturn
{code}

and the id():

{code}
0 aload_0
1 getfield #20 <com/toto/RefDataEntity.id>
4 areturn
{code}

The abstract RefDataEntity class has the TypeDef annotation visible and it defines the methods there, which the child inherits, thus it is visible and poses no problems. In the trait version however, the child doesn't inherit those methods but implements them (since it uses the RefDataEntity trait) and the class does not have the annotations in it, which is why at runtime it gets confused. That is how I understand it from looking at it with jclasslib, but I've been using scala for 2 months only.
