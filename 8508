subtyping is broken because substitution is -- you can't tell, because existentialTransform transitively chases all bounds so it doesn't matter, but that's not the right fix (as that rewrite is not universally valid, and we shouldn't be changing these user-defined types like that anyway)
```scala
scala> type T = X forSome { type X <: U ; type U <: String }
scala> typeOf[T].dealias.skolemizeExistential.typeSymbol.info
res7: $r.intp.global.Type =  <: String
```

If you disable that bound rewriting (as I'm doing), this will yield false:
```scala
scala> :power
scala> class C { type T = X.T forSome { val X : U ; type U <: {type T} } }
scala> typeOf[C].member("T": TypeName)
scala> res0.info.skolemizeExistential <:< res0.info
```
