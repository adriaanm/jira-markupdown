More:

- I'm thinking we should always generate the hashCode calculating method, so people can override hashCode and not lose the synthetic.  We should do this for equals as well.  Sample:
```scala
case class Foo(x: Int, y: Int, z: String)

would give us

object Foo {
  def classHashCode(x: Foo): Int = { // custom hashcode calculation }
  def classEquals(x1: Foo, x2: Foo): Boolean = { // custom equals }
  // apply, unapply, etc.
}

class Foo(val x: Int, y: Int, z: String) {
  // now you can do, for instance, this:
  override lazy val hashCode = Foo.classHashCode(this)
}
```
