I've had a look at this and it seems like there's an interaction between the CPS transform and non-local returns. After the {{selectivecps}} phase the {{test1}} function is transformed to return a ControlContext, but the return statement still returns an {{Int}}.

{noformat}
    def test1(): scala.util.continuations.ControlContext[Int,Int,Int] = {
      Main.this.one.map[Nothing](((tmp1: Int) => return tmp1))
    };
{noformat}

The non-local return code is transformed in the following ({{uncurry}}) phase. The return statement is transformed into a thrown {{NonLocalReturnControl}} containing an {{Int}}, but the catch now expects it to contain a {{ControlContext}}. This mismatch is probably the reason for the {{ClassCastException}} in the issue description.

{noformat}
    def test1(): scala.util.continuations.ControlContext[Int,Int,Int] = {
      <synthetic> val nonLocalReturnKey1: Object = new Object();
      try {
        Main.this.one().map[Nothing]({
          @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1[Int,Nothing] with Serializable {
            def this(): anonymous class $anonfun = {
              $anonfun.super.this();
              ()
            };
            final def apply(tmp1: Int): Nothing = throw new scala.runtime.NonLocalReturnControl[Int](nonLocalReturnKey1, tmp1)
          };
          (new anonymous class $anonfun(): Int => Nothing)
        })
      } catch {
        case (ex @ (_: scala.runtime.NonLocalReturnControl[Main._])) => if (ex.key().eq(nonLocalReturnKey1))
          ex.value().asInstanceOf[scala.util.continuations.ControlContext[Int,Int,Int]]()
        else
          throw ex
      }
    };
{noformat}
