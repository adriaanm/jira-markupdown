So for this:

{code:scala}
package a

import scala.annotation.hideImplicitConversion

trait Foo[S] {
  def foo(t: S): Int = 123
}

trait Boo[T]

trait ShouldNotAppear

object Boo {
  @hideImplicitConversion implicit class BooCharIsFoo(boo: Boo[ShouldNotAppear]) extends Foo[ShouldNotAppear]
  implicit class BooLongIsFoo(boo: Boo[Long]) extends Foo[Long]
}
{code}

I figured I could do something like this in {{ModelFactoryImplicitSupport.scala:545}}:

{code:scala}
def implicitShouldDocument(aSym: Symbol): Boolean = {
  //...
  && !aSym.owner.annotations.map(_.symbol.nameString).contains("hideImplicitConversion")
}
{code}

But unfortunately, the entities that have their owner set to the annotated implicit class - not one of them has the method {{foo}}. So I started looking at it from the perspective "what {{owner}} does the method {{foo}} have"? Turns out it has {{Foo}} as owner (surprise!).

So then I figured: maybe I can get the implicit class from the method {{foo}} by checking if its owner has any subclasses that have the {{@hideImplicitConversion}} annotation. But when I look at the {{_.owner.knownDirectSubclasses}} list of entities - I get an empty set for {{Foo}}. I looked around and found: SI-7046. I'm not sure this has anything to do with this. I just don't know how to get the subclasses from the {{Foo}} trait this way. Any ideas?

(PS: #4949 on github is ready to be merged)

PS2: I hope this approach enables us to mask stuff out in the Predef btw!
