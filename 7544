Some additional information.  Ran this code:

{noformat}
    val nodes = model.getPathToRoot(this)
    val pathBad = new TreePath(nodes)
    val pathTry = new javax.swing.tree.TreePath(nodes)
    val path = this.getTreePath(tree.getJTree, model, this)
{noformat}

and this is what appears in the Variables pane of Eclipse Debug:

{noformat}
this	WrapTreeNode  (id=53)	
nodes	TreeNode[1]  (id=54)	
	[0]	WrapTreeNode  (id=53)	
pathBad	TreePath  (id=62)	
	lastPathComponent	TreeNode[1]  (id=54)	
	parentPath	null	
pathTry	TreePath  (id=64)	
	lastPathComponent	TreeNode[1]  (id=54)	
	parentPath	null	
path	TreePath  (id=71)	
	lastPathComponent	WrapTreeNode  (id=53)	
	parentPath	null	

{noformat}

*nodes* has the value as expected (an array of 1 WrapTreeNode -- which is my extension of a TreeNode)

*path* at the end is correct.  getTreePath is a Java routine which does just *return new TreePath(model.getPathToRoot(node));*  Notice that the *lastPathComponent* is a simple WrapTreeNode instance

*pathBad* is executing the *new TreePath(nodes)* in Scala.  It sets up lastPathComponent as an *array* with one TreeNode element.

*pathTry* was to verify that we were getting the javax.swing.tree.TreePath constructor (instead of a similarly named TreePath from somewhere else) - but it results in the same thing.

Am I missing something here?  It seems to be a problem with the *new TreePath(...)* constructor when executed in Scala.  Am I missing a case or something?  (But no compiler warnings or errors were issued.)
