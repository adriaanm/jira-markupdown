Variable arguments will be converted to WrappedArray implicitly with proper component type, but under below case, for  ArrayWrapper.updateOne method, the argument will be converted to WrappedArray$ofRef (should be WrappedArray$ofDouble) discarding the declared type parameter [T] (Double here, for example).

The code below is similar to Scala's collections library code, and works under Scala 2.9.x.

{code}

import scala.collection.mutable.WrappedArray
import scala.reflect.ClassTag

object Main {
  
  def main(args: Array[String]) {
    val test = new ArrayWrapper[Double]
    test.update(1.0)    // ok
    test.updateOne(1.0) // failure with ArrayStoreExcpetion
  }
}

class ArrayWrapper[T: ClassTag] {
  val array = new Array[T](2)
  
  // elem will be boxed to java.lang.Object (java.lang.Double), then wrapped as 
  // Array[Object] and passed to scala.LowPriorityImplicits.genericWrapArray[T](xs: Array[T])
  // becaues of update(elems: T*), and causes ArrayStoreException.
  def updateOne(elem: T) {
    update(elem)
  }
  
  // ok when called outside directly
  def update(elems: T*) {
    updateAll(elems)
  }
  
  def updateAll(elems: scala.collection.Traversable[T]) {
    println(elems.getClass)
    // class scala.collection.mutable.WrappedArray$ofDouble -- when via update
    // class scala.collection.mutable.WrappedArray$ofRef    -- when via updateOne
    
    elems match {
      case xs: WrappedArray[T] =>
        println(xs.array) 
        // [D@504ad009                  --- when via update
        // [Ljava.lang.Object;@3b87bd31 --- when via updateOne
        
        array(0) = xs.array(0) 
        // ok
        
        System.arraycopy(xs.array, 0, array, 0, xs.length) 
        // ok             --- when via update
        // failure with java.lang.ArrayStoreException --- when via updateOne
        
        println("== ok ==")
      case _ =>
    }
  }
}

{code}
