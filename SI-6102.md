The following class throws `VerifyError` when running with `-optimize`. It's in *inline exception handlers*, since it works fine if I pass `-Yskip:inlineExceptionHandlers` (or if I add something in the `finally` block, like a dummy println).

{code}
class Foo {
	lazy val x = try { 10 } finally ()

	def main(args: Array[String]) {		
	}
}
{code}

and the output:
{code}
Exception in thread "main" java.lang.ClassFormatError: Illegal exception table range in class file Foo
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClassCond(ClassLoader.java:631)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:615)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:141)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:283)
	at java.net.URLClassLoader.access$000(URLClassLoader.java:58)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:197)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:247)
	at scala.tools.nsc.util.ScalaClassLoader$$anonfun$tryClass$1.apply(ScalaClassLoader.scala:43)
	at scala.tools.nsc.util.ScalaClassLoader$$anonfun$tryClass$1.apply(ScalaClassLoader.scala:43)
	at scala.util.control.Exception$Catch$$anonfun$opt$1.apply(Exception.scala:113)
	at scala.util.control.Exception$Catch$$anonfun$opt$1.apply(Exception.scala:113)
	at scala.util.control.Exception$Catch.apply(Exception.scala:97)
	at scala.util.control.Exception$Catch.opt(Exception.scala:113)
	at scala.tools.nsc.util.ScalaClassLoader$class.tryClass(ScalaClassLoader.scala:42)
	at scala.tools.nsc.util.ScalaClassLoader$class.tryToLoadClass(ScalaClassLoader.scala:37)
	at scala.tools.nsc.util.ScalaClassLoader$URLClassLoader.tryToLoadClass(ScalaClassLoader.scala:139)
	at scala.tools.nsc.util.ScalaClassLoader$.classExists(ScalaClassLoader.scala:162)
	at scala.tools.nsc.GenericRunnerCommand.scala$tools$nsc$GenericRunnerCommand$$guessHowToRun(GenericRunnerCommand.scala:34)
	at scala.tools.nsc.GenericRunnerCommand$$anonfun$2.apply(GenericRunnerCommand.scala:51)
	at scala.tools.nsc.GenericRunnerCommand$$anonfun$2.apply(GenericRunnerCommand.scala:51)
{code}
Yaay, not a problem in inlineExceptionHandlers:
{code}
$ cat test.scala
class Foo {
  try { 
    val x = 3
  } finally {
    print("hello") 
  }
}
$ scalac -Ydead-code test.scala
$ java Foo
Exception in thread "main" java.lang.ClassFormatError: Illegal exception table range in class file Foo
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClassCond(ClassLoader.java:631)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:615)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:141)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:283)
	at java.net.URLClassLoader.access$000(URLClassLoader.java:58)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:197)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
Could not find the main class: Foo.  Program will exit.
{code}
A couple of details on the problem: It stems from the fact that certain ICODE instructions have no JVM counterparts: instructions such as LOAD_EXCEPTION, SCOPE_ENTER, SCOPE_EXIT and JUMP to the next basic block in the linearization will not be emitted by genJvm or genAsm. 

If we form an entire basic block of such instructions and have an exception handler on it, the generated bytecode will be incorrect, as the exception handler will have an empty scope: thus the Illegal exception table range message.

There are many ways one can compose an no-jvm-instruction basic block: in the bug description, the basic block generate by inline exception handlers was:
{code}
bbX:
    LOAD_EXCEPTION(class Throwable) // <= no JVM instruction necessary for LOAD_EXCEPTION
    STORE_LOCAL(variable exc1)      // <= eliminated as dead code
    LOAD_LOCAL(variable exc1)       // <= eliminated as dead code
    JUMP bb(X+1)                    // <= JUMP to the next basic block in the linearization was skipped
bb(X+1):
    ...
{code}
and bbX was protected by another exception handler - so for the JVM, that exception handler was protecting nothing.

In the second example, the ICODE instructions are:
{code}
bbX:
    CONSTANT(3)          // <= eliminated as dead code
    STORE_LOCAL(value x) // <= eliminated as dead code
    SCOPE_ENTER value x  // <= no JVM instruction necessary for SCOPE_ENTER
    SCOPE_EXIT value x   // <= no JVM instruction necessary for SCOPE_EXIT
    JUMP bb(X+1)         // <= JUMP to the next basic block in the linearization was skipped
bb(X+1):
    ...
{code}

So my take on this bug is that it should be fixed in genJvm/genAsm: keep track of the basic blocks that have no instruction emitted and if an exception handler interval only consists of empty blocks, remove the interval.
