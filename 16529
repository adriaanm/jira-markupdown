Compile the following:

{code:title=testinherit.scala}
abstract class A {
  type Foo
  def bar(foo: Foo)
}

class BFoo {
}

class CFoo extends BFoo {
}

class B extends A {
  type Foo = BFoo
  def bar(foo: Foo) {
    println("B called")
  }
}

class C extends B {
  override type Foo = CFoo
  override def bar(foo: Foo) {
    super.bar(foo)
    println("C called")
  }
}
{code}

Result when compiling:

{noformat}
$ scalac testinherit.scala
testinherit.scala:22: error: ambiguous reference to overloaded definition,
both method bar in class B of type (foo: C.this.Foo)Unit
and  method bar in class A of type (foo: C.this.Foo)Unit
match argument types (C.this.Foo)
    super.bar(foo)
          ^
one error found
{noformat}

This error is, at the very least, extremely cryptic.

I encountered this recently and eventually figured out that I couldn't quite do what I was trying to do in code like the above.  Rather, I have to write class B like this:

{noformat}
abstract class B extends A {
  override type Foo <: BFoo
  def bar(foo: Foo) {
    println("B called")
  }
}
{noformat}

However, it took me a **long** time to figure this out.  The above error simply makes no sense whatsoever, because class A is totally abstract and class B is a subclass of A -- how could there possibly be an overload clash between a given class and its completely abstract parent?
