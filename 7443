I finally came up with an implementation based on type classes for now (didn't have the time to get into the vastness of information needed for implementing this directly for scala.collection._):

  https://github.com/wookietreiber/scala-collection-extras

The main part consists of this:
```scala
  def merge[A:Ordering](xs: CC[A], y: A) = { 
    val (ps,ss) = xs.partition(implicitly[Ordering[A]].lt(_,y))
    val builder = xs.genericBuilder[A]
    builder ++= ps.seq
    builder  += y
    builder ++= ss.seq
    builder.result.asInstanceOf[CC[A]]
  }   

  @tailrec
  def mergeAll[A:Ordering](xs: CC[A], ys: CC[A]) =
    if (ys.isEmpty) xs else mergeAll(merge(xs,ys.head), ys.tail.asInstanceOf[CC[A]])

  def sort[A:Ordering](xs: CC[A]) =
    xs.aggregate(xs.genericBuilder[A].result.asInstanceOf[CC[A]])(merge, mergeAll)

  def shuffle[A](xs: CC[A]): CC[A] =
    sortBy(xs) { _ â‡’ nextLong }
```

An example is included in the github projects README. 

Since all thats required are partition, aggregate, head tail decomposition and a builder I expect this to work with all collections.

The shuffle is just a straightforward implementation based on sorting by a random number.
