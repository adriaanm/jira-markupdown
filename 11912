I'm surprised that the order of named constants does matter for the generated code. The arguments and their target order are known at compile-time, so why does that lead to more code? I guess maybe that's because argument evaluation has side effects and they should not be changed by the reordering? But that amounts to translating 


{code:java}
       new Event (  day = M1, month = M2, year = M3, weekday = M4, ... )

{code}

to something like


{code:java}
   val d = M1
   val m = M2
   val y = M3
   val w = M4 
   ...
   new Event ( y, m, w, d )
{code}


and should not generate that much new code.

----

I also don't think a 1K LoC file should force a compiler out of memory. What's the root cause of this exceptional memory usage? An unprotected simple recursion instead of tail recursion?

