Here's a case which involves higher-kinded types but no (explicit) raw types. 

It's when the compiler tries to find a `Foo` for `Tuple2[Int, Int]` that it crashes.  Put in another type at the `implicitly`, and it reports "could not find implicit value" as you'd expect.  Actually having an implicit available doesn't make any difference; the crash still occurs.
```scala
import scala.{collection => sc}

object Test {
  trait Foo[T]

  // Haven't managed to repro without using a CanBuild or CanBuildFrom implicit parameter
  implicit def MapFoo[A, B, M[A, B] <: sc.Map[A,B]](implicit aFoo: Foo[A], bFoo: Foo[B], cb: sc.generic.CanBuild[(A, B), M[A, B]]) = new Foo[M[A,B]] {}

  // implicit object Tuple2IntIntFoo extends Foo[(Int, Int)] // no difference if this line is uncommented
  // implicit def Tuple2Foo[A, B] = new Foo[(A, B)] {}       // nor this one

  implicitly[Foo[(Int, Int)]]
}
```
