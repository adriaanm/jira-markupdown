One pattern used with macros is to have an unimplemented stub method that is valid only in the context of a macro and is then removed by that macro:

{code:lang=java}
trait Task[T] {
  def value: T = ???
}

val foo: Task[Int] = ...

val t: Task[Int] = task {
  foo.value + 1
}
```scala

The problem is that use of `value` outside of the macro is not caught at compile time, but at runtime.  For example, the following throws an exception at runtime because value is not used within the task macro that would otherwise remove the call to it.

{code:lang=java}
val foo: Task[Int] = ...
val i: Int = foo.value
```

The proposed solution is to have an annotation or some other way of telling the compiler that calls to `value` that survive typechecking are an error.  For example,

{code:lang=java}
   @compileTimeOnly("Calls to `value` must be made inside the the task macro.")
   def value: T = ???
{code}

This would be useful for standard macro-related methods like splice as well.
