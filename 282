I don't think this will work -- we'd need to pack an implicit with the existential value. This would mean that existential wrappers can change the representation of a type which seems undesirable. Better just use a dependent type:

type Wrapper {
  type T
  implicit def view(x: T): Int
  val x: T 
}

