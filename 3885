Is this the same problem:

  http://gist.github.com/444680

I want one of the implicit conversions to be rejected as it results in a type that can't satisfy the context bound. But maybe I'm asking too much :)

This is the motivating example from Scalaz:
{code}

trait Identity[A] {
  def mapply[F[_], B](f: F[A => B])(implicit ftr: Functor[F]): F[B] = f âˆ˜ (_(value))
}
{code}


{code}
scala> 1.mapply(Seq((_: Int) * 2))               
res5: Seq[Int] = List(2)

scala> 1.mapply[Identity, Int]((_: Int) * 2)
res6: scalaz.Identity[Int] = 2

scala> 1 mapply ((_: Int) * 2)              
<console>:12: error: type mismatch;
 found   : (Int) => Int
 required: ?F[ (Int) => ?B ]
Note that implicit conversions are not applicable because they are ambiguous:
 both method IdentityTo in trait Identitys of type [A](x: A)scalaz.Identity[A]
 and method any2ArrowAssoc in object Predef of type [A](x: A)ArrowAssoc[A]
 are possible conversion functions from (Int) => Int to ?F[ (Int) => ?B ]
       1 mapply ((_: Int) * 2)
         ^
{code}
