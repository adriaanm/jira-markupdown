I think this is working as designed as per SLS 6.1: "The following skolemization rule is applied universally for every expression: If the type of an expression would be an existential type T, then the type of the expression is assumed instead to be a skolemization of T." pair._1 and pair._2 get two different skolems which then don't match.

You can pattern match instead; this compiles:

{code:scala}
pair match { case (f, x) => f(x) }
{code}

You might also be interested in http://stackoverflow.com/a/39061519/86485 which is similar.
