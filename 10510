dumping my brain/debugging session:

{code}
trait Thing { type A }
trait View[AIn] {
  val in: Thing { type A = AIn }
  type Bla = in.A // 
}

val view = typeOf[View[Int]]
val bla = view.member(newTypeName("Bla"))

view.memberType(bla)

Types$AliasNoArgsTypeRef(Types$Type).asSeenFrom(Types$Type, Symbols$Symbol) line: 661	
  this	Types$AliasNoArgsTypeRef  (id=6373)	View.this.Bla
  pre	Types$ClassArgsTypeRef  (id=6357)	 View[Int]
  clazz	Symbols$ClassSymbol  (id=6374)	trait View
  tp	Types$AliasNoArgsTypeRef  (id=6478)	 _4.Bla // the existential that captures View.this  <: View[Int] with Singleton
  
Types$class.existentialAbstraction(SymbolTable, List, Types$Type) line: 3662	
  tpe0	Types$AliasNoArgsTypeRef  (id=6478)	 _4.Bla
  
TypeMaps$normalizeAliases$.apply(Types$Type) line: 22	
  tp	Types$AliasNoArgsTypeRef  (id=6478)	_4.Bla
  
Types$AliasNoArgsTypeRef(Types$TypeRef).normalize() line: 2277	
  this: _4.Bla


Types$AliasTypeRef$class.betaReduce(Types$AliasTypeRef) line: 2183	
  this: _4.in.A
  
Types$AliasNoArgsTypeRef(Types$NoArgsTypeRef).transform(Types$Type) line: 2081	
  tp: AIn
...
Types$AbstractNoArgsTypeRef(Types$Type).asSeenFrom(Types$Type, Symbols$Symbol) line: 660	
  this: AIn
  pre: View.<refinement>.type
  clazz: <refinement of Thing> // UHOH, does not own AIn, nor do any of its superclasses
{code}
