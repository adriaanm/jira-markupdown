bug1001 failed because the existential type that's constructed by  `mergePrefixAndArgs` does not meet the f-bounds.

Compiler output (edited to remove irrelevant stuff -- with printLubs enabled and some diagnostics in mergePrefixAndArgs):
```scala
lub of List(D, C) at depth 2
  lub of List(D, C) at depth 1
    lub of List(D, C) at depth 0
    lub of List(D, C) is A
MPAA of: List(B[D], B[C])
MPAA(params, sym, args) = (List(type _1 >: D with C <: A),trait B,List(_1))
  lub of List(D, C) is B[_ >: D with C <: A]
MPAA of: List(B[D], B[C])
MPAA(params, sym, args) = (List(type _2 >: D with C <: B[_ >: D with C <: A]),trait B,List(_2))
lub of List(D, C) is B[_ >: D with C <: B[_ >: D with C <: A]]

/Users/adriaan/git/scala/test/files/pos/ticket2251.scala:22: error: type arguments [_1] do not conform to trait B's type parameter bounds [T <: B[T]]
  val data: List[A] = List(new C, new D)
                      ^
one error found
```

Maybe this is the expected behaviour then? Should we focus on providing a better error message and leave mergePrefixAndArgs as it was?

Anyway, the inferred type is:

`B[_2] forSome { type _2 >: D with C{} <: B[_1] forSome { type _1 >: D with C{} <: A } }`  (not well-formed)

instead of the well-formed:

`B[_2] forSome { type _2  <: B[_2]}`

it's interesting that this first type is the unrolling (up to a certain depth) of the second one -- there's probably no complete algorithm to detect this and "roll the type back up", though... (is there?)  


I'm not sure whether this could work, but maybe we could improve mergePrefixAndArgs so that it detects f-bounds (with a more robust check) and then takes the type schema and replaces the type parameters by existentials?

E.g.,  `Foo[T <: Foo[U, U], U <: T]` would become `Foo[A, B] forSome {type A <: Foo[B, B]; type B <: A}`. As a further refinement, we could take the lub and glb of the type arguments that Foo was applied to and add them to the bounds of the type variables of the existential.
