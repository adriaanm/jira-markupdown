Just in case anyone is looking for a workaround, you can re-implement pattern matching as a library, at the expense of some ugly type annotations on the list of cases.

{code}
import Stream._

object diyMatcher {
  def crashNoMore[A](lefts: Stream[A], rights: Stream[A]) = {
    val cases: List[PartialFunction[(Stream[A], Stream[A]), Option[_]]] = List(
      {case (Stream.Empty, Stream.Empty) => None},
      {case (l #:: ls, rs) => None}
    )
    (lefts, rights) `match` cases
  }

  trait Matchable[A] { 
    def `match`[B](cases: Seq[PartialFunction[A, B]]): B
  }
  
  implicit def anyToMatchable[A](a: A): Matchable[A] = new Matchable[A]{
    def `match`[B](cases: Seq[PartialFunction[A, B]]) = {
      cases match {
        case Nil => throw new MatchError(a)
        case x :: _ if x.isDefinedAt(a) => x(a)
        case _ :: xs => a `match` xs
      }
    }
  }
}
{code}

