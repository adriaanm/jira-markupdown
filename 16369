Calling "loop" within another "loop" statement results in a reference being kept to the previous closure. Attached is a simple example showing this behavior.

**Expected behavior**:
The script continues running indefinitely, 

**Actual behavior**:
A java.lang.OutOfMemoryError: Java heap space is thrown.
```scala
import actors._
import Actor._

case object A
case object B

def doLoop(i: Int) {
  loop {
    react {
      case A => println(i)
      case B => doLoop(i + 1)
    }
  }
}

val a = actor { doLoop(0) }

while(true) {
  (1 to 5000).foreach { i => a ! B }
  a ! A
}
```
