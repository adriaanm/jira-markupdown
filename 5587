I just verified it with BigInt too. 
The check fails for inclusive ranges where end == -(start+1). 

The bug is in NumericRange.count:
```scala
193	    val longCount: Long =
194	      if (start == end) { if (isInclusive) 1 else 0 }
195	      else if (end > start != step > zero) 0
196	      else {
197	        val jumps     = toLong((end - start) / step) // <-------
198	        val remainder = toLong((end - start) % step)
199	       
200	        if (!isInclusive && zero == remainder) jumps
201	        else jumps + 1L
202	      }
203	   
204	    if (longCount > scala.Int.MaxValue || longCount < 0L)
205	      throw new IllegalArgumentException("Seqs cannot contain more than Int.MaxValue elements.")
```
