Using this very simple piece of code
    
```scala
    import java.util.Properties

    class MyProperties extends Properties

    object MyProperties {
    
        def get(): MyProperties = new MyProperties
    
        def anotherMethod(): MyProperties = new MyProperties
    
    }
```

the `get()` method is missing in the compiled code; a Java decompilation of the `MyProperties` class yields (scala signature omitted)

```scala
    import java.util.Properties;
    import scala.reflect.ScalaSignature;

    public class MyProperties extends Properties
    {
      public static MyProperties anotherMethod()
      {
        return MyProperties..MODULE$.anotherMethod();
      }
    }
```

If `MyProperties` does not extend `java.util.Properties` however, the `get()` method is generated.

`java.util.Properties` inherits the `public V get(Object key)` from `java.util.Dictionary` but that is a non static method with a different signature and this "works" in Java

```scala
    import java.util.Properties;

    public class MyPropertiesjava extends Properties {
  
        private static final long serialVersionUID = 1L;
	
        public static MyProperties get() {
    	
    	    return new MyProperties();
        }
    
        public static MyProperties antotherMethod() {
    	
    	    return new MyProperties();
        }
    }
```

A suggested workaround using `type` (author RÃ©gis Jean-Gilles) is stated below, but there does not seem to be a JVM related reason no to generate the `get` method

```scala
    import java.util.Properties

    type MyProperties = MyPropertiesImpl

    class MyPropertiesImpl extends Properties

    object MyProperties {    
        def get(): MyProperties = new MyPropertiesImpl
        def anotherMethod(): MyProperties = new MyPropertiesImpl
    }
```

(sorry for the lack of rendered formatting)

This is due to a Java limitation. In your original code, there's an inherited get method from HashTable that differs only in result type. http://stackoverflow.com/questions/9439379/why-does-java-enforce-return-type-compatibility-for-overridden-static-methods

Please experiment with variations on the following minimal example to see the error more directly.

```scala

class Super {
  // uncomment this and comment the last definition of get for the original report
  // def get(): Any = null
}

class Foo extends Super

object Foo {
  // no static forwarder generated in Foo when there's already one in Super
  def get(): Foo = new Foo
  // can't have two static methods with signatures that differ only in their return type
  def get(): Any = null
}
```
I re-open this because get() is NOT a static method on HashMap. What you describe is true for static methods collisions only.

Actually, this is exactly the opposite: it is a Scala limitation; java does not have this limitation. For proof consider this

In Scala
```scala
import java.util.HashMap

class HashMapScala extends HashMap[ String, String ] {

}

object HashMapScala {
    
    def get() : String = "dummy"
}
```

In java

```scala
import java.util.HashMap;


public class HashMapJava extends HashMap<String, String> {

    private static final long serialVersionUID = 1L;

	public static String get() {
		
		return "dummy";
	}
}
```

In java, the static get() method is available in the the compiled code along with the non static get() method inherited from Hashmap.
The static get() method is not available in the compiled code generated by the Scala compiler.

My bet is that the scala compiler only checks for method name collisions but does not check, as it should and javac does, for the methods signature: method name AND arguments. Only in the latter case you cannot have both a static and non static method generated.
Yes, that's what it does:

https://github.com/scala/scala/blob/v2.10.0/src/compiler/scala/tools/nsc/backend/jvm/GenASM.scala#L1161

The method is accessible to Java via `MyProperties.MODULE$.get()`.
