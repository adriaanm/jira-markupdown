I have finally tried benchmarking the existing ScalaRunTime._hashCodeJenkins in 2.8.0.Beta1. It runs about 15 - 200 times (!) as slow as ScalaRunTime._hashCode. So I've tried a reimplemented Jenkins algorithm, as well as some other well-known hash algorithms.

Austin Appleby, author of MurmurHash2, ran some quality tests on several hash algorithms: MurmurHash2, Bob Jenkins's lookup3, FNV, and Paul Hsieh's SuperFastHash (at http://sites.google.com/site/murmurhash/statistics). Of these four algorithms, only MurmurHash2 and lookup3 performed well on all tests; FNV and SuperFastHash have distributions that are poor by at least some measures.

On my machine, MurmurHash2 runs faster than lookup3, by about 10% - 40%, depending on what is being hashed. MurmurHash2 uses lots of multiplies, and lookup3 lots of rotates, so different relative speeds of those operations might lead to different results on different machines.

I've coded both algorithms to take a Product argument and to avoid the allocation of temporary objects, other than those required for boxing when calling Product.productElement. Judging from the lack of apparent effect from the -XX:+DoEscapeAnalysis switch in JDK 6 update 17, it may be premature to expect VMs with escape analysis to eliminate concerns about such allocations in
time-critical code.

I also coded versions of the data structures I hashed to implement a trait that looks like this:
```scala
    trait Hashable {
      def hashableInts: Int
      def hashableInt (n: Int): Int
    }
```

and coded versions of the hash algorithms to call the methods in it to obtain the contents of the data structures as a sequence of 32-bit integers, thereby avoiding any allocations during hashing. As expected, this resulted in a substantial speedup, of as much as 500%. However, it is not clear that it would be worth changing Product (for example) to include such methods, particularly since a superior hash algorithm may one day appear that consumes its input in
something other than 32-bit chunks. (Scala should certainly avoid the mistake of java.lang.String, which promises a specific, and decidedly low-quality, hash function.)

Attached are implementations of lookup3 and MurmurHash2 for Product and String, which might be useful to replace the existing ScalaRunTime._hashCode.
