Nope. See this:


{code}

object A {
  class C
  class D
  
  class O(x: D)
  
  implicit def toD(x: C) = new D
  
  implicit object O extends O(new C) with (D => C) {
    def apply(v1: D): C = new C
  }
  
  class H(x: C)
  
  implicit object H extends H(new D) with (C => D){
    def apply(v1: C): D = new D
  }
  
}
{code}

That compiles. But, if you move the implicit conversion definition to the point after where it's needed, you get an error:

{code}

object A {
  class C
  class D
  
  class O(x: D)
  
  implicit object O extends O(new C) with (D => C) {
    def apply(v1: D): C = new C
  }
  
  class H(x: C)
  
  implicit object H extends H(new D) with (C => D){
    def apply(v1: C): D = new D
  }
  
  implicit def toD(x: C) = new D
  
}
{code}

{code}
t5197.scala:11: error: type mismatch;
 found   : A.C
 required: A.D
 Note: implicit method toD is not applicable here because it comes after the application point and it lacks an explicit result type
  implicit object O extends O(new C) with (D => C) {
                              ^
one error found
{code}

So this doesn't have to do with implicit objects per se.
