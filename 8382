First, if overloading isn't allowed, that should be explicitly checked at definition time so a proper error can be generated.  Structuring the parameter lists to cause an error at the usage site unnecessarily delays feedback to the applyDynamic author.

For overloading being potentially desirable, I figured that the straightforward design of having an actual ApplyDynamic interface with a fixed signature like:

{code:lang=java}
trait ApplyDynamic {
 def applyDynamic(name: String, a: Any*)
}
{code}

was because it was deemed useful to be able to fix the number of arguments and use specific types for the parameters, like:

{code:lang=java}
 def applyDynamic(name: String, a: Int, b: Double)
{code}

because the compiler will then check whether a call is applicable as usual, saving the applyDynamic author some of the work of checking argument count, types, and giving names to arguments.  So, assuming fixing the parameter count and types is considered useful and given that Scala supports overloading, it seemed odd to have an inconsistency with the rest of Scala here.  Otherwise, why not just define and require the ApplyDynamic interface above?

I didn't mark it as critical, but if there is anything critical about it, I'd guess it might be a decision on what to do, since that could require incompatible changes.
