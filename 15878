scala.concurrent.SyncVar should not silently swallow InterruptedException within its get(Long) method. As the matter of fact it should not catch the exception at all (same as get() method does), considering that SyncVar.get() can perform no useful processing for the exception here: at very least, it should reraise the Thread.currentThread.interrupt() flag after catching the exception, but this is still bad as it results in aliasing None result for two things 'timeout happened' and 'thread was interrupted' keeping the calling code still unaware of the possibly pending interrupt.

While here, I see yet another problem in the same method: the get(Long) method uses if (!isDefined) instead of while (!isDefined) thus is vulnerable against spurious wakeups (which JLS explicitly allows to happen). Unfortunately the Object.wait(Long) does not report remaining timeout, so the correct implementation of the method looks a little bit complicated:

{code}
def get(timeout: Long): Option[A] = synchronized {
	var rest = timeout
	while (!isDefined && (rest > 0)) {
		val t0 = System.currentTimeMillis
		wait(timeout)
		if (!isDefined) {
			val t1 = System.currentTimeMillis
			val tdiff = t1 - t0
			if (tdiff > 0) rest -= tdiff // protect against system clock changed into past
			// if system clock jumped into future, detecting that will be harder,
			// but at least it will not result in arbitrary increase of timeout
		}
	}
	if (isDefined) Some(value)
	else None
}
{code}

Note: this implementation does not follow the unfortunate java notation of 'zero timeout means infinitely long'. Instead, zero means exactly that - 'do not wait at all', while 'infinitely long' is naturally represented by Long.MaxValue for all practical senses (but even better to call get() if waiting forever (or till interrupt()) is needed). This change should be ok considering that SyncVar never carried scaladoc promising any non-monotonic behaviour with zero timeout.

The time math can be redone by using java.util.concurrent.locks.Cond.awaitNanos(long) method (which returns remaining time to sleep), if using that class does not breach any scala policy. Unfortunately, awaitNanos(long) operates in terms of nanoseconds not milliseconds, so some math will still be needed for large values including Long.MaxValue (but the extra gettimeofdate syscall or equivalent could be avoided, at least on some systems). But if to silently clump (or disallow) huge timeouts downto Long.MaxValue/1000000 (ms-to-ns ratio; that's almost 300 years if I still am able to count), the loop will become trivial. BTW Cond is exactly what is emulated with object lock in the current SyncVar implementation.
