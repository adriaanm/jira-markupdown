Calling the same compiled Scala code with `"scala CLASSNAME"` and from
the REPL results in different runtime performance.  

The the following simple loop speed test was used.

`ForLoopScala.scala`:
```scala
object ForLoopScala {
  def run(): Unit = {
    val t1 = java.lang.System.nanoTime()
    var x:Int = 0
    for (i <- 1 to 1000000000) x = x/2+5
    val t2 = java.lang.System.nanoTime()
    val totalTime = (t2 - t1) * 1E-9d
    println("result = " + x + ", time = " + totalTime)
  }

  def main(args: Array[String]) {
    while (true) {
      run()
      Thread.sleep(1000)
    }
  }
}
```

Compiling the class with scalac and executing from console yield the following
runtime behaviour:
```scala
$$ scalac ForLoopScala.scala && scala ForLoopScala

result = 9, time = 2.891358464
result = 9, time = 2.8058508900000003
result = 9, time = 2.797509938
result = 9, time = 2.798401755
result = 9, time = 2.797242445
```


Calling the same compiled class from the REPL is significantly slower:
```scala
$$ scala
Welcome to Scala version 2.8.0.final (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_20).

scala> ForLoopScala.main(Array.ofDim[String](0))
result = 9, time = 9.13641963
result = 9, time = 7.214275783000001
result = 9, time = 7.212255825000001
result = 9, time = 7.213397081
result = 9, time = 7.210866085
```

Does the REPL re-tune the JVM differently?

I'm not quite sure what's the correct category for this, so I'm putting it as a defect under "Interpreter and scripts". Is it even a defect? :-)


As a side note, a simple translation to Java also produces
interesting results:

`ForLoopJava.java:`
```scala
class ForLoopJava {
	static void run() {
		long t1 = java.lang.System.nanoTime();
		int x = 0;
		for (int i = 0; i < 1000000000; ++i) x = x/2+5;
		long t2 = java.lang.System.nanoTime();
		double totalTime = (t2 - t1) * 1E-9d;
		System.out.println(x);
		System.out.println("result = " + x + ", time = " + totalTime);
	}

	public static void main(String[] args) {
		while (true) {
			run();
			try {Thread.sleep(1000);}
			catch(Exception e) {}
		}
	}
}
```
```scala
$$ javac ForLoopJava.java && java ForLoopJava

result = 9, time = 2.7969517120000003
result = 9, time = 4.452042181
result = 9, time = 9.400000000000001E-8
result = 9, time = 9.400000000000001E-8
result = 9, time = 1.08E-7
```

Obviously, in the Java case, Hotspot is able to pull some trick after the
second iteration it can't do with the scala-generated bytecode.


System information:
```scala
$$ scala -version
Scala code runner version 2.8.0.final -- Copyright 2002-2010, LAMP/EPFL

$$ java -version
java version "1.6.0_20"
Java(TM) SE Runtime Environment (build 1.6.0_20-b02)
Java HotSpot(TM) 64-Bit Server VM (build 16.3-b01, mixed mode)

$$ uname -a
Linux host 2.6.31-22-generic SI-63-Ubuntu SMP Thu Aug 19 00:23:50 UTC 2010 x86_64 GNU/Linux
```
