In scala-library.jar of Scala 2.11.2, a number of classes (165 to be precise) have Signature attributes that are inconsistent with their interfaces.

For instance, scala.Tuple1 has one superclass
  java/lang/Object

and 2 direct interfaces:
  scala/Product1
  scala/Serializable

At the same time, it has this signature (adding whitespace for clarity):
  <T1:Ljava/lang/Object;>
  Ljava/lang/Object;
  Lscala/Product1<TT1;>;
  Lscala/Product;
  Lscala/Serializable;

Note the 3 interface types, including the spurious "Lscala/Product;". The tool javap incorrectly lists it as a direct interface.

This seems to go against The Java Virtual Machine Specification, section 4.7.9.1: "A class signature encodes type information about a (possibly generic) class declaration. It describes any type parameters of the class, and lists its (possibly parameterized) direct superclass and direct superinterfaces, if any."

In practice, the problem triggers a crash in ProGuard 5.0, with an ArrayIndexOutOfBoundsException.

My apologies if this is a known issue; I haven't found it anywhere.

Eric Lafortune -- developer of ProGuard
Hmm, I don't get it, isn't it the same from Java? If you directly implement an interface ({{scala.Product}} here), and *also* indirectly implement it through something else (here {{scala.Product1\[T\] extends scala.Product}}), then it does appear in the resulting classfile.

As in:

{code}
==> A.java <==
import java.io.Serializable;

public class A<T> implements Product1<T>, Product, Serializable {}

==> Product.java <==
public interface Product {}

==> Product1.java <==
public interface Product1<T> extends Product {}
{code}
{code:bash}
% javap -v A.class
[...]
#12 = Utf8               <T:Ljava/lang/Object;>Ljava/lang/Object;LProduct1<TT;>;LProduct;Ljava/io/Serializable;
{code}

Note that {{Tuple1}} directly implements {{Product}} because it is a case class:
{code}
case class Tuple1[+T](_1: T) extends Product1[T]
{code}
is syntactic sugar for this:
{code}
class Tuple1[+T] extends AnyRef with Product1[T] with Product with Serializable { <autogenerated members> }
{code}
Looking at the compiled bytecode, {{Product}} really isn't listed as a direct interface. I presume the scalac compiler has removed it (but not from the Signature). The tool javap confusingly lists the generic direct interfaces, not the plain direct interfaces.

With a lower-level tool, you should see the actual interfaces. E.g. with ProGuard's {{-dump}} option:

{code}
java -jar proguard5.0/lib/proguard.jar \
  -dontshrink \
  -dontoptimize \
  -dontobfuscate \
  -dontpreverify \
  -dump \
  -injars lib/scala-library.jar'(scala/Tuple1.class)' \
| less
{code}

You'll then see
{code}
- Program class: scala/Tuple1
  Superclass:    java/lang/Object
.....
Interfaces (count = 2):
  - Class [scala/Product1]
  - Class [scala/Serializable]

.....
  - Signature attribute:
    - Utf8 [<T1:Ljava/lang/Object;>Ljava/lang/Object;Lscala/Product1<TT1;>;Lscala/Product;Lscala/Serializable;]
{code}
Tools like asm or jad may provide the same information. Other tell-tale sign: {{scala/Product}} isn't present as a class constant in the bytecode.
bq. {{scala/Product}}  isn't present as a class constant in the bytecode.
Oh, I had completely missed that; that's very wrong.  And it happens for any interface:

{code}
trait Foo

trait Foo1 extends Foo

class A extends Foo1 with Foo
{code}
{code:bash}
% javap -v A.class | grep '= Class.*Foo' # where is Foo...
#6 = Class              #5             // Foo1
{code}

This seems to have regressed in Scala 2.9.2:

{code:bash}
% java -jar ~/Downloads/proguard5.0/lib/proguard.jar \
  -dontshrink \
  -dontoptimize \
  -dontobfuscate \
  -dontpreverify \
  -dump \
  -injars ~/scaladev/packs/scala-v2.9.1-1/pack/lib/scala-library.jar'(scala/Tuple1.class)' \
  | grep 'Interfaces' -A 4
Interfaces (count = 4):
  - Class [scala/Product1]
  - Class [scala/ScalaObject]
  - Class [scala/Product]
  - Class [scala/Serializable]
% java -jar ~/Downloads/proguard5.0/lib/proguard.jar \
  -dontshrink \
  -dontoptimize \
  -dontobfuscate \
  -dontpreverify \
  -dump \
  -injars ~/scaladev/packs/scala-v2.9.2/pack/lib/scala-library.jar'(scala/Tuple1.class)' \
  | grep 'Interfaces' -A 4
Interfaces (count = 2):
  - Class [scala/Product1]
  - Class [scala/Serializable]

Constant Pool (count = 184):
{code}
The jvms does say:

bq. Oracle's Java Virtual Machine implementation does not check the well-formedness of Signature attributes during class loading or linking. Instead, Signature attributes are checked by methods of the Java SE platform class libraries which expose generic signatures of classes, interfaces, constructors, methods, and fields. Examples include getGenericSuperclass in Class and toGenericString in java.lang.reflect.Executable.
(§4.7.9 in jdk8, and something similar at $4.3.4 in jdk7)

But even java reflection seems fine with it:

{code}
scala> val c = classOf[Tuple1[String]]
c: Class[(String,)] = class scala.Tuple1

scala> c.getInterfaces
res0: Array[Class[_]] = Array(interface scala.Product1, interface scala.Serializable)

scala> c.getGenericInterfaces
res1: Array[java.lang.reflect.Type] = Array(scala.Product1<T1>, interface scala.Product, interface scala.Serializable)
{code}
So apparently this was done on purpose, in [7a99c03|https://github.com/scala/scala/commit/7a99c03da1d31ac5950eecb30f422f43c5e3d04e] (SI-5278) to "ease trouble on android".

So either it shouldn't do it at all, or it should do it properly (for both the signature and the interface list).
