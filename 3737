I did not realize it behaved as expected for a block when the conversion is triggered by a missing member.  That is certainly useful and not problematic.

The problem I was trying to address is restricted to when the conversion is to an expected type.  For example, this prints "side effect 1":

{code}
object ExpectedType {
  implicit def runnable(act: => Unit): Runnable =
    new Runnable { def run() = act }

  def main(args: Array[String]) {
      val runnable: Runnable =
      {
          println("side effect 1")
          println("side effect 2")
      }
      
      if(false)
          runnable.run()
  }
}
{code}

Since the two cases are handled separately in the specification, what about specifying that implicits with by-name parameters are not considered for this case (situation 1 in the spec)?
