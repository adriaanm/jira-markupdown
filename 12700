The difference is that the anon fun is:

{code}
        val res0 = ((x$1) => {
          final class $anon extends B(x$1) {
            def <init>() = {
              super.<init>();
              ()
            };
            <empty>
          };
          new $anon()
        })
      }

{code}
as opposed to
{code}
val res1 = ((x$1) => new A(x$1))
{code}

It's not obvious that "local type inference" should propagate to the enclosing scope. Maybe it could be made to work by detecting the pattern.
