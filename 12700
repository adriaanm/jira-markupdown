The difference is that the anon fun is:
```scala
        val res0 = ((x$1) => {
          final class $anon extends B(x$1) {
            def <init>() = {
              super.<init>();
              ()
            };
            <empty>
          };
          new $anon()
        })
      }
```
as opposed to
```scala
val res1 = ((x$1) => new A(x$1))
```

It's not obvious that "local type inference" should propagate to the enclosing scope. Maybe it could be made to work by detecting the pattern.
