Here's a reduced version that also fails. Removing the inner match makes it pass the typer. Replacing the extractors with tuple patterns makes it pass the typer but will cause a crash in ParallelMatching during explicit outer.
{code}
object NonEmptyCons {
  def unapply[H, T](c: (H, T)): Option[(H, T)] = Some(c)
}


object Main {

  type BT[+H, +T <: Tuple2[Tuple2[H, T], Tuple2[H, T]]] = Tuple2[H, T]
  
  type BinaryTree[+E] = BT[E, T forSome {type T <: Tuple2[BT[E, T], BT[E, T]]}]

  def foo[E](tree: BinaryTree[E]): Unit = tree match {
    case NonEmptyCons(_, tail) => {
      tail match {
        case NonEmptyCons(_, _) => {
        }
      }
    }
  }
}

{code}
