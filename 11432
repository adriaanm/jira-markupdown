Right you are...

FWIW, here's a somewhat facile counter example:

{quote}
A singleton type is of the form p.type, where p is a path pointing to a value expected to conform (ยง6.1) to scala.AnyRef. The type denotes the set of values consisting of null and the value denoted by p.
{quote}

{code}
scala> { val p = 0; implicit def intToString(i: Int) = ""; type T = p.type }
<console>:8: error: type mismatch;
 found   : p.type (with underlying type Int)
 required: AnyRef
              { val p = 0; implicit def intToString(i: Int) = ""; type T = p.type }
                                                                           ^
{code}

I suppose the unwritten detail is whether or not implicit conversions are allowed in a particular context.
