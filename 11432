Right you are...

FWIW, here's a somewhat facile counter example:
```
A singleton type is of the form p.type, where p is a path pointing to a value expected to conform (ยง6.1) to scala.AnyRef. The type denotes the set of values consisting of null and the value denoted by p.
```
```scala
scala> { val p = 0; implicit def intToString(i: Int) = ""; type T = p.type }
<console>:8: error: type mismatch;
 found   : p.type (with underlying type Int)
 required: AnyRef
              { val p = 0; implicit def intToString(i: Int) = ""; type T = p.type }
                                                                           ^
```

I suppose the unwritten detail is whether or not implicit conversions are allowed in a particular context.
