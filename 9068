Minimized (well, relative to where we started)
```scala
import Ordering.{Byte, comparatorToOrdering}
trait Format[T]

object CacheIvy {
	implicit def basicInputCache[I](implicit fmt: Format[I], eqv: Equiv[I]): InputCache[I] = null
	implicit def arrEquiv[T](implicit t: Equiv[T]): Equiv[Array[T]] = null
	implicit def hNilCache: InputCache[HNil] = null
	implicit def ByteArrayFormat: Format[Array[Byte]] = null
	type :+:[H, T <: HList] = HCons[H,T]
	implicit def hConsCache[H, T <: HList](implicit head: InputCache[H], tail: InputCache[T]): InputCache[H :+: T] = null
	hConsCache[Array[Byte], HNil]
}

sealed trait HList
sealed trait HNil extends HList
object HNil extends HNil
final class HCons[H, T <: HList](head : H, tail : T) extends HList
```

Fixed by:
```
diff --git a/src/compiler/scala/tools/nsc/typechecker/Implicits.scala b/src/comp
index ed1e6d0..7ee6cc2 100644
--- a/src/compiler/scala/tools/nsc/typechecker/Implicits.scala
+++ b/src/compiler/scala/tools/nsc/typechecker/Implicits.scala
@@ -668,7 +668,7 @@ trait Implicits {
             // duplicating the code here, but this is probably a
             // hotspot (and you can't just call typed, need to force
             // re-typecheck)
-            val checked = itree2 match {
+            .itree2 match {
               case TypeApply(fun, args)           => typedTypeApply(itree2, EXP
               case Apply(TypeApply(fun, args), _) => typedTypeApply(itree2, EXP
               case t                              => t
@@ -677,7 +677,7 @@ trait Implicits {
             if (context.hasErrors)
               fail("typing TypeApply reported errors for the implicit tree: " +
             else {
-              val result = new SearchResult(checked, subst)
+              val result = new SearchResult(itree2, subst)
               if (Statistics.canEnable) Statistics.incCounter(foundImplicits)
               printInference("[success] found %s for pt %s".format(result, ptIn
               result
```
