My usecase was adding additional tagging information to AST nodes. I did not want tagging to influence pattern matching and equality but at the same time I didn't want to have a separate map for the tags. Before I learned about curried case class arguments I used:
{code}
case class Node(info: Info) { var tag: SomeTag /* two classses with the same info but with different tags SHOULD be equal */ }
{code}

which could be replaced by:

{code}
case class Node(info: Info)(var tag: SomeTag)
{code}

Indeed, if you care about the implicit parameters in equality and hashCode, then it's a pain. Here's a (long) workaround:
{code}
scala> :paste
// Entering paste mode (ctrl-D to finish)

case class A(i: Int, j: String)
object A {
  class AvoidErasure
  implicit val avoidErasure = new AvoidErasure
  // simply defining apply(i: Int)(implicit j: String) will cause the erasure phase to complain
  def apply(i: Int)(implicit j: String, ae: AvoidErasure) = new A(i, j)
}

// Exiting paste mode, now interpreting.

defined class A
defined module A

scala> implicit val theString="hello"
theString: String = hello

scala> A(3).j
res0: String = hello
{code}
