Scala appears to encode strings with a NUL byte "\u000" differently than Java. To reproduce this define a compile time constant in Java.

Create a Java file (Test.java):

{code:java}
public class Test {
  public static final String TEST = "\0ABC";
}
{code}

Create a sample Scala main program and access TEST from there.

When accessing the string TEST from scala, the NUL byte appears to be encoded with 2 bytes. So, even simple equality tests like 
{code:java}
"\0ABC".equals(Test.TEST) 
{code}
fail and return false. 

However, when TEST is made a private field in the class, and returned from class Test from a static getter function - getTestValue(), the equality check {code:java}  "\0ABC".equals(Test.getTestValue())  {code} passes and returns true.

I took a look at the generated bytecode, and I suspect defining TEST as a compile time constant and makes this difference (as opposed to accessing it via a getter()). 

Can someone please explain if I'm missing something obvious related to encoding of Strings? Some insight on the problem will be helpful.
The modified encoding isn't handled (jvms 4.4.7):

There are two differences between this format and the "standard" UTF-8 format.
First, the null character (char)0 is encoded using the 2-byte format rather than the
1-byte format, so that modified UTF-8 strings never have embedded nulls. Second,
only the 1-byte, 2-byte, and 3-byte formats of standard UTF-8 are used. The Java
Virtual Machine does not recognize the four-byte format of standard UTF-8; it uses
its own two-times-three-byte format instead.

So, 0 and supplementary chars in constants are fffd.

{code}
scala> val x = new str.Test
x: str.Test = str.Test@c808207

scala> x.str
res0: String = imagine JIRA allowed posting unicode comments instead of reporting "communications failure"

scala> str.Test.STR
res1: String = ����������������

{code}

I understand the difference between utf 8 and modified utf 8. But, I'm not clear where exactly the mismatch happens in this scenario. (or where the bug - if any should be). Does scalac not support modified utf 8 encoding? I assume this is a compile time constant. If so, do scalac and javac generate different copies of the same constant? (Sorry if I'm missing something, I'm no expert on compiler internals.)

Thanks, you got it exactly right. This was a learning experience for me, and thanks to your info, not entirely fruitless.

Unfortunately, there is no JIRA label for not-entirely-fruitless. It was fun adding "java-interop", which is only a slight stretch.

The problem was that the constants were ingested incorrectly from the other class file. Now the copies are not differing, modulo separate recompilation.
