it turns out this is a bug in the DelayedInit transformation.

The transformation moves constructor statements after the {{super}} call into a separate method. This generated method is always param-less ([see here|https://github.com/scala/scala/blob/96f230a0e9c254c45dc91c71b5929639e6add1f0/src/compiler/scala/tools/nsc/transform/Constructors.scala#L247]). The assumption is that the statements don't access any of the constructor's parameters, because for each of them there is in fact a field generated in the class, and the statements should be accessing those fields instead.

(Side-note: a field is generated for every constructor param initially. If a fields ends up not being used because a constructor param is only accessed during the constructor body, the field is eliminated by the Constructors phase).

The bug is that the above assumption is not correct in the case of the captured variable in the example above. Here's the {{-Xprint}} before {{constructors}}:

{code}
  class C extends Object {
    def <init>(): C = {
      C.super.<init>();
      ()
    };

    def b(s: String): Null = null;

    {
      val symbol: String = "ABC";
      {
        new <$anon: WA>(C.this, symbol)
      }
    };

    final class $anon$1 extends WA {
      def <init>($outer: C, symbol$1: String): <$anon: WA> = {
        $anon$1.super.<init>();
        ()
      };
      $anon$1.this.$outer.b(symbol$1);
      <synthetic> <paramaccessor> <artifact> private[this] val $outer: C = _;
      <synthetic> <stable> <artifact> def $outer(): C = $anon$1.this.$outer
    }
  }
{code}

Note that the invocation {{$anon$1.this.$outer.b(symbol$1)}} refers to the constructor parameter {{symbol$1}}. After {{constructors}} which performs the DelayedInit transform:

{code}
  class C extends Object {
    def b(s: String): Null = null;

    final class $anon$1 extends WA {
      <synthetic> <paramaccessor> <artifact> private[this] val $outer: C = _;
      <synthetic> <stable> <artifact> def $outer(): C = $anon$1.this.$outer;

      final <synthetic> def anon$1$1: Unit = {
        $anon$1.this.$outer.b(symbol$1);
        ()
      };

      final <synthetic> class delayedInit$body extends runtime.AbstractFunction0 { ... };

      def <init>($outer: C, symbol$1: String): <$anon: WA> = {
        if ($outer.eq(null))
          throw null
        else
          $anon$1.this.$outer = $outer;
        $anon$1.super.<init>();
        $anon$1.this.delayedInit(new delayedInit$body($anon$1.this));
        ()
      }
    };

    def <init>(): C = {
      C.super.<init>();
      {
        val symbol: String = "ABC";
        {
          new <$anon: WA>(C.this, symbol)
        }
      };
      ()
    }
  }
{code}

The access to {{symbol$1}} in the generated method {{anon$1$1}} is invalid.
