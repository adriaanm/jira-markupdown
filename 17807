I hadn't realized this works[*], which is neat:
```scala
scala> import scala.reflect._
import scala.reflect._

scala> def f[T: ClassTag](xs: Any*) = xs collectFirst { case x: T => x }
f: [T](xs: Any*)(implicit evidence$1: scala.reflect.ClassTag[T])Option[T]

scala> f[List[Int]](1, "a", List(1)) map (_.head)
res0: Option[Int] = Some(1)
```

But it cannot be so credulous - the pattern match can only be checked up to the granularity of a ClassTag.
```scala
scala> f[List[Int]](1, "a", List("a")) map (_.head)
java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer
	at scala.runtime.BoxesRunTime.unboxToInt(Unknown Source)
	at $anonfun$1.apply(<console>:12)
	at $anonfun$1.apply(<console>:12)
```

This is rather bad I think. Why does "Int" survive into the ClassTag? 
```scala
scala> implicitly[ClassTag[List[Int]]]
res2: scala.reflect.ClassTag[List[Int]] = scala.collection.immutable.List

// I think that should either be
scala> implicitly[ClassTag[List[Int]]]
res3: scala.reflect.ClassTag[List[_]] = scala.collection.immutable.List

// or do this
scala> implicitly[ClassTag[List[Int]]]
<console>:10: error: No ClassTag available for List[Int]
       def f[T] = implicitly[ClassTag[List[Int]]]
                            ^
Note: ClassTags do not encode type arguments. Try List[_] instead.
```
