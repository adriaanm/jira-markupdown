You'll notice the minimized test case

{code}
import _root_.scala.collection.Seq
import _root_.scala.util.control.Exception
import _root_.scala.util.continuations._

object Test {

  trait AbstractResource[+R <: AnyRef]  {
    def reflect[B] : R @cpsParam[B,Either[Throwable, B]] = shift(acquireFor)
    def acquireFor[B](f :  R => B) : Either[Throwable, B] = {
      import Exception._
      catching(List(classOf[Throwable]) : _*) either (f(null.asInstanceOf[R]))
    }
  }  

  def main(args: Array[String]) : Unit = {
     val x = new AbstractResource[String] { }
     val result = x.acquireFor( x =>  7 )
     println(result)
  }
}
{code}

Throws this exception: 

{code}
[partest] java.lang.ClassCastException: scala.collection.immutable.$$colon$$colon cannot be cast to java.lang.Class
  [partest] 	at Test$$AbstractResource$$class.acquireFor(josh-vararg-issue.scala:11)
  [partest] 	at Test$$$$anon$$1.acquireFor(josh-vararg-issue.scala:16)
  [partest] 	at Test$$.main(josh-vararg-issue.scala:17)
  [partest] 	at Test.main(josh-vararg-issue.scala)
{code}

due to the erroneous checkcast bytecode placed after the creation of the exception list.
