Not sure what you did on this already, but here are some things I came up with.

 1. It can be easily reproduced outside of the REPL.
 2. It can be reproduced without specialization
 3. The generated bytecode for the anonymous function and the call to cfor is the same in each case, with or without specialization.
 4. The slowdown could be the usual initializers and jvm optimization.

If `SI-4` is correct, there are two solutions:
 1. Users just have to put code where performance is important into a method due to the REPL's wrapping.  If we use the above definition of `cfor`, the following works fine:
```scala
def x = { var sum = 0; cfor[Int](0, _<1000000000, _+1) { sum += _ }; sum }
x
```
 2. The REPL puts everything in methods and lazy vals and never in a constructor.

Here is the code I reduced it to for outside the REPL. `line4_object.res1` below can be changed to a `def` and then `1000000` can be changed to `1000000000` and it runs at the same speed as the other one.
```scala
object line2_object {
  var sum = 0
}

object line3_object {
  import Test.`cfor`
  def res0 = cfor(1000000000) { line2_object.sum += _ }
  def x = res0
}

object line4_object {
  import Test.`cfor`
  var sum = 0
  val res1 = cfor(1000000) { sum += _ }
  def x = res1
}

object Test
{
  def cfor(c: Int)(f: Int => Unit) {
    var t = 0
    while( t < c ) {
      f(t)
      t += 1
    }
  }
  
  def main(args: Array[String])
  {
    import System.{currentTimeMillis => now}
    val start = now
    def printTime = println("Time: " + (now - start) / 1000.0 + "\n")
    println(line4_object.x)
    println(line4_object.sum)
    printTime
    
    println(line3_object.x)
    println(line2_object.sum)
    printTime
    
    println(line4_object.x)
    println(line4_object.sum)
    printTime
    
    println(line3_object.x)
    println(line2_object.sum)
    printTime
  }
}
```

(If there is no `x`, `cfor` doesn't get run for some variations.)
