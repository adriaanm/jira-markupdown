When compiling the following snippet with and without -optimize, I get varying semantics and presumably wrong bytecode.

Given:
{code:java}
import scala.util.Success

object Test {
 def main(args: Array[String]) {
   val e = new Exception("this is an exception")
   val res = Success(1).flatMap[Int](x => throw e)
   println(res)
 }
}
{code}

The expected output is:
{code}
Failure(java.lang.Exception: this is an exception)
{code}

(This is indeed what I get when running after compiling without -optimize)

When running after compiling _with_ -optimize, the exception is incorrectly thrown:
{code}
java.lang.Exception: this is an exception
       at Test$.main(opt-bug.scala:5)
       at Test.main(opt-bug.scala)
       at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
       at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
       at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
       at java.lang.reflect.Method.invoke(Method.java:597)
       at scala.tools.nsc.util.ScalaClassLoader$$anonfun$run$1.apply(ScalaClassLoader.scala:71)
       at scala.tools.nsc.util.ScalaClassLoader$class.asContext(ScalaClassLoader.scala:31)
       at scala.tools.nsc.util.ScalaClassLoader$URLClassLoader.asContext(ScalaClassLoader.scala:139)
       at scala.tools.nsc.util.ScalaClassLoader$class.run(ScalaClassLoader.scala:71)
       at scala.tools.nsc.util.ScalaClassLoader$URLClassLoader.run(ScalaClassLoader.scala:139)
       at scala.tools.nsc.CommonRunner$class.run(ObjectRunner.scala:28)
       at scala.tools.nsc.ObjectRunner$.run(ObjectRunner.scala:45)
       at scala.tools.nsc.CommonRunner$class.runAndCatch(ObjectRunner.scala:35)
       at scala.tools.nsc.ObjectRunner$.runAndCatch(ObjectRunner.scala:45)
       at scala.tools.nsc.MainGenericRunner.runTarget$1(MainGenericRunner.scala:70)
       at scala.tools.nsc.MainGenericRunner.process(MainGenericRunner.scala:92)
       at scala.tools.nsc.MainGenericRunner$.main(MainGenericRunner.scala:101)
       at scala.tools.nsc.MainGenericRunner.main(MainGenericRunner.scala)
{code}


In inspecting the bytecode, it seems that the optimizer completely removes the flatMap invocation in the above snippet.

Bytecode without optimize (*CORRECT*):
{code}
public final class Test$ extends java.lang.Object{
public static final Test$ MODULE$;

public static {};
 Code:
  0:        new        #2; //class Test$
  3:        invokespecial        #12; //Method "<init>")V
  6:        return

public void main(java.lang.String[]);
 Code:
  0:        new        #16; //class java/lang/Exception
  3:        dup
  4:        ldc        #18; //String this is an exception
  6:        invokespecial        #21; //Method java/lang/Exception."<init>":(Ljava/lang/String;)V
  9:        astore_2
  10:        new        #23; //class scala/util/Success
  13:        dup
  14:        iconst_1
  15:        invokestatic        #29; //Method scala/runtime/BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer;
  18:        invokespecial        #32; //Method scala/util/Success."<init>":(Ljava/lang/Object;)V
  21:        new        #34; //class Test$$anonfun$1
  24:        dup
  25:        aload_2
  26:        invokespecial        #37; //Method Test$$anonfun$1."<init>":(Ljava/lang/Exception;)V
  29:        invokevirtual        #41; //Method scala/util/Success.flatMap:(Lscala/Function1;)Lscala/util/Try;
  32:        astore_3
  33:        getstatic        #46; //Field scala/Predef$.MODULE$:Lscala/Predef$;
  36:        aload_3
  37:        invokevirtual        #49; //Method scala/Predef$.println:(Ljava/lang/Object;)V
  40:        return

}
{code}

Bytecode with optimize (*INCORRECT*):
{code}
public final class Test$ extends java.lang.Object{
public static final Test$ MODULE$;

public static {};
 Code:
  0:        new        #2; //class Test$
  3:        invokespecial        #12; //Method "<init>")V
  6:        return

public void main(java.lang.String[]);
 Code:
  0:        new        #16; //class java/lang/Exception
  3:        dup
  4:        ldc        #18; //String this is an exception
  6:        invokespecial        #21; //Method java/lang/Exception."<init>":(Ljava/lang/String;)V
  9:        astore_2
  10:        new        #23; //class scala/util/Success
  13:        dup
  14:        iconst_1
  15:        invokestatic        #29; //Method scala/runtime/BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer;
  18:        invokespecial        #32; //Method scala/util/Success."<init>":(Ljava/lang/Object;)V
  21:        pop
  22:        aload_2
  23:        athrow

}
{code}

The diff between the two:
{code}
--- without-opt        2012-08-05 11:32:04.000000000 +0200
+++ with-opt        2012-08-05 11:32:17.000000000 +0200
@@ -20,16 +20,9 @@
   14:        iconst_1
   15:        invokestatic        #29; //Method scala/runtime/BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer;
   18:        invokespecial        #32; //Method scala/util/Success."<init>":(Ljava/lang/Object;)V
-   21:        new        #34; //class Test$$anonfun$1
-   24:        dup
-   25:        aload_2
-   26:        invokespecial        #37; //Method Test$$anonfun$1."<init>":(Ljava/lang/Exception;)V
-   29:        invokevirtual        #41; //Method scala/util/Success.flatMap:(Lscala/Function1;)Lscala/util/Try;
-   32:        astore_3
-   33:        getstatic        #46; //Field scala/Predef$.MODULE$:Lscala/Predef$;
-   36:        aload_3
-   37:        invokevirtual        #49; //Method scala/Predef$.println:(Ljava/lang/Object;)V
-   40:        return
+   21:        pop
+   22:        aload_2
+   23:        athrow

}
{code}
