This problem arises from the desugaring of val patterns.

{code}
 cat sandbox/client.scala
trait Client extends Test {
  def test() {
    val If(condp, thenp, elsep) = (??? : Tree)
  }
}
2.11.x /code/scala2 qscalac sandbox/test.scala && qscalac -Xprint:parser sandbox/client.scala
[[syntax trees at end of                    parser]] // client.scala
package <empty> {
  abstract trait Client extends Test {
    def $init$() = {
      ()
    };
    def test(): scala.Unit = {
      <synthetic> <artifact> private[this] val x$1 = ($qmark$qmark$qmark: Tree): @scala.unchecked match {
        case If((condp @ _), (thenp @ _), (elsep @ _)) => scala.Tuple3(condp, thenp, elsep)
      };
      val condp = x$1._1;
      val thenp = x$1._2;
      val elsep = x$1._3;
      ()
    }
  }
}
{code}

A similar problem is evident in SI-8468 (case classes with > 22 fields.)

It would be nice if we could desugar them to vars:

{code}
  var x$1: ? = _
  var x$2: ? = _
  var x$3: ? = _
  scrut match {
    case Pattern(a, b, c) =>
      x$1 = a
      x$2 = b
      x$3 = c
    case => throw ...
  }
  val condp = x$1
  val elsep = x$2
  val thenp = x$3
{code}

But we would then need to give those symbols a magic type that took on the type of the RHS of the first assignment. Which sounds like too much magic. We'd also have a problem creating unwanted fields if this was part of a class.

So maybe we'd need to resurrect [~moors] patch to optimize away the TupleN creation / destruction after the fact.
