In Eclipse, if I use an annotation processor to generate a source file, say foo.SomeClass.java, but I have a Scala file that wants to use foo.SomeClass, there is a catch 22 and the annotation processor is never run.

Normally, if it was just another Java class referring to the missing foo.SomeClass, Eclipse would skip the initial compile error (on missing foo.SomeClass), run the annotation processor round(s), and then find the original "missing foo.SomeClass" error resolved and so ignore/remove it.
Off the top of my head, the easiest way to see this is to make a new Scala/Java project, and setup this annotation processor:

http://repo.joist.ws/org/interfacegen/interfacegen/0.1/

(See http://bindgen.org/setup.html for Eclipse annotation processor setup, replacing bindgen with this interfacegen--this interfacegen is just simpler hence using it to reproduce this instead of bindgen.)

Now make a class:

{code}
package bar;
@GenInterface
public Foo implements IFoo {
  public void foo() {
  }
}
{code}

The `@GenInterface` just copies all of the public methods of `Foo` into `IFoo` for mock testing.

So, now if you add a Scala file:

{code}
package bar

class A {
  val f: IFoo = new Foo
}
{code}

You'll get a compile error and the output for `IFoo` will never get generated. You can check the annotation processor output folder (.apt_generated by default).

If for some reason you happen to still have an `IFoo` left over from when you had an A.scala (though this did not happen to me), if you run clean, it will delete all the .apt_generated classes and then fail to make `IFoo`.

I admit I have not tried the command-line compiler so this may affect more than just the eclipse plugin.

Replying to [comment:2 milessabin]:
> in effect you're asking for support for joint compilation with scalac, javac and an annotation processor with mutual dependencies, and that's most likely going to be a fiddly process.

Agreed.

> Can you boil this down to a simple sample project using minimal dependencies and get it working nicely with the command line tools?

I've got a simple project running scalac/javac, but, no, it's not working. scalac doesn't consider/pre-run annotation processors that javac will later run. Should I move this bug to some other component, open another one, or bring this up on the list?

This actually reminds me of the joint compiler framework discussion I came across on some jvm languages list, where I thought you and Charles Nutter were on the right track, and then the clojure guy started talking about using class files instead of an API. I think a common compiler API that would allow multi-language, iterative compilation (e.g. to allow cross-language/compile-time meta-programming like annotation processors and Kevin's compiler plugin to generate new types as compilation is happening) would be pretty dang slick.


