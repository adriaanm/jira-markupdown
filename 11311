I looked into the issue a bit, and I think I found the main cause and a potential fix (though I am uncertain about the fix).

The source of the issue seems to be: https://github.com/scala/scala/blob/2.11.x/src/compiler/scala/tools/nsc/transform/Constructors.scala#L501, where the wrong parameter can be matched when the names involved include dollar signs (even when the names used in the source program do not include dollar signs). The current behaviour matches names that are exactly the same (which is correct) as well as names that start with the same substring, followed by a dollar sign, followed by anything. That behaviour is somewhat weird, but would explain the different test cases, since the space in `a b` is represented using an initial dollar sign followed by some representation of space.

I looked into it, and it seems the current behaviour was changed in this commit: https://github.com/scala/scala/commit/6b6d21444f2d68988423424ee4a9ebda544985e9#diff-086eb87150c79730cf3cfe9cb8b12219L70, where the previous behaviour was to match names that are exactly the same as well as names that start with the same substring and with a dollar sign at the end. Reverting the behaviour to that in the commit solves most cases discussed here (as well as the case "case class plus(a_+ : Int, a_ : String)"): Only Arya Irani's case with "case class right5(b: Int, `a b`: Int, a: Int, `a `: Int, `a b c`: Int)" does not print correctly, and accessing its fields works correctly. Cases where dollar signs are used directly at the end of names, such as "case class dollarsign(a$: Int, a: String)" and "case class dollarsign2(`a$`: Int, a: String)", still fail.

I did not figure out what the purpose of the check is. The original behaviour seems to be to check against an "original name": https://github.com/scala/scala/commit/cb7711db82c381848a6571047c68145e4f2d3c46#diff-086eb87150c79730cf3cfe9cb8b12219L58. In either case, I think a refactoring of the handling of Names from working on the string values to encapsulating the string value and instead provide more descriptive methods would be useful in making it much easier to verify and maintain correctness in relation to the handling of names, though I can imagine that would be quite a lot of work. In line with this, a better fix than presented below would implement a descriptive method (describing what the matching means) on Name (or similar) that handles the matching and call that instead of directly matching on parts of the string value of the name.

The potential fix (tested using "ant test-opt"):
```scala
def matchesName(param: Symbol) =
  param.name == name ||
  (param.name.startsWith(name) && param.name.endsWith(nme.NAME_JOIN_STRING))
```
