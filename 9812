Here's the typer issue down to its essentials. The NPE is most likely error reporting floundering.
{code}
class Foo[A](x: A)
object bar extends Foo(5: T forSome { type T })
// a.scala:2: error: illegal inheritance;
//  self-type bar.type does not conform to Foo[T]'s selftype Foo[T]
// object bar extends Foo(5: T forSome { type T })
//                    ^
// a.scala:2: error: type mismatch;
//  found   : T(in constructor bar) where type T(in constructor bar)
//  required: <empty>.T where type <empty>.T
// object bar extends Foo(5: T forSome { type T })
//                         ^
// two errors found
{code}
That error message says, in effect, "Bug City." You never know what's going to end up owning certain kinds of symbols; neither does the compiler, which is requiring a T owned by the empty package (i.e. the enclosing package class.)
