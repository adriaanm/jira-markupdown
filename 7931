It's a bug.  It happens during lambdalift, and it tries to avoid it.  Look at the eerie similarity of the example in the comment.
{code}
beforePickler {
  // The param symbol in the MethodType should not be renamed, only the symbol in scope. This way,
  // parameter names for named arguments are not changed. Example: without cloning the MethodType,
  //     def closure(x: Int) = { () => x }
  // would have the signature
  //     closure: (x$1: Int)() => Int
  if (sym.isParameter && sym.owner.info.paramss.exists(_ contains sym))
    sym.owner modifyInfo (_ cloneInfo sym.owner)
}
{code}
