_> I'm not sure they should be rejected_

On the subject of [~szeiger]'s comment, and as discussed in a more roundabout way in https://github.com/scalapuzzlers/scalapuzzlers.github.com/issues/146#issuecomment-275896910 and subsequent comments: is it clear from the spec that this should fail?

The following code snippets (2.12.1 REPL) seem to point in different directions here.

* The compiler is able to pick a particular overloaded method to be eta-expanded if the expected function type is given:

{code:scala}
scala> val maxLongFun: (Long, Long) => Long = math.max
maxLongFun: (Long, Long) => Long = $$Lambda$1276/401366570@52290e63
{code}

* The compiler cannot pick a particular overloaded method if the expected function type uses a type parameter with type bounds:

{code:scala}
scala> def getMaxTFun[T >: Long]: (T, T) => T = math.max
<console>:12: error: type mismatch;
 found   : (Int, Int) => Long
 required: (T, T) => T
       def getMaxTFun[T >: Long]: (T, T) => T = math.max
                                                     ^
...
        def getMaxTFun[T >: Long]: (T, T) => T = {
          ((x: Int, y: Int) => scala.math.`package`.max(x.toLong, y.toLong))
...

{code}

So are the type bounds the problem? In the above example, overloading resolution seems to have picked the correct version of {{max}} - it looks as though eta expansion happened "too soon"?

As suggested by the previous example, overload resolution unrelated to eta expansion seems to be fine with type bounds:

{code:scala}
scala> def maxT[T >: Long](a: Int, b: Int): T = math.max(a, b)
[[syntax trees at end of                     typer]] // <console>
...
        def maxT[T >: Long](a: Int, b: Int): T = scala.math.`package`.max(a.toLong, b.toLong)
...
maxT: [T >: Long](a: Int, b: Int)T
{code}

If (from the first snippet) the compiler can use the expected function type to guide overloading resolution before ( ?) eta expansion, and (from the third snippet) type _bounds_ are sufficient to help the compiler determine the correct method during "normal" overloading resolution, why would type bounds on the expected type of the eta-expanded function be expected to fail?

/cc [~apm]
