We are using Eclipse 3.5 Build id 20090920-1017 and Scala Eclipse plug-in 2.8.0.r19132-b20091019023339.

When declaring a method that returns an inner class object of a specific instantiation of a type parameterized class, the generated byte code is missing a signature describing the actual type instantiation.

Consider these classes

```scala
class Outer[T](val t: T) {
  class Inner {
    def getT : T = t
  }
}

class OuterImpl(x: X) extends Outer(x) {
  def newInner = new Inner
}

class X {
  def getI : OuterImpl#Inner = {
    val oImpl = new OuterImpl(this)
    new oImpl.Inner
  }
}
```

Inspecting the class file for class X, looking at the method "getI" reveals:

```scala
// Method descriptor SI-12 ()Ltest/scala/Outer$$Inner;
// Stack: 3, Locals: 2
public test.scala.Outer.Inner getI();
```

Calling the class from Scala works fine. Functions 'getT' and 'getI' have the expected return types and can be chained forever.

```scala
class TestFromScala {
  val x = new X
  val o = new OuterImpl(x)
  val i = o.newInner
  val i2 = i.getT.getI.getT.getI
}
```

However, calling from Java causes problems:

```scala
public class TestFromJava {
  void test() {
    final X x = new X();
    final OuterImpl o = new OuterImpl(x);
    
    final OuterImpl.Inner i1 = o.newInner();
    i1.getT().getI().getT().getI();  // <--- Error: "The method getI() is undefined for the type Object"
   
    final Outer<X>.Inner i2 = o.newInner();
    i2.getT().getI().getT().getI(); // <--- Error: "The method getI() is undefined for the type Object"
  }
}
```

Implementing the same classes in Java looks like this:

```scala
public class Outer<T> {
  private final T t;

  public Outer(T t) {
    this.t = t;
  }
  
  public class Inner {
    public T getT() {
      return t;
    }
  }
}
 
public class OuterImpl extends Outer<X> {
  public OuterImpl(X x) {
    super(x);
  }
  
  public OuterImpl.Inner newInner() {
    return this.new Inner();
  }
}

public class X {
  OuterImpl.Inner getI() {
    final OuterImpl oImpl = new OuterImpl(this);
    return oImpl.newInner();
  }
}
```

The signature for 'X.getI()' looks like this:

```scala
// Method descriptor SI-15 ()Ltest/java/Outer$$Inner;
// Signature: ()Ltest/java/Outer<Ltest/java/X;>.Inner;
// Stack: 3, Locals: 2
test.java.Outer.Inner getI();
```

Please note the "// Signature" line. And now everythings works from Java:

```scala
public class TestFromJava {
  void test() {
    final X x = new X();
    final OuterImpl o = new OuterImpl(x);
    
    final OuterImpl.Inner i1 = o.newInner();
    i1.getT().getI().getT().getI(); // <--- Works fine.
    
    final Outer<X>.Inner i2 = o.newInner();
    i2.getT().getI().getT().getI(); // <--- Works fine.
  }
}
```
There seem to be two problems going on here.  Iulian, can you have a look at problem #2:

If I change the result type of newInner to Outer[X].Inner (to get around problem SI-1: we don't detect we need to generate a javasig when the result type refers to an instantiation of a generic inner class(??)), I get (compiling with -Ydebug -verbose):
```scala
Java sig of method newInner is ()LOuter<LX;>.Inner;
add generic sig method newInner:()<empty>.this.Outer[<empty>.this.X]#Inner ==> ()LOuter<LX;>.Inner; @ 24
...
add generic sig class OuterImpl:<empty>.this.Outer[<empty>.this.X] with scala.this.ScalaObject{<method> def this(<param> x: <empty>.this.X): <empty>.this.OuterImpl; <method> def newInner(): <empty>.this.Outer[<empty>.this.X]#Inner} ==> LOuter<LX;>;Lscala/ScalaObject; @ 26
[wrote classes/OuterImpl.class]
```

javap says
```scala
lampmac6:tmp adriaan$$ javap -classpath classes -v -s OuterImpl
Compiled from "x.scala"
...
const SI-23 = Method	SI-20.SI-22;	//  Outer$$Inner."<init>":(LOuter;)V
const SI-24 = Asciz	()LOuter<LX;>.Inner;;
const SI-25 = Asciz	Signature;
const SI-26 = Asciz	LOuter<LX;>;Lscala/ScalaObject;;

...

public Outer$$Inner newInner();
  Signature: ()LOuter$$Inner;
```

Note that the signature does not use the (expected?) const #24. It's clearly computed as you can see in the log, but somehow the method does not get the javasig attribute thingy (I don't really know how this works in bytecode)
(might be related to #1745)
Martin: I propose the attached patch -- am not entirely satisfied with it, but am stuck trying to improve it
(In r19756) closes #2585: generate more precise Java generic signatures for classes nested in parametric outer classes
fix based on review by Martin
baseType is your friend
note that this particular issue is fixed, but the test case includes a Scala method that could be given a more precise java generic sig

currently, the `withFilter` method in `HashMap`:
```scala
trait TraversableLike[+A, +Repr] {
  class WithFilter(p: A => Boolean)
  def withFilter(p: A => Boolean): WithFilter = new WithFilter(p)
}

class HashMap[K, +V] extends TraversableLike[(K, V), HashMap[K, V]]
```

becomes:

```scala
public class HashMap<K, V> implements TraversableLike<Tuple2<K, V>, HashMap<K, V>>, ScalaObject {
  public TraversableLike.WithFilter withFilter(Function1 p) { return TraversableLike.class.withFilter(this, p);
```

a more precise type would obviously include type params for `TraversableLike` and `Function1`
Since 2.11.0-RC1 is one week away, pushing all non-blockers without PR to 2.11.1-RC1. Please undo the change if I missed work in progress.
