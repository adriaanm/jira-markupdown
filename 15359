Had trouble dreaming up a one line summary on this one.
{code}
object Test {
  class J1 {
    def f[K, V](x: Map[K, V]): Map[K, V] = error("")
  }
  class J2 {
    def f[K, K1 <: K, V](x: Map[K1, V]): Map[K, V] = error("")
  }
  class J3 {
    def f[K, K1 >: K, V](x: Map[K1, V]): Map[K, V] = error("")
  }
  
  def main(args: Array[String]): Unit = {
    (new J1).f(Map[Int, Int]())   // ok
    (new J2).f(Map[Int, Int]())   // ok
    (new J3).f(Map[Int, Int]())   // not ok
    
    // error: inferred type arguments [Int,Int] do not conform to method f's type parameter bounds [K1 >: K,V]
    //      (new J3).f(Map[Int, Int]())
    
    ()
  }
}
{code}

There may be two distinct bugs, in that it fails to compile for some reason and then there is an error reporting bug which drops a type parameter.  I say that partly because it fails in 2.7 as well, but the error message has the right arity:
{code}
scalac27 b.scala 
b.scala:15: error: inferred type arguments [K,Int,Int] do not conform to method f's type parameter bounds [K,K1 >: K,V]
    (new J3).f(Map[Int, Int]())    
             ^
one error found
{code}
I can't see why it shouldn't compile when the constraint is trivially satisfiable, but I accept that limitation if it exists.  Still, the arity being wrong is the kind of thing that strikes fear into my heart about what else might be happening.  (That also applies to those HK messages which say things like "error: expected 1 type parameter, found 1", though maybe those are gone now.)
