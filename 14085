Consider the following class:
{code}
class BeanPropertyExample
{
  @scala.reflect.BeanProperty
  val eagerProperty = "Eager"
  
  @scala.reflect.BeanProperty
  lazy val lazyProperty = "Lazy"
}
{code}
As {{javap}} shows, the getter method is created only for the regular (non-lazy) property.
{code}
$$ javap BeanPropertyExample
Compiled from "BeanPropertyExample.scala"
public class BeanPropertyExample extends java.lang.Object implements scala.ScalaObject{
    public volatile int bitmap$$0;
    public BeanPropertyExample();
    public java.lang.String getEagerProperty();
    public java.lang.String lazyProperty();
    public java.lang.String eagerProperty();
    public int $$tag()       throws java.rmi.RemoteException;
}
{code}
I suppose this shouldn't happen, I think there is no reason for not having the getter for lazily constructed values.
