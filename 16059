```scala
object Test {
  // this works.
  trait A { def f (): Unit }
  class B { final def f(): Unit = () }

  // this earns a VerifyError.
  trait C { def wait (): Unit }
  class D { }
  
  def main(args: Array[String]): Unit = {
    new B with A { }
    new D with C { }
  }
}
```
The error is this:
```scala
// java.lang.VerifyError: class Main$$C overrides final method wait.()V
//  at java.lang.ClassLoader.defineClass1(Native Method)
//  at java.lang.ClassLoader.defineClassCond(ClassLoader.java:632)
//  at java.lang.ClassLoader.defineClass(ClassLoader.java:616)
```
This may just be a jvm limitation for methods defined in Object, because the bytecode for C looks pretty innocuous.
```scala
public abstract void wait();
```
But if interfaces are treated like classes and Object is an assumed parent, I can see why it would consider that interface unacceptable.  In which case we need to catch such declarations at compile time.
