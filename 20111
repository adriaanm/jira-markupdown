I expect that "loop" should be finished. But it hangs on ~7kk iteration. If I give JVM more memory (4G for example) this works fine. I tried to use SerialExecutionContext (http://bit.ly/1ZUwKIt) to exclude reasons related to ForkJoinPool but got same result.

{code:scala}
import java.util.concurrent.ConcurrentLinkedQueue
import scala.concurrent.{ExecutionContext, Future, Await}
import scala.concurrent.duration._

object Main extends App {
 
  val N = 10000000
 
  def foo(read: () => Future[String], write: String => Future[Unit])
    (implicit topEc: ExecutionContext): Future[Unit] = {

    def loop(state: Int): Future[Unit] = {
      for {
        text <- read()
        x = text.toInt
        newState = state + x
        _ <- write(newState.toString)
        _ <- {
          if (newState == N) Future.successful(())
          else loop(newState)
        }
      } yield {
        ()
      }
    }

    loop(0)
  }

  import scala.concurrent.ExecutionContext.Implicits.global

  val f = foo(
    read = () => Future.successful("1"),
    write = { s =>
      s.toInt match {
        case i if i == N / 10 => println(i)
        case i if i == N / 5 => println(i)
        case i if i == N / 3 => println(i)
        case i if i == N / 2 => println(i)
        case i if i == N - N / 3 => println(i)
        case i if i == N - N / 5 => println(i)
        case i if i == N - N / 10 => println(i)
        case _ =>
      }
      Future.successful(())
    }
  )

  val t = System.nanoTime()
  Await.result(f, 1 hour)
  val t2 = (System.nanoTime() - t) / 1000000000d
  println(s"Execution time: ${t2}s")
}
{code}
