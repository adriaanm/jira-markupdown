This was a difficult minimization.  g must be overloaded; the expression must be typed as an argument; and both legs of the if as well as the call to map appear to be necessary.  Remove any of the above, and one sees the appropriate error message - List(g(x)) is attempting to call g with a String rather than one of the types upon which it is overloaded.
{code}
class C1
class C2
class A {
  def f(x: Any) = x
  def g(x: C1): String = "A"
  def g(x: C2): String = "B"
  
  def crash() = f(List[String]() flatMap { x =>
    if (false) List(g(x)) else List[C1]() map g
  })
}
// at scala.Predef$.assert(Predef.scala:162)
// at scala.tools.nsc.Global.assert(Global.scala:235)
// at scala.tools.nsc.typechecker.SuperAccessors$SuperAccTransformer.transform(SuperAccessors.scala:291)
// at scala.tools.nsc.typechecker.SuperAccessors$SuperAccTransformer$$anonfun$transformArgs$1.apply(SuperAccessors.scala:74)
// at scala.tools.nsc.typechecker.SuperAccessors$SuperAccTransformer$$anonfun$transformArgs$1.apply(SuperAccessors.scala:71)
// at scala.reflect.internal.TreeInfo$$anonfun$mapMethodParamsAndArgs$1.apply(TreeInfo.scala:115)
// at scala.reflect.internal.TreeInfo$$anonfun$mapMethodParamsAndArgs$1.apply(TreeInfo.scala:115)
// at scala.reflect.internal.util.Collections$class.foreach2(Collections.scala:150)
// at scala.reflect.internal.SymbolTable.foreach2(SymbolTable.scala:12)
{code}
