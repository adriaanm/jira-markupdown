This is getting more fun.

M.scala
```scala
object M extends Application {
  def foo {
    lazy val a = {
        lazy val b = 1
        lazy val c = 2
        println(b)
        println(c)
    }
    a
    lazy val d = 42
    println(d)
  }
  
  foo
}
```
```scala
scalac M.scala
scala M

1
0
42
```

But hey, why is there 0 you ask? Well, all vals here share the same bitmap but b and c get also the same bit because of a bug in LazyVals line 51. Now if we fix that, with the example above we get
```scala
1
2
0
```
because now c and d share the same bit.
