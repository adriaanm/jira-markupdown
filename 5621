It appears the the following approach might get the "onCreate" functionality
on a case-by-case basis:
```scala
trait A extends DelayedInit {
  println("A ConstructionCode")

  def delayedInit(body: => Unit) = {
    body
    postConstructionCode
  }
  protected def postConstructionCode: Unit = {
    println("A PostConstructionCode")
  }
}
trait B extends A {
  println("B ConstructionCode")
  override protected def postConstructionCode: Unit = {
    super.postConstructionCode
    println("B PostConstructionCode")
  } 
} 
  
class C extends B { 
  println("C ConstructionCode")
  override protected def postConstructionCode: Unit = {
    super.postConstructionCode
    println("C PostConstructionCode")
  }
}object Test {
  def main(args: Array[String])
    val c = new C
  }
}
```

This outputs:
```scala
A ConstructionCode
B ConstructionCode
C ConstructionCode
A PostConstructionCode
B PostConstructionCode
C PostConstructionCode
```
5W (which was what we wanted)!

Of course, each framework would have to create their own "onCreate" 
method (called "postConstructionCode" in this example) and users would have
to make sure that the protected method was not normally called - a call once
methods.
