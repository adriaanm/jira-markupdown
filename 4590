Replying to [comment:16 rompf]:
> First of all, there seems to be some confusion about the nature of Scala's Vector implementation. I don't know who spread the myth about the underlying data structure being a skip-list (I've read that in a couple of places now) but this is definitely false. The implementation is based on 32-wide trees, just as in Clojure. This renders any wholesale arguments (e.g. about locality) invalid.

That would be me spreading that rumor.  :-)  While Scala's Vector **is** a tree, it doesn't push the data to the leaves, so you can't really say that it's doing the same thing that Clojure's tries do.  I'll spend some more time with the implementation, but it really **does** look like a skip-list to me.  Maybe it's just the fact that I'm looking at the six display pointers sideways, but that's what it seems like.

In any case, the difference between a skip-list and a tree is really just in whether access is optimized for level tips or branch traversal, and I wasn't able to grok the implementation sufficiently to see which holds true.  As you mentioned, the focus optimization changes which locality is fast to reference, so the difference between something which is conceptually a skip-list and something which is conceptually a tree is basically nil.

> More generally, one central goal of the Vector design was to build the most versatile general purpose collection we could. This means that we tried to make as many operations as possible fast, but not optimize the hell out of a single one at the cost of others. As a corollary, we ruled out any model which is asymmetric regarding its left and right ends (we already have Lists) or only geared towards appending (we have Builders for that). Some operations we considered important are take, drop, takeRight, dropRight, splitAt etc (none of them are optimized in Clojure's or your implementation). Even more important is good support for Iterators and Builders because these are central to many other general collection operations. Your benchmarks show your implementation is 3 to 4 times slower for reverse, which is the only Iterator/Builder based operation you provide measurements for. My intuition is that others will show similar numbers. Without evidence that an implementation performs better on all Seq operations (well, let's say most) we cannot seriously consider it as a contender for replacing the current one.

General sequence operations would certainly be slower than Scala's Vector as you have described the optimizations (which are certainly interesting).  I absolutely disagree with the decision to make a general purpose collection though.  What's done is done, but it seems that if you want fast prepend, just use a List.  In my experience, you usually know the shape of your problem ahead of time, so picking out a specialized collection isn't an issue.  Unfortunately, because you chose to optimize for the widest set of operations possible, you have rendered Vector less useful than it could have been in filling a specialized niche left vacant by the remainder of the collections library.  It's still a nice data structure, just not as nice as it could be IMHO.

And don't even get me started about the lack of + and update methods, but this isn't the right forum for that particular rant...

> What your implementation shows, however, is that indexed access can be done faster in some cases. This is not completely surprising (it's, well, a 2x speedup in a micro benchmark), so the question is whether the results can be generalized.

Seems to work quite well in practice for Clojure.  I don't have any raw numbers from them, but Rich Hickey has more than hinted that Clojure's vectors perform astonishingly well in large, non-trivial applications with extensive random access.

> From my perspective, indexed access is an important operation, but for me it is not top priority. The cost of indexing is inherently log n so we can only get so far. A common use for indexing would be iteration, but iteration can in fact be done much faster. So I believe indexing is really only for random access. Now if a program's bottleneck is indeed random access performance, a log n collection will never do, and a speedup of 2 won't help. In that case, an ArrayBuffer or plain Array is the appropriate choice.

When the base of the log term is 32, the result is effectively constant if only due to the limits of 32 bit integers.  So, the upper-bound on the log(n) term is 6, which means that all of the performance is in the constant factor.  A 2x improvement there is nothing to sniff at.


> That said, it is worth to look at some details. In essence, your implementation seems to do two things differently: 

(eliding quoted analysis for brevity)

It's interesting that you point out exactly these two things, because these were optimizations implemented quite recently.  If you look at Clojure's PersistentVector class, you will notice that all of its implementation is done using heterogeneous arrays and non-inlined loops and recursion.  This was the original implementation technique that I used when I ported the data structure, but I switched to the inlining upon the suggestion of Rich Hickey (he had been planning on implementing the same optimization, but hadn't gotten around to it yet).  As a matter of interest, the inlining didn't have any appreciable impact on performance (at least not in my benchmarks).  The typed arrays sort of fell out of the inlining, and since typed arrays are usually faster than untyped arrays (as you said), I decided to keep them.

> In your benchmarks, this doesn't show up since your call sites of apply are all monomorphic.

Very interesting.  I appreciate your analysis of HotSpot's inlining fu.  It does explain some of the results I was seeing.

> You also use very aggressive manual inlining. That's ok for implementing a small number of operations. But if you extend it to more operations, I could imagine it getting unwieldy. After all, somebody has to maintain the code. Another possible concern is that HotSpot is less likely to compile large methods (there might also be an instruction cache penalty).

Quite so.  As I mentioned, this is a fairly recent optimization that didn't produce much of an improvement.  It wouldn't be too hard to use the un-inlined versions instead.

> In conclusion, we appreciate the effort you undertook in porting Clojure's Vector. Exploring different paths is always a valuable thing. As I have explained, we cannot accept it as a replacement in its current form. However, if you would like to help improve scala.collection.immutable.Vector, you are more than welcome. The current implementation is certainly not etched in stone. There are several avenues one could try: 1) Use typed Arrays, as you did, and see how that performs. 2) Instead of keeping a full 6-element display, keep only the bottom level (like Clojure, but with a variable focus position). 3) The current implementation has a large memory overhead for very small Vectors. Can we reduce that footprint? Obviously, we can build special subclasses for Vectors of 1,2,3,... elements, but that means we're again depending on monomorphic call sites. Another strategy would be turning the 6 display pointers into AnyRefs and making them hold actual data elements for Vectors of size <= 6. Again, this has to be carefully weighed against the cost of casting them to arrays for larger Vectors.

Well, this is disappointing, but not entirely surprising.  Since you had access to my original port of Clojure's Vector before you started, I assumed there had to be some reason why you rolled your own, but I was never privy to the details.  This certainly clears things up.  While I still take serious issue with some of the API, the underlying data structure seems well justified.
