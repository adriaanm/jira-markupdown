Implicits must be explicitly type annotated, otherwise the typechecker may ignore them from preceding parts of the same source file. This is done to avoid triggering spurious cycles in type inference.

Unfortunately, there is no way to explicitly annotated the type of an implicit val with a pattern on the LHS of the =.
```scala
% qscala -Xprint:parser -e 'implicit val (a, b): (Int, Int) = (1, 2)'
[[syntax trees at end of                    parser]] // scalacmd6461168732762336959.scala
package <empty> {
  object Main extends scala.AnyRef {
    def <init>() = {
      super.<init>();
      ()
    };
    def main(args: Array[String]): scala.Unit = {
      final class $anon extends scala.AnyRef {
        def <init>() = {
          super.<init>();
          ()
        };
        <synthetic> <artifact> private[this] val x$1 = (scala.Tuple2(1, 2): @scala.unchecked: scala.Tuple2[Int, Int]) match {
          case scala.Tuple2((a @ _), (b @ _)) => scala.Tuple2(a, b)
        };
        implicit val a = x$1._1;
        implicit val b = x$1._2
      };
      new $anon()
    }
  }
}
```

We should add a style checking rule to https://github.com/scala/scala-abide/blob/master/README.md to help find such implicits. It is probably that a future version of Scala will actually enforce that implicits are type annotated.
