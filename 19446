TL;DR: immutable collections are nice because they don't chance, so we can be smart about their equality.


s.c.i.List (for example) seems to derive its equals from GenSeqLike:

{code}
 override def equals(that: Any): Boolean = that match {
    case that: GenSeq[_] => (that canEqual this) && (this sameElements that)
    case _               => false
  }
{code}

canEquals cannot succeed-fast (only fail-fast) for `this eq that` so we go directly to sameElements, which is using LinearSeqOptimized's:

{code}
  override /*IterableLike*/
  def sameElements[B >: A](that: GenIterable[B]): Boolean = that match {
    case that1: LinearSeq[_] =>
      var these = this
      var those = that1
      while (!these.isEmpty && !those.isEmpty && these.head == those.head) {
        these = these.tail
        those = those.tail
      }
      these.isEmpty && those.isEmpty
    case _ =>
      super.sameElements(that)
  }
{code}

As witnessed this does not succeed-fast.
