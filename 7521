The problem seems to be that in the broken case a nested RefinedType is generated (OOO being an outer class):
```scala
tree.tpe: OOO.this.T with OOO.this.TA with OOO.this.TB
RefinedType(
    RefinedType( TypeRef( ThisType(OOO),  TB,  [ ]),  TypeRef( ThisType(OOO),  TA,  [ ]), ), 
    TypeRef( ThisType(OOO),  T,  [ ]), )
```

Whereas in the good case
```scala
tree.tpe: OOO.this.T with OOO.this.TA with OOO.this.TB
RefinedType(
    TypeRef( ThisType(OOO),  TB,  [ ]), 
    TypeRef( ThisType(OOO),  TA,  [ ]), 
    TypeRef( ThisType(OOO),  T,  [ ]), )
```

On erasure when generating the isInstanceOf[TA] && isInstanceOf[TB] cascades, an inner RefinedType is not handled and thus the [TA with TB] type stays there until TB is eventually erased.
