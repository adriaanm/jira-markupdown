Using java libraries that have been generated by languages like groovy where inner classes might not exist from scala causes the scala compiler to throw and error. 

The only way to get around this is either remove the inner classes of the library generated during compile time and then put them back in during runtime, or ignore the exception in the scala compiler itself and continue with the class compilation.


The second option is much more integration friendly and if done via a settings flag can be turned on and off as required. 


As an example see:

https://github.com/gerritjvv/glue/blob/master/core/glue-unit/src/main/groovy/org/glue/unit/om/impl/ScriptedGlueProcessImpl.groovy

From line 72.


The code I use actually use IMain from groovy, and example is pasted in below.

{code}
                                def settings = new Settings()
                                def imain = new IMain(settings)
                                imain.setContextClassLoader()


                                imain.interpret("""
                   import scala.tools.nsc.interpreter._
                                   import scala.tools.nsc._
                   def getIMain(cls:ClassLoader) = {
                                           val s = new Settings
                       s.usejavacp.value = true
                       s.ignoreinnercls.value = true
                       s.embeddedDefaults(cls)
                       new IMain(s){
                         override protected def parentClassLoader:ClassLoader = cls
                       }
                   }
                                   val m = getIMain _
                """)

                                def v = imain.valueOfTerm("m").get().asType(Function1).apply(
                                        new ScalaClassLoader(ctx.class.classLoader))
                                v.setContextClassLoader()

                                def ctx1 = DefaultGlueContextBuilder.buildStaticGlueContextMap(ctx)
                                imain.bind(new NamedParamClass("ctx", "java.util.Map[String, Object]", ctx1))

                                v.bind(new NamedParamClass("ctx", "java.util.Map[String, Object]", ctx1))
                                v.interpret(new String(script.value.decodeBase64()))

{code}
