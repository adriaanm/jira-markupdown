Replying to [comment:2 odersky]:
> I think NumericRange is essentially an over-abstraction, not worth the troubles it causes.

I see it differently, in two ways.  First, that BigInt and BigDecimal/Double ranges are quite useful, and second that I view the trouble it has caused is providing a very useful early warning system regarding surprising/unfortunate feature interactions.  There is no question we haven't yet found all the interesting consequences of recent changes like weak conformance, and NumericRange helps us find them faster.

I can (and want to) make the rest work.  (I didn't open the ticket looking for anyone else to do it, but to document the issue and give people a chance to chime in.) In some sense the harder it is to make work the more worthwhile it is.  It's not like this is a crazily esoteric abstraction, it's a successor function: given the existence of Numeric if we can't make it work there's something wrong.  In fact the whole class is purely optimization, because
```scala
Iterate.iterate(start)(_ `plus` step) takeWhile (_ lt/gt/le/ge end)
```

is all you need, until you want to contains to finish in your lifetime.

> Note that for numeric primitive ranges the right test goes something like this (say for Long):
> {code}
>   def contains(elem: Any) = elem match {
>     case n: Number => ... stuff with n.longValue ...
>     case _ => false
>   }
> }}

Actually in the course of addressing this and other bugs I noticed that this is insufficient, and here is one reason why:
```scala
scala> (Long.MinValue to Long.MinValue + 1)        
res5: scala.collection.immutable.NumericRange.Inclusive[Long] = NumericRange(-9223372036854775808, -9223372036854775807)

scala> BigInt(Long.MaxValue) + 1
res6: scala.math.BigInt = 9223372036854775808

scala> res5 contains res6
res7: Boolean = false

scala> res5 contains res6.longValue
res8: Boolean = true
```
I have found more long-standing Range bugs too.  These classes are surprisingly subtle.
