This turned out to be harder than I thought, so I am stopping for now.  I attached a patch which is closer to right, but causes five tests to fail.  One test fails because the error message changed; three fail because the interpreter output doesn't match what it expects thanks to some types being e.g. Int(5) instead of Int; and the last one fails over a deeper issue.

Here is a test case for the last failure:
{code}
abstract class NeedsXEarly { val x: Int }
class Foo extends { val x = 1 } with NeedsXEarly
{code}
This leads to an exception in the compiler which says "assignment to non variable." Basically what happens is that when the time comes to type that assignment, the compiler has already concluded that x is the singleton type Int(1).  As stated in the comments for adapt, it "Convert expressions with constant types to literals", which in this case replaces x with 1, so it sees 1 = 1 and bails.

As I'm getting further into compiler areas where my understanding is close to nil, I am hereby moving on (though I'd be happy to take another shot at this with a little direction on what approach is preferred.)
