I just wrote a logging interpolator that takes an implicit logger. I expanded my unit test horizon with the example in scala-logging:
```scala
  "Using the error interpolator" should {

    "call the underlying logger's error method if the error level is enabled" in {
      val f = fixture(_.isErrorEnabled, true)
      import f._
      import delogging._
      error"""msg"""
      verify(underlying).error(msg)
    }
  }
  def fixture(p: Underlying => Boolean, isEnabled: Boolean, output: String = "msg") =
    new { 
      val msg = output
      val cause = new RuntimeException("cause")
      val arg1 = "arg1"
      val arg2 = new Integer(1)
      val arg3 = "arg3"
      implicit val underlying = mock[org.slf4j.Logger]
      when(p(underlying)).thenReturn(isEnabled)
    }
```
Do I understand correctly that the question is whether the underlying logger should remain an implicit in scope of the test?
