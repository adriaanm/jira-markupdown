I've got my ups and downs upside down, that last comment wasn't quite right.

I see now that the key difference in inference is that scalac solves for T in `adapt(Test.this.AfromB[T], pt = Test.A[Test.C])`, whereas dotc does this a little later at `adapt((Test.AfromB[T]: Test.A[Test.C], pt = Test.A[Test.C])`

By that time, T has the constraints:
```
Constraint(
 uninstVars = T;
 constrained types = [T <: Test.B[LazyRef(T)]]Test.A[T]
 bounds = 
     T >: Test.C <: Test.B[LazyRef(T)] & Test.C
 ordering = 
)
```

Given that the T does not appear in the type of this expression, dotc instantiates it to its lower bound, C.

This differs from scalac, which would have picked the upper bound (had it not been cyclic), given that T was in a contravariant position.
