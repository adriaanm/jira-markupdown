I took a look at this in the debugger, and attached an analysis. Still can't pare it down to a small example, unfortunately :(
```scala

      Transforming unit Pointed.scala. Inspection of the AST here shows that 's' in PromisePure(s) already has the wrong symbol. I expect it to
      be the parameter 's' from PromisePointed, instead it is bound to the parameter 's' from another file.
      
        // Pointed.scala
        trait Pointed[P[_]] extends Functor[P] with Pure[P]

        object Pointed {
           import concurrent._
           implicit def PromisePointed(implicit s: Strategy[Unit]) = pointed[Promise]
   // = Pointed.this.pointed(
   //         scalaz.this.Functor.PromiseFunctor(),
   //   scalaz.this.Pure.PromisePure(s).$$asInstanceOf[scalaz.Pure]())
   //                                |__ 's' bound to out-of-scope implicit
   //                                     param of Applicative.PromiseApplicative()!
        }
      
        //Applicative.scala:
        trait Applicative[Z[_]] extends Pointed[Z] with Apply[Z] {
          override def fmap[A, B](fa: Z[A], f: A => B): Z[B] = apply(pure(f), fa)
        }

        object Applicative {
           implicit def PromiseApplicative(implicit s: Strategy[Unit]) = applicative[Promise]           
        }               
```
