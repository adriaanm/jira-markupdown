Yes, I/O can't be the main explanation for the low CPU utilization, workload division is more likely. 
Although classloading (unpickling, reflection) and classwriting (GenJVM, less so for GenASM) take time.

Regarding even division of the workload:
# jvisualvm reveals (picture below) most worker threads in the ANT process waiting for something (yellow). 
I'm talking about "{{ForkjoinPool-1-worker-1}}" to "{{ForkjoinPool-1-worker-12}}". 
Are they partest's actors?
# Not sure about the distribution of running times for tests (that is, once they've been compiled, where most of the I/O takes place). 
After "visual inspection" the longest I noticed was ctrie taking a minute and a half. 
Doesn't seem that a few tests monopolize the run.

Another observation: run "{{partest --run}}" and jvisualvm. Do you see those Scala logos on the top left? 
Those are tests running in parallel. Select "Show live threads only" to keep the timeline uncluttered. 
Except at the beginning, there are about 5 logos at any given time. That's too low, even on an 8-core machine.

!jvisualvm.png!

