I don't think this is worth doing just for Option.apply, while leaving the rest of the language and standard library unchanged. It wouldn't be consistent with how Scala handles boxed vs. unboxed types in any other situation, and it would change the meaning of existing code. (Plus it would involve adding overloads on Option.apply, which currently has none, which is desirable; overloading is something of a last resort.)

And as for the possibility of carrying this thinking through to the rest of the language and standard library, I think that's a non-starter. The design of how Scala treats boxed Java types was settled at least a decade ago and the benefit would have to be very high indeed in order to justify the cost of pushing through such a fundamental change.

The only change in this vein I can envision perhaps being accepted would be adding an additional method, not named `apply`, that is overloaded as you propose. {{Option.unbox}}, I guess, by analogy with existing methods like {{Long.unbox}} (which translate nulls to 0). I dunno, though, {{Option\(x\).map(_.longValue)}} or {{Option\(x\).map(Long.unbox)}} seem not so bad to me. And I have not seen a need for this come up very often on SO, IRC, conversations with colleagues, etc.
