I agree with the covariance, but maybe I can better tell where the source of existential confusion comes from.
The thread is:
https://groups.google.com/forum/?fromgroups#!topic/scala-user/x7eeo4zUAQA

It's the warning message: "the existential type T forSome { type T }, which cannot be expressed by wildcards" which is suggesting inequivalence. 
In your example I can see too that it can be expressed by wildcards: List[_ <: Any] is expressed by wildcards. Or does it mean "which is expressed by wildcards"?

I think I interpreted "which cannot be expressed by wildcards" and the often lexical/syntactic sugared use of underscore as a text replacement in a certain context e.g. x => x, but the message means thus "the existential type T forSome { type T }, which cannot be expressed as a type by wildcards on its own i.e. out of this context" which is a kind of contradiction because existentials exist in a context.

So okay I agree,
 List[_] =:= List[T forSome { type T }] =:= List[T] forSome { type T }

Underscore _ is not T forSome { type T } but
 [_] as a whole is syntactic sugar for [T] forSome { type T }
or
 [_] as a whole is syntactic sugar for [T forSome { type T }]

But still the multiple syntactic sugars of underscore with the covariant equivalence is confusing in this context.  

f(a)==f(b) does not mean a==b but if f(a)==f(b) and (b) and (a) have the same lexical representation say (_) so then you can write f(_)==f(_).
Then you cannot see that a and b can be actually different so an warning message when applying explicitly a it needs a language.existentials and when applying explicitly b it doesn't need it, is confusing.

{noformat}
C:\Users\Dave>scala -feature
Welcome to Scala version 2.10.0-M5 (Java HotSpot(TM) Client VM, Java 1.6.0_33).
Type in expressions to have them evaluated.
Type :help for more information.

scala> val l: List[ T forSome { type T }] = List(1)
<console>:7: warning: the existential type T forSome { type T }, which cannot be
 expressed by wildcards,  should be enabled
by making the implicit value language.existentials visible.
This can be achieved by adding the import clause 'import language.existentials'
or by setting the compiler option -language:existentials.
See the Scala docs for value scala.language.existentials for a discussion
why the feature should be explicitly enabled.
       val l: List[ T forSome { type T }] = List(1)
                      ^
l: List[T forSome { type T }] = List(1)

scala> val l: List[T] forSome { type T } = List(1)
l: List[_] = List(1)
{noformat}
So now it is suggested that the above expressions are not equivalent.
