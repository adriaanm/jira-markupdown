The example in full, with comments: 

{code}
object X { // http://lampsvn.epfl.ch/trac/scala/ticket/4457

  class N[T]
  class NE[T] extends N[T]
  class NN[T] extends N[T]
  class AA[A1,A2]
  class BB[A]    

  // conv1 and conv2 just convert the arguments to the aFunc invocation below 
  implicit def conv1(i: Option[Float]) = new NE[Option[Float]]
  implicit def conv2(i: Int)           = new NE[Int]

  // just here to convert the result of aFunc invocation below 
  implicit def conv4(op: AA[Float,Int]) = new N[Float]

  def aFunc[A,B](a: NE[Option[A]], b: NE[B]) = new AA[A,B]

  /* Uncommenting all three of the members below causes ambiguity among conversion of aFunc's result */

  // conv3 is a candidate to convert the result of the aFunc overload above into bFunc's argument 
  implicit def conv3(op: AA[Byte,Byte]     ) = new N[Byte] 
  implicit def conv5(e : BB[java.util.Date]) = new NN[java.util.Date]

  def aFunc[A]  (a: NN[Option[A]], b: NN[A]) = new BB[A] 
  // the aFunc overload above is never picked because 
  //    conv1, conv2 return NE's not NN's 
  // and 
  //    there are no other conversions into NN's from the args to aFunc's call below. 
  // HOWEVER uncommenting it (together with conv3 and conv5) leads to ambiguity 

  def bFunc[T1](e1: N[T1]) = {}
  
  /* for programs that typecheck, the arguments to the aFunc call below are always expanded like this: 
   *
   *    X.this.aFunc[Float, Int](  
   *                                X.this.conv1(scala.Some.apply[Float](4.0)), 
   *                                X.this.conv2(0)
   *                            ) 
   *
   * attempts to convert the result of aFunc's call lead to ambiguity 
   * if all of conv3, conv5, and the aFunc overload (line 24) are uncommented.
   *
   */

  bFunc( 
         aFunc( 
                  Some(4F)    , /* after conversion: new NE[Option[Float]] */
                  0             /* after conversion: new NE[Int]           */
              ) 
       ) 
  
}
{code}
