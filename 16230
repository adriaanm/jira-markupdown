{code}
scala> object +: {
     |     def unapply[T, Coll <: LinearSeqLike[T, Coll]](t : Coll with LinearSeqLike[T, Coll]) : Option[(T, Coll)] =
     |       if (t.isEmpty) None
     |       else Some(t.head -> t.tail) // TODO - Try to remove cast.
     | }
defined module $plus$colon

scala>  +:.unapply(List(1,2,3,4))
res3: Option[(Int, List[Int])] = Some((1,List(2, 3, 4)))

scala>  List(1,2,3,4) match { case x +: xs => xs }
res4: List[Int] = List(2, 3, 4)
{code}

works fine, but if we remove the seemingly redundant second constituent in `t : Coll with LinearSeqLike[T, Coll]`, type inference fails, because Coll is f-bounded (?)

can we generalise this pattern to make type inference work for f-bounds?
