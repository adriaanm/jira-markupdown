Replying to [comment:12 anovstrup]:
> Replying to [comment:11 jibal]:
> > "Implicit conversions in general carry the danger of appearing to give behavior to null values, contrary to the spec."
> > 
> > That is *not* contrary to the spec; the spec refers to "A reference to any other member of the “null” object" but implicitly applied methods *aren't* members of the “null” object. It would not only be unwise, but impossible, to enforce implicit conversions throwing NPE's when applied to null because in general they are arbitrary user code and can do whatever they please.
> 
> Agreed, but I think my comment was unclear.  Implicit conversions do not give behavior to null values contrary to the spec, but they can _appear_ to give behavior to null values contrary to the spec. My point was that any library developer (especially the developers of the standard library) must weigh the benefits of any implicit conversion against the potential confusion they can cause.

Well, this is a bug report about the spec, not guidance about library design. But on that score:

The design of Scala is committed to the use of implicits, which are non-local effects that can give all sorts of contrary-to-spec _appearances_, as code readers go hunting around in the receiver class and superclasses looking for where those methods are defined and failing to find them. In the REPL, if I type "1".<TAB> I do not see toInt as a possible method, yet "1".toInt is valid Scala. I think this is a very serious problem with the usability of the language that goes way beyond this minor stuff about absent NPE's. But it's not so much a reason for library developers to not use implicits as it is a reason to develop documentation tools that do not ignore the impact of implicits. The REPL, and every IDE, should invoke the compiler to tell me exactly what methods I can apply at that point, and Scaladoc should gather up every implicit def into a special listing that tells me what implicit methods apply if I import the enclosing scope -- I should not have to peruse the source to find the types of the left operands and then go look at the source of the return type to find the type of the right operand and the name of the method -- that's madness.
