Inlining the forwarder method could be sufficient: since the forwarder contains an explicit call of the implementation method wouldn't that be dealt with transitively?

However it seems like `lookupIMethod` would need to do the same thing as `lookupImplFor`, namely look at `overridingSymbol` while walking up the inheritance chain. 

Also, `lookupImplFor` aborts the traversal if `sym.owner.isTrait`. I'm not sure about the reasoning behind that check.

I may be missing something (a lot, possibly) but to me it looks like the lookup logic could be simplified into something like this:
```scala
      // look up methSym for a receiver instance of classSym:
      var actualClass = classSym
      var actualMeth = methSym
      while (actualMeth.owner != actualClass) {
        val ov = actualMeth.overridingSymbol(actualClass)
        if (ov != NoSymbol) {
          actualMeth = ov
          assert(actualMeth.owner == actualClass)
        } else {
          actualClass = actualClass.superClass
        }
      }
      val iclass = icodes.icode(actualClass,true)
      val imethod = iclass.lookupMethod(actualMeth)
```
