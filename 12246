Let me quickly outline why this is not straightforward

{code}
trait T extends Any {
  def s: String
  def t1 = s.toUpperCase
}
{code}

This universal trait needs to be compiled into a valid interface. We don't know that {{s}} is potentially implemented as a value class field - in fact, T can be implemented by a non-value class. So the bytecode is

{noformat}
public abstract interface T {
  public abstract s()Ljava/lang/String;

  public default t1()Ljava/lang/String;
    ALOAD 0
    INVOKEINTERFACE T.s ()Ljava/lang/String;
    INVOKEVIRTUAL java/lang/String.toUpperCase ()Ljava/lang/String;
    ARETURN
}
{noformat}

Now we introduce a value class

{code}
class C(val s: String) extends AnyVal with T
{code}

If we don't want to break separate compilation (change the body of T.t1, re-compile T, also C should get the new impl) then we have no choice but to invoke T.t1, which requires an instance.


Now there's a few possibilities. We can get actually already quite close just with inlining, but it (currently, 2.12.0-M4) requires an {{@inline}} annotation:

{code}
trait T extends Any {
  def s: String
  @inline final def t1 = s.toUpperCase
}
class C(val s: String) extends AnyVal with T
class A { def f1(c: C) = c.t1 }
{code}

gives

{noformat}
public final class C implements T  {
  public f1(Ljava/lang/String;)Ljava/lang/String;
    NEW C
    DUP
    ALOAD 1
    INVOKESPECIAL C.<init> (Ljava/lang/String;)V
    INVOKEINTERFACE T.s ()Ljava/lang/String;
    INVOKEVIRTUAL java/lang/String.toUpperCase ()Ljava/lang/String;
    ARETURN
{noformat}

We're planning to extend our box-unbox optimization to value classes (currently supports tuples and primitive boxes), which would eliminate the allocation. This will probably not happen for 2.12.0, unfortunately - there's not much time left. Note that the JVM's escape analysis will probably also eliminate the box.


Other options I see:

* we could introduce some marker annotation to tell the compiler that {{def s: String}} is potentially a value class field. Then we could split up methods that access {{s}} into a static method that gets the string as parameter and the instance method that invokes {{s()}} and passes it to the static method. the value class could then invoke the static method.
* when generating the value class code, we could locate the bytecode of methods inherited from universal traits and duplicate it, and attempt to create static copies, replacing accesses to {{this.s()}} by the value class field. that sounds a bit complicated though, it would have to happen during the optimizer where we can read and duplicate bytecode.

the second of this ideas is related to inlining (code is duplicated), also related to what dimitry is researching for dotty (creating specialized copies of methods).
