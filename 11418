Let's look at through this example. I'm avoiding the placeholder syntax for existentials to highlight the different types.

{code}
trait C[A] { def bar(f: A => A) }

trait M[A] { def m: M[Y] forSome { type Y } = ??? }

object Test {
  def c[A](a: A): C[A] = ???

  def x1(m: M[Int]) = c/*[M[Int]]]*/(m).bar(_.m) // found M[Y] where type Y, required M[Int]

  def x2(m: M[Int]) = c/*[M[X]]]*/(m : M[X] forSome { type X }).bar(_.m) //found M[Y] where type Y, required M[X] where type X

  def x3(m: M[Int]) = c[M[Z] forSome {type Z}](m).bar(_.m)
}
{code}

I don't believe that you can provide an argument to method `c` that will lead to inference of the type argument explicitly provided in `x3`, which is the only one that will end up allowing `_.m` to typecheck.
