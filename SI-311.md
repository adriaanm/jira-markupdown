Scala code: (anything dealing with synchronization)

class Partner {
  def hasNext: Boolean = Partner.this.synchronized((this == null) ) 
}

MSIL code generated by scalac-net:
{code}
            .try {
                .line       5
                IL_0008:    ldarg.1
                IL_0009:    ldarg.0
                IL_000a:    callvirt    instance bool 'test.Partner'::'f'()
                IL_000f:    bne.un      IL_001a
                .line       5
                IL_0014:    ldc.i4.1
                IL_0015:    br          IL_002b
                .line       5
                IL_001a:    ldc.i4.0
                IL_001b:    br          IL_002b
                .line       5
                IL_0020:    box         [mscorlib]'System.Boolean'
                IL_0025:    ldloc.0
                IL_0026:    call        void [mscorlib]'System.Threading.Monitor'::'Exit'(object)
                IL_002b:    stloc       1	// object '$$exhResult'
                IL_002f:    leave       IL_0040
            }
            catch [mscorlib]'System.Exception' {
                IL_0034:    ldloc.0
                .line       5
                IL_0035:    call        void [mscorlib]'System.Threading.Monitor'::'Exit'(object)
                IL_003a:    throw
                IL_003b:    leave       IL_0040
            }
{code}
See where the mistakes are? Look at these instructions:
{code}
                IL_0015:    br          IL_002b
                IL_001b:    br          IL_002b
{code}

They branch to after the thread lock is exited. Editing these instructions to target IL_0020 causes the lock to be released normally and for the file to pass verification. Now if I can just figure out how to do that... :)
 
Looking at this code, its all compiled wrong. The exit shouldn't be in a catch all, rather it should be in a finally block: If the exist crashes in the try block, then everything is screwed. Also, I don't understand why we are boxing the boolean, it should be:


{code}
        .method public virtual hidebysig instance bool 'foo'() cil managed
        {
            .maxstack   3
            .locals init (
                object 'monitor1',
                int32 '$$exhResult')
            .line       4
            IL_0000:    ldarg.0
            IL_0001:    dup
            IL_0002:    stloc.0
            IL_0003:    call        void [mscorlib]'System.Threading.Monitor'::'Enter'(object)
            .try {
                .line       4
                IL_0008:    ldarg.0
                IL_0009:    callvirt    instance int32 'test.Test'::'test'()
                IL_000e:    ldc.i4.0
                IL_000f:    bne.un      IL_001a
                .line       4
                IL_0014:    ldc.i4.1
                IL_0015:    br          IL_002b
                .line       4
                IL_001a:    ldc.i4.0
                IL_001b:    br          IL_002b
                .line       4
                IL_002b:    stloc       1	// object '$$exhResult'
                IL_002f:    leave       IL_0040
            } finally {
                IL_0034:    ldloc.0
                .line       4
                IL_0035:    call        void [mscorlib]'System.Threading.Monitor'::'Exit'(object)
                endfinally
            }
            IL_0040:    ldloc       1	// object '$$exhResult'
            .line       4
            IL_004a:    ret
        }
{code}
