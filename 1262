The following is enlightening:

{code}
object Foo{
  final val Thing = '3';
}

object Bar{
  final val Thing : Char = '3'
}
{code}

Observe what happens:

{code}
david@mel:~$$ fsc -Xprint:explicitouter switch.scala 
[[syntax trees at end of explicitouter]]// Scala source: switch.scala
package <empty> {
  final class Foo extends java.lang.Object with ScalaObject {
    def this(): object Foo = {
      Foo.super.this();
      ()
    };
    final private[this] val Thing: Char('3') = '3';
    final <stable> <accessor> def Thing(): Char = Foo.this.Thing
  };
  final class Bar extends java.lang.Object with ScalaObject {
    def this(): object Bar = {
      Bar.super.this();
      ()
    };
    final private[this] val Thing: Char = '3';
    final <stable> <accessor> def Thing(): Char = Bar.this.Thing
  }
}
{code}

Adding the type annotation widens the type of the private version from Char('3') to Char. This is almost certainly what's causing these things to fail to be inlined as constants and thus what's causing the switch statement to not get generated.

So it's technically not an issue in the pattern matcher. But I'd be amazed if it manifests as a problem anywhere else. 
