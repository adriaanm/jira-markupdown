To motivate fixing this bug, consider the following - automatically converting nullable types to Option:
```scala
case class AuthorizationRequest(
  val sid: String,
  val oid: Option[String],
  val o_class: Option[String],
  val act: Option[String],
  val ctx: Option[String]
)

trait AuthorizationClient {
  def authorize(req: AuthorizationRequest): Task[Unit]
}

object AuthorizationClient {
  implicit class AuthorizationExts(client: AuthorizationClient) {
    def authorize(sid: String, oid: String = null, o_class: String = null, act: String = null, ctx: Json = null) = {
      client.authorize(AuthorizationRequest(sid = sid, oid = Option(oid), o_class = Option(o_class), act = Option(action), ctx = Option(ctx)))
    }
  }
}
```

The intermediate `Request` type just adds verbosity, so the `authorize` method on `AuthorizationExts` makes it easy to call `authorize`. But `authorize` is long enough (and its arguments have the same type) that it would be nice to call it with named arguments:
```scala
auth.authorize(sid ="foo", oid = "bar", o_class = "bif", etc.) 
```

This also makes it impossible to omit parameters and use defaults instead.  Self-contained example in my next comment.
