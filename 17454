We recently had this problem with spray:

{code}
trait A {
  def foo: Long
}

object Main {
  def a(): A = new A {
    var foo: Long = 1000L

    val test = () => {
      foo = 28
    }
  }
  def main(args: Array[String]) {
    println(a().foo)
  }
}
{code}

will throw

{code}
java.lang.AbstractMethodError: Main$$anon$1.foo()J
	at Main$.main(Main.scala:14)
	at Main.main(Main.scala)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)

{code}

Important things here:
  * implementing foo with a var
  * accessing the setter of foo in an inner anonymous class
  * function a() having an explicit return-type

The same behavior can be observed in 2.8.2, 2.9.2, and 2.10.0-M7.

A workaround is not to implement A.foo directly with a var but use an auxiliary var and implement foo separately.
