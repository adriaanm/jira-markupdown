immutable.BitSet's builder uses an immutable.BitSet inside, and every time a new element is added to the builder it copies this BitSet. This makes methods like BitSet.++, which use the builder, run in O(N^2) rather than O(N) time, which makes creating immutable.BitSets with large sets very difficult.

Here is a new implementation that solves this problem:

{code}
  /** A builder that takes advantage of mutable BitSets. */
  def newBuilder: Builder[Int, BitSet] = new Builder[Int, BitSet] with Proxy {
    val self = new mutable.BitSet
    def +=(x: Int): this.type = {self += x; this}
    def clear() = {self.clear}
    def result: BitSet = self.toImmutable
  }
{code}
