Just ran into this as well. Another example:
{code:scala}
trait X {
  type Id[+A] = A
  def foo[A](x: Id[A]) = x
}
{code}
{{error: covariant type Id occurs in contravariant position in type X.this.Id[A] of value x}}

However, if the type alias is defined in a separate trait, there's no error.
{code:scala}
trait X { 
  type Id[+A] = A 
}
trait Y extends X {
  def foo[A](x: Id[A]) = x
}
{code}
