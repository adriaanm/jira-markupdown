Currently implicit defs, which are also macros, are expanded too early (typed1 in typedImplicit1), which means that they cannot be used to generate type tags.
```scala
scala> def impl[T: c.WeakTypeTag](c: Context) = { println(c.weakTypeOf[T]); c.Expr[C[T]](c.universe.Literal(c.universe.Constant(null))) }
impl: [T](c: scala.reflect.macros.Context)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[C[T]]

scala> class C[T]defined class C

scala> def impl[T: c.WeakTypeTag](c: Context) = { println(c.weakTypeOf[T]); c.Expr[C[T]](c.universe.Literal(c.universe.Constant(null))) }
impl: [T](c: scala.reflect.macros.Context)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[C[T]]

scala> implicit def foo[T]: C[T] = macro impl[T]
foo: [T]=> C[T]

scala> implicitly[C[Int]]
<console>:30: foo is not a valid implicit value for C[Int] because:
incompatible: C[T] does not match expected type C[Int]
              implicitly[C[Int]]
                        ^
<console>:30: error: could not find implicit value for parameter e: C[Int]
              implicitly[C[Int]]
                        ^
```
