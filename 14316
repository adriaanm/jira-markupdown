As was discussed on the list, Enumeration lacks the advantages of being object oriented, while case classes/objects lack the advantages of being enumeratable. A simple subclass of Enumeration, which I would like to contribute to the standard library, solves this problem. The idea of using reflection to solve the problem of lazy object intialization comes from lift's MetaMapper.

 This only works for
```scala
val enums = new CaseEnum { ... }
```
or
```scala
class Enums extends CaseEnum { ... }
object Enums extends Enums
```
but for
```scala
object Enums extends CaseEnum { ... }
```
you have to reference the members in the body,
e.g.
```scala
A; B; C
```
Example usage:
```scala
val Colors = new CaseEnum {
  sealed abstract class Color extends Case
  object Red extends Color
  object Blue extends Color
}
/*OR*/ object Colors extends CaseEnum {
  sealed abstract class Color extends Case
  object Red extends Color
  object Blue extends Color
  (Red,Blue)
}
Colors.foreach {c=> println("Value "+c+" is mapped to "+Colors.cases(c))}
/* should print
Red is mapped to Red
Blue is mapped to Blue
*/
```
Note that members do not actually have to be case classes or case objects.
Also, I haven't tested it on 2.8. Is there a significant difference in Enumeration?

Here is my source code:
```scala
class CaseEnum extends Enumeration {
  private val _cases = new scala.collection.mutable.HashMap[Value, Case]
  trait Case {
    private val name = {
      val name = getClass.getName
      if(name.endsWith("$$"))
        name.substring(name.lastIndexOf("$$", name.length-2)+1, name.length-1)
      else
          name.substring(name.lastIndexOf("$$")+1)
    }
    val value = Value(name)
    _cases += (value -> this)
  }
  
  def cases(v: Value) = _cases(v)
  for {
    m <- getClass.getMethods
    if m.getReturnType.getName.endsWith("$$"+m.getName+"$$") &&
      m.getParameterTypes.length==0 &&
      classOf[Case].isAssignableFrom(m.getReturnType)
  } {
    m.invoke(this)
  }
}
```
