I finally get it. I wasn't thinking about the fact that the return type can change covariantly. What should the rule be though? Should a subtype method have as return type the first explicitly declared type in the class hierarchy? Meaning, the following should be possible:
```scala
class A{
  def x: Option[String] = None
}

class B extends A{
  override def x: None = None
}

// should NOT compile
class C extends B{
  override def x = Some("123")
}

class D extends A{
  override def x = None
}

// should compile
class E extends D{
  override def x = Some("123")
}
```

Am I right?
