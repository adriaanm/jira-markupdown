{code}
trait Iterable[+S]
trait Box[U]

trait A {
 type T <: Iterable[S] forSome { type S <: Box[U]; type U }
}

trait B extends A {
 type T <: Iterable[S] forSome { type S <: Box[U]; type U }
}
{code}

Compilation with 2.8.0.r18050-b20090618020144 gives:

{code}
a.scala:9: error: overriding type T in trait A with bounds >: Nothing <: Iterable[_ <: Box[U]];
 type T has incompatible type
 type T <: Iterable[S] forSome { type S <: Box[U]; type U }
{code}

But according to SLS, 3.5.1 Type Equivalence:
Two existential types (ï¿½3.2.10) are equivalent if they have the same number of quantifiers, and, after renaming one list of type quantifiers by another, the quantified types as well as lower and upper bounds of corresponding quantifiers are equivalent.

So, every existential type must be equivalent to (and conform to) itself.
