{code}
import scala.reflect.macros.WhiteboxContext

object Macros {
  def impl[T](c: WhiteboxContext)(implicit T: c.WeakTypeTag[T]) = {
    import c.universe._
    import definitions._
    val fields = T.tpe.declarations.toList.collect{ case x: TermSymbol if x.isVal && x.isCaseAccessor => x }
    val Repr = appliedType(TupleClass(fields.length).asType.toType, fields.map(_.typeSignature))
    q"new Generic[$T]{ type Repr = $Repr }"
  }
}
{code}

{code}
trait Generic[T] { type Repr }
object Generic {
  type Aux[T, Repr0] = Generic[T] { type Repr = Repr0 }
  import scala.language.experimental.macros
  implicit def materializeGeneric[T]: Generic[T] = macro Macros.impl[T]
}

object Test extends App {
  case class C(x: Int, y: Int)

  // does work: the implicit is materialized and Repr is successfully inferred as (Int, Int)
  def reprify[T, Repr](x: T)(implicit generic: Generic.Aux[T, Repr]) = ???
  reprify(C(40, 2))

  // doesn't work: can't find implicit value for parameter e: Generic.Aux[Test.C,(Int, Int)]
  // implicitly[Generic.Aux[C, (Int, Int)]]
}
{code}

upd. Note that the original bug report looked differently, involving an anonymous class that inherited from a class that takes an implicit of type Generic.Aux. However, it all boiled down to a very simple reproduction, so I decided to update the description. Therefore if initial comments look confusing to you, don't worry - it's okay. If you really wonder about what was going on, take a look at the issue's history.
