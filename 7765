@Seth I agree that these examples aren't compelling -- my intent was to give examples that would exhibit the behavior with the least amount of extraneous cruft to wade through (i.e. simplicity over realism). My related comments on the mailing list make the case a bit more clearly:

https://groups.google.com/d/topic/scala-user/21IbHRhgxQU/discussion

"The real danger, of course, is that the right-hand side need not be
typed explicitly.  The type may be inferred locally, or it may be the
return type of a method, etc. A refactoring could easily lead to
runtime failures."

The complaint is not that the compiler does not use its knowledge of what "1" is, but rather that it doesn't use its knowledge of what Tuple2 is.  Any unintended widening of the static type on the right-hand side could lead to runtime failure.  Here's a more realistic example (although it fails the simplicity test):
```scala
class Character(name: String)
case class Player(name: String, age: Int, gender: Gender) extends Character(name)
case class NPC(name: String, species: Species, language: Lang) extends Character(name)

// Originally, getCharacter returns a Player.  Later, it's modified 
// to return a Character. After the change, the following line of 
// code will still compile but may fail at runtime.  
val Player(_, a, g) = getCharacter("Dingus")
```

The original developer intended his code as shorthand for
```scala
val c = getCharacter("Dingus")
val a = c.age
val g = c.gender
```
which *would* fail to compile after the change in `getCharacter`.
