Actually, my suggestion is the opposite of `Option\[SomeCannotPossiblyBeNullType\]`.

That is, as I said you ban `null` from the interior of your system completely. It never exists, ever. If you have something that can never be null, you just reference it directly. You only use the Option in instances where you're not sure if you have it or not:
```scala
var x: SomeCanNeverBeNull = nonNullReference;
var y: Option[SomeCanNeverBeNull] = Option(nullableReference); // Oops, it actually was null, but we handled it cleanly
```

That is, you seem to be assuming that nullable is your default and you're flagging non-null cases. My understanding of idiomatic Scala code was that you should consider all variables non-nullable, and flag values that might not be present as `Option`.

If you do your null-checks at system boundaries (IO, etc.) and when calling Java libraries, a `null` should literally never enter your system. You shouldn't have to write unit tests around them, or boiler-plate null-checking code, because they just don't exist.

YMMV, and my take might be wrong, but I never get a `NullPointerException` inside a system unless I forget a check at the system boundary.
