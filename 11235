I have not noticed problems reported in SI-7963, but I think it does not relate this. There is some problems in PipedProcesses as listed bellow:
- source and sink leak when b.run() fails at https://github.com/scala/scala/blob/538aa22ec8144430e778a34bc749eccb6f5dbf4c/src/library/scala/sys/process/ProcessImpl.scala#L132

- source, sink and second leak when a.run() fails at https://github.com/scala/scala/blob/538aa22ec8144430e778a34bc749eccb6f5dbf4c/src/library/scala/sys/process/ProcessImpl.scala#L133

- source and sink leak when Process.exitValue() interrupted in https://github.com/scala/scala/blob/538aa22ec8144430e778a34bc749eccb6f5dbf4c/src/library/scala/sys/process/ProcessImpl.scala#L135

- first and second do not properly connected when None putted to currentSink before sink receive Some(InputStream) in https://github.com/rubyu/scala/blob/538aa22ec8144430e778a34bc749eccb6f5dbf4c/src/library/scala/sys/process/ProcessImpl.scala#L138

I tried to fix these problems in https://github.com/scala/scala/pull/3913, but there was still a few bugs. I'm fixing it. 

And I have a question about BasicIO.transferFully.

- BasicIO.transferFullyImpl is a function copying data from InputStream to OutputStream. https://github.com/scala/scala/blob/538aa22ec8144430e778a34bc749eccb6f5dbf4c/src/library/scala/sys/process/BasicIO.scala#L223

- process.onInterrupt catches InterruptedException. https://github.com/scala/scala/blob/159baa268e5cc14b50bf29a40fff922e36dd7bc9/src/library/scala/sys/process/package.scala#L238

therefore it seems meaningless that BasicIO.transferFully using onInterrupt for catching a exception. I guess this originally intented to catch InterruptedIOException, and I suggest the correct implementation is:

{code}
      def onIOInterrupt[T](handler: => T): Throwable =?> T = {
        case _: InterruptedIOException => handler
      }
{code}

{code}
  def transferFully(in: InputStream, out: OutputStream): Unit =
    try transferFullyImpl(in, out)
    catch onIOInterrupt(())
{code}

Is this prediction not wrong?
