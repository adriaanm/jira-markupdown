This is a different idea of mutability than Scala has.  (Rust has this idea.)

That is, in Rust, mutability is a property of the **context**.  If you are in a mutable context, you can mutate things.  If you are in an immutable context, you can't.  If you stick a mutable thing into an immutable context, you can't mutate it any more.  (Conversely: if you stick an immutable thing into a mutable context, you can mutate it.)  There are both advantages and disadvantages to this approach.  It lowers surprise when you wield the system intentionally, but it makes it difficult for you to really protect something from mutation.

In Scala as it stands, mutability is a property of the **field** and therefore you get cases where immutable fields hold mutable objects and vice versa.  This is just one example of this sort.  Option(Array(1,2,3)) is another.

I do think it's bad that X* doesn't have a very clear type, so you can be thinking "immutable" and yet get a mutating version handed to you.  Personally I would just disallow X* in case classes, or think of some more robust fix.  If you want a vararg in your case class to make it seem like the case class can take an arbitrary number of parameters, you'll be have a bit of a rough ride:
```scala
scala> case class C(a: Int, xs: Int*)
defined class C

scala> C(1,2,3)  // toString doesn't match what we type
res0: C = C(1,WrappedArray(2, 3))

scala> C(1, List(2,3): _*)  // Wrapped type leaks through
res1: C = C(1,List(2, 3))

scala> res0 match { case C(a,b,c) => 1 + 2 + 3; case _ => 0 }  // Can match 3 args!
res2: Int = 6

scala> res0.productArity  // Wait, what?
res3: Int = 2
```
