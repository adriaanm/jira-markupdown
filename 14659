It's my understanding that the Iterable.projection method should return a non-strict iterable, that is, a iterable that only accesses its elements on demand.

However, if the iterable is, in fact, a List, then the resulting non-strict iterable behaves differently.  When mapped, the List projection always invokes the mapping function once more than necessary.

For example, consider the following code:
```scala
List(1,2,3).projection.map { i => println(i); i }.find(_ == 1)
```

It prints both 1 and 2, not just 1.

If the mapping function has side effects or (more likely) is simply time-consuming, then using projection is impractical unless the application knows that the iterable is not a List.  Obviously the mapping function in this case trivial, but it just as well might be callTheVerySlowWebService, in which case invoking it once more than necessary is awfully inconvenient, even if doing so produces no side-effects.

Furthermore the "always call the map function once more than necessary" behavior of List.projection.map is counterintuitive and is **never** the behavior that the application expects or wants, even if the application can tolerate it.
