Thanks for your quick review. Unfortunately I don't succeed eliminating more than a single line because to demonstrate, we do need two overloading and another two implicit methods:
{code}
abstract class ImplicitRepeated[CC[N, R <: List[N]]] {
  def f[N, R <: List[_]](elems: Either[N,R]*) // alternative a)
  def f[N, R <: List[_]](props: String,
                         elems: Either[N,R]*) // alternative b) 
}
object Predef {
  implicit def anyToN[N] (x: N) = Left (x)
  // the following implicit causes "cannot be applied" errors
  implicit def anyToR[R <: List[_]] (x: R) = Right(x)
}
class Test[CC[N, R <: List[N]]] (c : ImplicitRepeated[CC]) {
  import Predef._
  c.f( "A", 1, 2) // should be implicitly resolved to alternative b)
  c.f( 1, 2 )     // should be implicitly resolved to alternative a)
}
{code}
Maybe the key to resolve this problem is to find out, why any2R is considered for the applications of f, even if none of the arguments is of type <: List[_]. Should not the two above applications be valid irrespective of the presence of any2R?
