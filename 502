Thanks for the effort, we will discuss these. 

Personally, I think we should be careful not to bloat the API with special purpose methods. Many things can be expressed with map and flatMap already. Since Option is an Iterable, it interacts with other collections. Function `somes`, e.g., can be written as:
{code}
val someSet: Set[Option[Int]] = ...
val set = someSet.flatMap(x=>x)
{code}

This has the benefit that we maintain the collection type, in this case Set.

Other methods such as ifNone don't add much. If we are going to add it, we probably need to add ifSome to Option and ifEmpty and ifNotEmtpy to collections. Saving just a few key strokes doesn't justify this.

On the other hand, I sometimes also wish I could express things with Options more concisely. I don't see a good way to do it though.
