I like the simplicity of this proposal. It also provides a hook for reducing constructor macros to normal def macros.
It's a lot simpler than `DelayedInit`, though I don't see how it lets us eliminate the main boilerplate (but that's okay -- maybe we can use top-level defs for that).

I'd propose considering how this relates to language virtualization and constructor macros.
Would be nice to use the former to subsume the latter with regular macros.

{code}
trait OnCreate[+T] { self: T =>
    // Don't actually include this method signature, as we cannot express that we want
    // to allow a subclass implementation to add an implicit arg section or that it could be a macro
    // def completeConstruction: T
}
{code}

for any `C <: OnCreate[C]`, we rewrite `new C` to `(new C).completeConstruction` in the same style as for comprehension desugaring/language virtualisation.


macro example:
{code}
scala> trait OnCreate[T] { self: T => } //def completeConstruction: Any }
defined trait OnCreate

scala> def impl[T: c.WeakTypeTag](c: BlackboxContext): c.Tree = { import c.universe._    
     |     println(typeTag[C])
     |     q"""???"""
     | }    
impl: [T](c: scala.reflect.macros.BlackboxContext)(implicit evidence$1: c.WeakTypeTag[T])c.Tree

scala> class C extends OnCreate[C] { import language.experimental.macros
     |   println("c")
     |   def completeConstruction = macro impl[C] 
     | }
defined class C

scala> (new C).completeConstruction
TypeTag[C]
scala.NotImplementedError: an implementation is missing
  at scala.Predef$.$qmark$qmark$qmark(Predef.scala:229)
  ... 32 elided

scala> (new C)
c

{code}
