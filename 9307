In Juha's excellent and tiny test case:
```
# s[Int](Vector(1)) // okay
% qbin/scalac sandbox/test.scala
isAsSpecific((x: Iterable[_ <: Int])Seq[Int], (x: Traversable[_ <: Int])Seq[Int]): true
isAsSpecific((x: Traversable[_ <: Int])Seq[Int], (x: Iterable[_ <: Int])Seq[Int]): false
isAsSpecific((x: Iterable[_ <: Int])Seq[Int], (x: Traversable[_ <: Int])Seq[Int]): true
isAsSpecific((x: Traversable[_ <: Int])Seq[Int], (x: Iterable[_ <: Int])Seq[Int]): false

# s(Vector(1)) // fail
% qbin/scalac sandbox/test.scala
isAsSpecific([T](x: Iterable[_ <: T])Seq[T], [T](x: Traversable[_ <: T])Seq[T]): false
isAsSpecific([T](x: Traversable[_ <: T])Seq[T], [T](x: Iterable[_ <: T])Seq[T]): false
isAsSpecific([T](x: Traversable[_ <: T])Seq[T], [T](x: Iterable[_ <: T])Seq[T]): false
isAsSpecific([T](x: Iterable[_ <: T])Seq[T], [T](x: Traversable[_ <: T])Seq[T]): false
isAsSpecific([T](x: Iterable[_ <: T])Seq[T], [T](x: Traversable[_ <: T])Seq[T]): false
isAsSpecific([T](x: Traversable[_ <: T])Seq[T], [T](x: Iterable[_ <: T])Seq[T]): false
isAsSpecific([T](x: Iterable[_ <: T])Seq[T], [T](x: Traversable[_ <: T])Seq[T]): false
isAsSpecific([T](x: Traversable[_ <: T])Seq[T], [T](x: Iterable[_ <: T])Seq[T]): false
isAsSpecific([T](x: Traversable[_ <: T])Seq[T], [T](x: Iterable[_ <: T])Seq[T]): false
isAsSpecific([T](x: Iterable[_ <: T])Seq[T], [T](x: Traversable[_ <: T])Seq[T]): false
isAsSpecific([T](x: Iterable[_ <: T])Seq[T], [T](x: Traversable[_ <: T])Seq[T]): false
isAsSpecific([T](x: Traversable[_ <: T])Seq[T], [T](x: Iterable[_ <: T])Seq[T]): false
sandbox/test.scala:5: error: ambiguous reference to overloaded definition,
both method s in class S of type [T](x: Iterable[_ <: T])Seq[T]
and  method s in class S of type [T](x: Traversable[_ <: T])Seq[T]
match argument types (scala.collection.immutable.Vector[Int])
```
