This is due to wildcard types reaching the backend. They are used only for type inference, and are replaced by inferred types by the analyzer. It looks like the pattern matcher generates them for bound variables. Here's the relevant tree after 'explicitOuter', patterns expanded:
{code}
    def crash(updates: List[Crash.StateUpdate[_]]): Unit = {
      <synthetic> val temp6: List[Crash.StateUpdate[_]] = updates;
      if (scala.this.Nil.==(temp6))
        ()
      else
        if (temp6.isInstanceOf[::[Crash.StateUpdate[_]]]())
          {
            <synthetic> val temp8: ::[Crash.StateUpdate[_]] = temp6.asInstanceOf[::[Crash.StateUpdate[_]]]();
            <synthetic> val temp9: Crash.StateUpdate[_] = temp8.hd$$1();
            val u: Crash.StateUpdate[?] = temp9;
            val v: ? = u.value();
            ()
          }
        else
          throw new MatchError(temp6)
    };
{code}

Notice the types of `u` and `v`. 
