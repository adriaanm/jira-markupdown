Part of the problem might stem from the fact that the method
{code}
  protected final def Value: Value = Value(nextId)     
{code}
(declared [https://lampsvn.epfl.ch/trac/scala/browser/scala/tags/R_2_8_1_final/src//library/scala/Enumeration.scala#L131 here])
is not filtered out by populateNameMap:
{code}
    val methods = getClass.getMethods filter (m => m.getParameterTypes.isEmpty && classOf[Value].isAssignableFrom(m.getReturnType))
{code}
each of those methods is afterward invoked by `populateNameMap`; the `Value` method will then be invoked, it will construct an instance of `Val`, and the `Val` constructor will reset `vsetDefined` altering the return value of values (even if its definition seems immutable, it is not).
To complete the picture, `populateNameMap` is only called indirectly through `Val.toString -> Enumeration.nameOf`.

Problems:
1) The `Val` constructor should _not_ reset `vsetDefined`, it should rather throw an exception if `vsetDefined` was true, i.e. `values` had been invoked.

2) `populateNameMap` should filter out `Value`, and a big fat warning should be added against adding new method with the same signature without fixing `populateNameMap`. Alternatively, `populateNameMap` could use `getDeclaredMethods` on the class of the actual enumeration, which filters out inherited methods.

3) Of course, this does not solve the fragility problem: if the Enumeration instance declares a method like `randomElem(): Value`, it will mistaken for an enumeration entry. As already asked, this "evil magic" should be documented.

Should I provide a patch for 1) and 2)?
