The following code runs into a deadlock, even though all monitors are acquired and released correctly. Note that the code runs as expected when using the commented class, and running the object body from a newly created instance of that class.

{code}
class Control {
  var proceed = false
  def cont(): Unit = synchronized {
    println("acquired main lock")
    proceed = true
    println("notifying main thread")
    notify()
  }
  def waitOn(): Unit = synchronized {
    while (!proceed) {
      println("suspending main thread")
      wait()
    }
  }
}

/*
class MainClass {
  def run() {
    val mainControl = new Control

    val r = new Runnable {
      def run() {
        println("running body")
        //body
        println("hello")
        println("acquiring main lock")
        mainControl.cont()
      }
    }
    val worker = new Thread(r)
    worker.start()
    mainControl.waitOn()
  }
}
*/

object threadResume2 extends Application {
  //(new MainClass).run()

  val mainControl = new Control

  val r = new Runnable {
    def run() {
      println("running body")
      //body
      println("hello")
      println("acquiring main lock")
      mainControl.cont()
    }
  }
  val worker = new Thread(r)
  worker.start()
  mainControl.waitOn()
}
{code}
