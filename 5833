Background info:


The overrides in {{ObservableBuffer}} currently do not include {{++=}}. They currently are: 

{code}
  abstract override def +=(element: A): this.type

  abstract override def +=:(element: A): this.type

  abstract override def update(n: Int, newelement: A): Unit

  abstract override def remove(n: Int): A

  abstract override def clear(): Unit
{code}

(some of these overrides are for {{BufferLike}}, others for {{Growable}}, and others for {{SeqLike}}). 

In the example, the following callsite is not "observed" 

{code}
 buf ++= ArrayBuffer(3) // fails
{code}

because the override in {{ArrayBuffer}} that gets picked is: 

{code}
  /** Appends a number of elements provided by a traversable object.
   *  The identity of the buffer is returned.
   *
   *  @param xs    the traversable object.
   *  @return      the updated buffer.
   */
  override def ++=(xs: TraversableOnce[A]): this.type = xs match {
    case v: IndexedSeq[_] =>
      val n = v.length
      ensureSize(size0 + n)
      v.copyToArray(array.asInstanceOf[scala.Array[Any]], size0, n)
      size0 += n
      this
    case _ =>
      super.++=(xs)
  }

{code}

It would be great if a patch were provided (and tests run!). Additionally, are there any other mutator methods that don't get "observed"?


