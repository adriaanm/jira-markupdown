With dependent method types we have a somewhat cumbersome, but just about usable workaround. The key idea is to use implicits to destructure a type, and then pick out and use its component parts as dependent types.
```scala
// Template we will unpack into
trait UnpackM[MA] {
  type M[_]
  type A
}
  
// Destructuring implicits
implicit def unpackM1[M0[_], A0] = new UnpackM[M0[A0]] {
  type M[X] = M0[X]
  type A = A0
}

implicit def unpackM2[M0[_, _], A0, B0] = new UnpackM[M0[A0, B0]] {
  type M[X] = M0[A0, X]
  type A = B0
}

def meh[MA](x : MA)(implicit u : UnpackM[MA]) : (u.M[String], List[u.A]) = null
//      ^^          ^^^^^^^^^^^^^^^^^^^^^^^^     ^^^^^^^^^^^       ^^^
//      (1)                   (2)                    (3)           (3)
// 1: Type variable being destructured
// 2: Destructuring implicit
// 3: Uses of (dependent) component types
  
val m = meh{(x: Int) => x}
implicitly[m.type <:< (Int => String, List[Int])]
```

See also [here](http://goo.gl/efy8F) for a slightly more elaborate scalaz inspired example.
