{code}
object test {
  class R[@specialized(Double) C]

  def g[@specialized(Double) C](x: R[C]): Unit = {
    case object S
  }
}
{code}

{noformat}
sandbox/test.scala:5: error: S is already defined as (compiler-generated) case class companion object S
    case object S
                ^
{noformat}

Here's what gets into `retyped`
{code}
<specialized> def g$mDc$sp(x: test.R[Double]): Unit = {
  case object S extends Object with Product with Serializable {
    def <init>(): S.type = {
      S.super.<init>();
      ()
    };
    override <synthetic> def productPrefix(): String = "S";
    <synthetic> def productArity(): Int = 0;
    <synthetic> def productElement(x$1: Int): Any = {
      case <synthetic> val x1: Int = x$1;
      case4(){
        matchEnd3(throw new IndexOutOfBoundsException(x$1.toString()))
      };
      matchEnd3(x: Any){
        x
      }
    };
    override <synthetic> def productIterator(): Iterator[Any] = runtime.this.ScalaRunTime.typedProductIterator[Any](S.this);
    <synthetic> def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[S.type]();
    override <synthetic> def hashCode(): Int = 83;
    override <synthetic> def toString(): String = "S";
    <synthetic> private def readResolve(): Object = S()
  };
  var S$module: S.type = _;
  case <stable> def S(): S.type = {
    S$module = new S.type();
    S$module
  };
  ()
}
{code}
