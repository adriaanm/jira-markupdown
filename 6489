Jens, I'm glad you're working on this.

I agree that suggestion #1 is strictly better than the current code.

However, of course ideally we'd have no ThreadLocal at all. (The perfect is always the enemy of the good...)

Let's try and construct a case where {{lastNoSuccessVar}} makes a difference. Consider the arithmetic expression parser in Programming in Scala, at http://booksites.artima.com/programming_in_scala_2ed/examples/html/ch33.html . It uses {{RegexParsers.parseAll}} which calls {{Parsers.phrase}}. Suppose we change the definition of {{factor}} a little to give a better error:

{noformat}
  def factor: Parser[Any] = floatingPointNumber | "("~expr~")" | failure("expected factor")
{noformat}

And then we parse "0+". With the {{lastNoSuccessVar}} logic in place, we get "expected factor". Without it we just get "end of input expected". (Yup, I ran it both ways to be sure.)

So then the question is, which error is better? There are two ways of viewing the input. One is that it consists of good input (0) followed by some garbage (+), thus, "end of input expected". The other is that all the input is good but it is merely incomplete, thus, "expected number".

The {{filterNot}} call in {{Parser.phrase}} is there so that the choice that consumed more input is taken. And, sorry to say, I think that makes perfect sense. If you agree, then I think we need to address this without altering the behavior.
