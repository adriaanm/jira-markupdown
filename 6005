In case there was any doubt, here is a test case which demonstrates that is indeed what happened.
{code}
object Test {  
  def it = {
    Thread.sleep(1000)
    (1 to 3).iterator
  }
  
  def timed[T](label: String)(body: => T): T = {
    val start   = System.currentTimeMillis
    val result  = body
    val end     = System.currentTimeMillis
    val elapsed = (end - start).toDouble / 1000

    println(label + ": " + elapsed + " seconds elapsed.")
    result
  } 
  
  def g1: Iterator[Int] = timed("create g1")(List(it, it, it, it, it).foldLeft(Iterator.empty: Iterator[Int])(_ ++ _))
  def g2: Iterator[Int] = timed("create g2")(Iterator.empty ++ it ++ it ++ it ++ it ++ it)
  
  def main(args: Array[String]): Unit = {
    val it1 = g1
    timed("run g1")(println(it1 mkString " "))
    
    val it2 = g2
    timed("run g2")(println(it2 mkString " "))
  }
}
{code}
This prints:
{code}
create g1: 5.012 seconds elapsed.
1 2 3 1 2 3 1 2 3 1 2 3 1 2 3
run g1: 0.0 seconds elapsed.
create g2: 0.0030 seconds elapsed.
1 2 3 1 2 3 1 2 3 1 2 3 1 2 3
run g2: 5.002 seconds elapsed.
{code}
