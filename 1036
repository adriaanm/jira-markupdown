I think documenting it is the wrong solution, it's an issue that needs resolving.

An easy (though potentially naive) fix would be to return an iterator from {{takeWhile}} that simply returned the last taken element (the first that doesn't match the predicate) as the first element in the new iterator (the first call to {{hasNext}} or {{next}}).

Here's a quick and dirty hack that shows this (doubt this actually works):

{code}
new Iterator[A] {
  val first = lastTakenThatDoesNotMatch
  val wrapped = wrappedIterator
  var taken = false

  override def hasNext = !taken || wrapped.hasNext

  override def next = 
    if (!taken) {
      taken = true
      first
    } else {
      wrapped.next
    }
}
{code}
