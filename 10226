Although, after further thought, it also seems to me that you could simulate this memoization behaviour easily:

{code}
import collection._

class Cache[K, V] {
  class LazyCell(compute: =>V) {
    lazy val value = compute
  }
  private val tm = concurrent.TrieMap[K, LazyCell]()
  def getOrElseUpdate(k: K, fresh: =>V): V = {
    val proposedCell = new LazyCell(fresh)
    val existingCellOpt = tm.putIfAbsent(k, proposedCell)
    if (existingCellOpt.nonEmpty) existingCellOpt.get.value
    else proposedCell.value
  }
}

object Main {
  def main(args: Array[String]) {
    val cache = new Cache[String, String]
    val v1 = cache.getOrElseUpdate("key1", { println("val1"); "val1" })
    val v1p = cache.getOrElseUpdate("key1", { println("val1 generation again"); "val1" })
    val v2 = cache.getOrElseUpdate("key2", { println("val2"); "val2" })
  }
}
{code}

Note that there's no way of avoiding the thunk creation above, and we're already in object-creation-land, so an additional `LazyCell` object should not be a huge issue. If it is, you could avoid creating it in most cases by first checking via `get` if there's an entry in the map already.

This means that any concurrent map that supports `putIfAbsent` can be wrapped to support `getOrElseUpdate`. This makes me more convinced that we should remove `getOrElse` from the `ConcurrentMap` interface.
