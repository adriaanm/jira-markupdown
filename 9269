Who would have thought that this could go wrong? https://github.com/scala/scala/commit/86397c9
```scala
// typedCompoundTypeTree
newTyper(context.make(templ, self.typeSymbol, decls)).typedRefinement(templ)
```
```scala
    def typedRefinement(templ: Template) {
      val stats = templ.body
      namer.enterSyms(stats)

      // need to delay rest of typedRefinement to avoid cyclic reference errors
      unit.toCheck += { () =>
        val stats1 = typedStats(stats, NoSymbol)
        // this code kicks in only after typer, so `stats` will never be filled in time
        // as a result, most of compound type trees with non-empty stats will fail to reify
        // todo. investigate whether something can be done about this
        val att = templ.attachments.get[CompoundTypeTreeOriginalAttachment].getOrElse(CompoundTypeTreeOriginalAttachment(Nil, Nil))
        templ.removeAttachment[CompoundTypeTreeOriginalAttachment]
        templ updateAttachment att.copy(stats = stats1)
        for (stat <- stats1 if stat.isDef) {
          val member = stat.symbol
          if (!(context.owner.ancestors forall
                (bc => member.matchingSymbol(bc, context.owner.thisType) == NoSymbol))) {
                  member setFlag OVERRIDE
                }
        }
      }
    }
```

The lowest friction solution for this would be to make `CompoundTypeTreeOriginalAttachment` mutable. We could then attach it to `templ` immediately. The deferred code would operate on that attachment, which would have been passed to the copy of tree.

15% less hacky, we could avoid registering this with `unit.toCheck`, and instead have a standard `ToCheck(() => Unit)` attachment. At the end of each typing a compilation unit, we would traverse the final tree and execute these blocks of code.

Or find some other way to break the cycles.
