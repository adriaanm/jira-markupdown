Replying to [comment:5 aarti_pl]:
> Well, argumentation in SI-399 seems to me very unconvincing. As far as I know compiler should do flow analysis and just issue an error when variable is used before declaration.

Here, this is an excerpt from the most recent of the dozens of mailing list threads on the subject (in which I was asking someone else not to open this same ticket, because closing the same tickets over and over is not how things improve.)  Nothing is going to change here without an extremely well thought out proposal which encompasses mixin order, inheritance, abstract members, early defs, and all the many other complications.

{code}
> > It seems I missed the point of your original post -- the forward            
> > reference doesn't work in either case.  In this case, I'd say this          
> > should be a compile error (forward references make no sense and should      
> > therefore be illegal).  If you must have a forward reference, you can       
> > define `j` as a method.
This is not true.  Not that I design a lot of classes like this, but:
  
trait NotWeird {
  val a: Int = b + 1
  val b: Int = a + 1
}                                                                               
  
object OK extends { override val a = 5 } with NotWeird
object AOK extends { override val b = 5 } with NotWeird

object Test {
  def main(args: Array[String]): Unit = {
    println(List(OK.a, OK.b, AOK.a, AOK.b) mkString " ")
  }                                                                             
}                                                                               
// prints: 5 6 6 5

A "forward reference" may or may not be a forward reference.  We have
inheritance and overriding here.
{code}
