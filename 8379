There is an added twist to this when pairing @static with App:

{code}
rk:test rkuhn$ cat static.scala 
import annotation.static

object Static extends App {
  val i = 1
  @static val si1 = { println("si1"); i }
  println("si1=" + si1)
}
rk:test rkuhn$ scalac static.scala 
rk:test rkuhn$ scala Static
si1
si1=0
{code}

The thing here is that there is no way to get it “right” in this case, because the initialization code of the “final” (only not in bytecode) “val i” runs outside of the context of class initialization. Given that it cannot work, this must be a compile time error.
