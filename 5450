With the universes and path-dependence running around in reflection, I think this has become a significantly larger problem.  I ran into it immediately:
{code}
object Test {
  implicit class Ops(val g: scala.reflect.api.JavaUniverse) {
    def op[T: g.TypeTag] = ()
  }
  
  scala.reflect.runtime.universe.op[Int]
}
{code}
{noformat}

// uncaught exception during compilation: java.lang.AssertionError
// error: java.lang.AssertionError: assertion failed: mkAttributedQualifier(_1.type, <none>)//
//
// at scala.Predef$.assert(Predef.scala:162)
// at scala.reflect.internal.TreeGen.mkAttributedQualifier(TreeGen.scala:87)
// at scala.reflect.internal.TreeGen.mkAttributedQualifier(TreeGen.scala:60)
// at scala.reflect.internal.TreeGen.mkAttributedRef(TreeGen.scala:120)
// at scala.tools.nsc.typechecker.Implicits$ImplicitSearch.tagOfType(Implicits.scala:1176)
// at scala.tools.nsc.typechecker.Implicits$ImplicitSearch.implicitTagOrOfExpectedType(Implicits.scala:1339)
// at scala.tools.nsc.typechecker.Implicits$ImplicitSearch.bestImplicit(Implicits.scala:1373)
{noformat}
