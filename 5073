Replying to [comment:6 soc]:
> But the (bogus?) message about the conversions to floating point numbers:
> {code}
> Note that implicit conversions are not applicable because they are ambiguous:
>  both method int2float in object Predef of type (x: Int)Float
>  and method int2double in object Predef of type (x: Int)Double
> [...]
> }}
> 
> I just felt a bit uneasy that the compiler even considered something with flaoting points when only doing integer math...

It's confusing for sure, but it's accurate as far as the compiler knows, and it's in the zone of difficult change.  The error is encountered when it is still trying to type the + expression.  Naturally it's going to go look for implicit conversions before it gives up, and there are conversions called int2double and int2long in Predef, and they are ambiguous in the narrow context of the expression it is typing.

Now were those implicits unambiguous, it would only kick the error further downfield a little ways, so you don't need to worry it's randomly resorting to FP math when it gets confused.  Compare these outcomes.
{code}
scala> (1 + 2L): Int 
<console>:6: error: type mismatch;
 found   : Int(1)
 required: ?{val +(x$$1: ?>: Long(2L) <: Any): ?}
Note that implicit conversions are not applicable because they are ambiguous:
 both method int2double in object Predef of type (x: Int)Double
 and method int2float in object Predef of type (x: Int)Float
 are possible conversion functions from Int(1) to ?{val +(x$$1: ?>: Long(2L) <: Any): ?}
       (1 + 2L): Int
        ^

scala> (1d + 2L): Int 
<console>:6: error: type mismatch;
 found   : Double(3.0)
 required: Int
       (1d + 2L): Int
           ^

{code}
