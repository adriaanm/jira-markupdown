Hi folks,

Since some time in the 2.8.0 branch, the interpreter started using ScalaRunTime.stringOf to show string values instead of calling objects' toString methods.  It seems the motivation here is for stringOf to construct a python-repr-like string for an object at runtime, a noble goal.

Unfortunately, the current implementation of ScalaRunTime.stringOf falls short for custom collections.  An elaborate instance check is performed to determine how to construct the string with several special cases that apply only to built in collections, with no hooks for external collections that extend Traversable to provide an alternative.  The code block in question from the current head branch is attached, below, for reference.

More specifically, custom Traversable instances with definite size that are not part of scala.tools.nsc.io cannot provide a custom string.  This interacts poorly with the interpreter for, e.g., all the numerical collections in scalala http://github.com/scalala/Scalala, for which appropriate toString methods exists.  The custom toString methods on those collections are concise and readable, but the stringOf version are often useless and/or slow.  The result is that the interpreter moves from being a useful matlab-like environment to something far less useful for many real interactions.

It seems like there are a few choices here:

1) Make toString behave correctly for all scala data types, so that stringOf just does the check for isArray (because java arrays' toStrings cannot be changed), but otherwise delegates to x.toString.

2) If there really were a use case for having stringOf and toString look different, instead define a HasStringRepr trait that defines a .toStringRepr method.  Let Traversable extends this.  Then stringOf can defer to x.toStringRepr if the class implements HasStringRepr, or x.toString otherwise unless it isArray.

3) Use a HasStringRepr view class, i.e. `def stringOf[A:HasStringRepr](arg : A)`.  This options seems the most flexible, as it will allow a custom string repr for Arrays, but requires more complexity in the Interpreter loop, because it can't easily be done by reflection.

1 and 2 seem easy enough work-arounds for the near term.  I think 3 is the way to go, but there is some complexity to it.  I've worked out the details for doing this more generally here: http://github.com/scalanlp/scalanlp-core/blob/master/data/src/main/scala/scalanlp/serialization/TextSerialization.scala
```scala
(scala.runtime.ScalaRuntime)
237	  def stringOf(arg: Any): String = {
238	    import collection.{SortedSet, SortedMap}
239	    def mapTraversable(x: Traversable[_], f: Any => String) = x match {
240	      case ss: SortedSet[_] => ss.map(f)
241	      case ss: SortedMap[_, _] => ss.map(f)
242	      case _ => x.map(f)
243	    }
244	    def inner(arg: Any): String = arg match {
245	      case null                     => "null"
246	      // Node extends NodeSeq extends Seq[Node] strikes again
247	      case x: Node                  => x toString
248	      // Not to mention MetaData extends Iterable[MetaData]
249	      case x: MetaData              => x toString
250	      // Range/NumericRange have a custom toString to avoid walking a gazillion elements
251	      case x: Range                 => x toString
252	      case x: NumericRange[_]       => x toString
253	      case x: AnyRef if isArray(x)  => WrappedArray make x map inner mkString ("Array(", ", ", ")")
254	      case x: TraversableView[_, _] => x.toString
255	      case x: Traversable[_] if !x.hasDefiniteSize => x.toString
256	      case x: Traversable[_]        => 
257	        // Some subclasses of AbstractFile implement Iterable, then throw an
258	        // exception if you call iterator.  What a world.
259	        // And they can't be infinite either.
260	        if (x.getClass.getName startsWith "scala.tools.nsc.io") x.toString
261	        else (mapTraversable(x, inner)) mkString (x.stringPrefix + "(", ", ", ")")
262	      case x                        => x toString
263	    }
264	    val s = inner(arg)
265	    val nl = if (s contains "\n") "\n" else ""
266	    nl + s + "\n"   
267	  }
268	}
```
