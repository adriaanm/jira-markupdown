The `take` and `drop` methods of iterators of type `IndexedSeqLike#Elements` to not advance the iterators and also ignore the iterators current state. `IndexedSeqLike#Elements` it used by IndexedSeq.iterator and others. 

REPL Transscript (with current nightly build):
```scala
Welcome to Scala version 2.8.0.r21946-b20100517020056 (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_20).

scala> val it = (1 to 12).toSeq.iterator 
it: Iterator[Int] = non-empty iterator

scala> it.next
res0: Int = 1

scala> it.take(2).toList
res1: List[Int] = List(1, 2)

scala> it.takeWhile(_ < 6).toList
res2: List[Int] = List(2, 3, 4, 5)

scala> it.next
res3: Int = 7

scala> val d = it.drop(2)
d: Iterator[Int] = non-empty iterator

scala> d == it
res4: Boolean = false

scala> it.next
res5: Int = 8

scala> it.take(2).toList
res6: List[Int] = List(1, 2)
```


Whereas with other iterators (e.g. List.iterator):
```scala
scala> val it = (1 to 12).toList.iterator
it: Iterator[Int] = non-empty iterator

scala> it.next
res0: Int = 1

scala> it.take(2).toList
res1: List[Int] = List(2, 3)

scala> it.takeWhile(_ < 6).toList
res2: List[Int] = List(4, 5)

scala> it.next
res3: Int = 7

scala> val d = it.drop(2)
d: Iterator[Int] = non-empty iterator

scala> d == it
res4: Boolean = true

scala> it.next
res5: Int = 10

scala> it.take(2).toList
res6: List[Int] = List(11, 12)
```

With `Map` the behaviour of Map.iterator depends on the size of the Map, since Map uses different implementations for different sizes, for small Maps IndexedSeqLike#Elements is used.


Cause:

The implementation of IndexedSeqLike#Elements looks like this:
```scala
  protected class Elements(start: Int, end: Int) extends BufferedIterator[A] {
    private var i = start

    def hasNext: Boolean = i < end

    def next: A = 
      if (i < end) {
        val x = self(i)
        i += 1
        x
      } else Iterator.empty.next

    [...]

    override def drop(n: Int): Iterator[A] =
      if (n > 0) new Elements(start + n, end) else this

    override def take(n: Int): Iterator[A] =
      if (n <= 0) Iterator.empty.buffered
      else if (start + n < end) new Elements(start, start + n) 
      else this
  }
```

So while `hasNext` and `next` use `var i`, the optimized versions of `drop` and `take` use `start` instead, ignoring and not advancing the current state.

I believe we should have something like
```scala
    override def drop(n: Int): Iterator[A] = {
      if (n > 0) i = math.min(i + n, end)
      this
    }
 
    override def take(n: Int): Iterator[A] = {
      if ((n <= 0) || !hasNext) Iterator.empty.buffered
      else {
        val from = i
        i = math.min(i + n, end)
        new Elements(from, i)
      }
    }
```

in there.
