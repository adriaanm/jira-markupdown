The optimizer can't optimize code that doesn't typecheck, the JVM can't run code that doesn't typecheck, for example the ICode below 

(the "{{CALL_METHOD scala.Unit.getClass}}" expects an Object on the stack but finds nothing (the Predef module instance is there to be consumed by the forthcoming `Predef.println` invocation) 
```
  def main(args: Array[String] (ARRAY[REF(class String)])): Unit {
  locals: value args
  startBlock: 1
  blocks: [1]
  
  1: 
    5	LOAD_MODULE object Predef
    5	CALL_METHOD scala.Unit.getClass (dynamic)
    5	CALL_METHOD scala.Predef.println (dynamic)
    5	RETURN(UNIT)
    
  }
```

How does that code find its way till GenICode? Like so:

After superaccessors:
```
[[syntax trees at end of superaccessors]]// Scala source: bt4.scala
package <empty> {
  object Test extends scala.AnyRef {
    def <init>(): Test.type = {
      Test.super.<init>();
      ()
    };
    final private[this] val UNIT: Unit = ().asInstanceOf[Unit];
    final <stable> <accessor> def UNIT: Unit = Test.this.UNIT;
    def main(args: Array[String]): Unit = scala.this.Predef.println(Test.this.UNIT.getClass())
  }
}
```

After erasure:
```
[[syntax trees at end of erasure]]// Scala source: bt4.scala
package <empty> {
  object Test extends Object {
    def <init>(): ... = {
      Test.super.<init>();
      ()
    };
    final private[this] val UNIT: Object = scala.runtime.BoxedUnit.UNIT.$asInstanceOf[Object]();
    final <stable> <accessor> def UNIT(): Object = Test.this.UNIT;
    def main(args: Array[String]): Unit = scala.this.Predef.println(().getClass())
  }
}
```

