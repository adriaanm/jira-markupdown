That dealias method seems like nothing but trouble to me.  Chasing from one symbol to another and disregarding the info completely means you better not be using the result for much.  For instance in this case you end up with Array's type constructor instead of Array[Int] if you call ai.dealias.

Here are some things about type aliases.
```scala

scala> class Foo { type AI = Array[Int] }
defined class Foo

scala> val ai = typeMember(intp.types("Foo"), "AI")
ai: $r.intp.global.Symbol = type AI

scala> ai.info
res0: $r.intp.global.Type = Array[Int]

scala> ai.tpe
res1: $r.intp.global.Type = Foo.this.AI

scala> ai.tpe.typeSymbol
res2: $r.intp.global.Symbol = class Array

scala> ai.tpe.typeSymbolDirect
res3: $r.intp.global.Symbol = type AI

scala> ai.info.typeSymbol
res4: $r.intp.global.Symbol = class Array

scala> ai.info.typeSymbolDirect
res5: $r.intp.global.Symbol = class Array

scala> ai.dealias
res7: $r.intp.global.Symbol = class Array

scala> ai.typeParams
res8: List[$r.intp.global.Symbol] = List()

scala> res7.typeParams
res9: List[$r.intp.global.Symbol] = List(type T)
```
