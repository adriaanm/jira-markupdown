We generate wrong method signarues for AnyRef specialization. Let me give you the following example:
{code}
package foo
import scala.runtime.BoxedUnit

trait CustomFunction1[@specialized(scala.Int) T1, @specialized(scala.AnyRef) R] extends AnyRef {
  def apply(v1: T1): R
}
class UnitFunctionBridge[T] extends CustomFunction1[T, BoxedUnit] {
  override final def apply(t: T): BoxedUnit = BoxedUnit.UNIT
}
{code}

Let's see what -Xprint:cleanup gives us:
{code}
package foo {
  abstract trait CustomFunction1 extends Object {
    def apply(v1: Object): Object;
    <specialized> def apply$mcLI$sp(v1: Int): Object
  };
  class UnitFunctionBridge extends Object with foo.CustomFunction1 {
    <specialized> def apply$mcLI$sp(v1: Int): Object = foo.CustomFunction1$class.apply$mcLI$sp(UnitFunctionBridge.this, v1);
    final override def apply(t: Object): scala.runtime.BoxedUnit = scala.runtime.BoxedUnit.UNIT;
    final override <bridge> def apply(v1: Object): Object = UnitFunctionBridge.this.apply(v1);
    def <init>(): foo.UnitFunctionBridge = {
      UnitFunctionBridge.super.<init>();
      foo.CustomFunction1$class./*CustomFunction1$class*/$init$(UnitFunctionBridge.this);
      ()
    }
  };
  abstract <specialized> trait CustomFunction1$mcLI$sp extends Object with foo.CustomFunction1 {
    <specialized> def apply(v1: Int): Object
  };
  abstract trait CustomFunction1$class extends  {
    <specialized> def apply$mcLI$sp($this: foo.CustomFunction1, v1: Int): Object = $this.apply(scala.Int.box(v1));
    def /*CustomFunction1$class*/$init$($this: foo.CustomFunction1): Unit = {
      ()
    }
  };
  abstract <specialized> trait CustomFunction1$mcLI$sp$class extends  {
    def /*CustomFunction1$mcLI$sp$class*/$init$($this: foo.CustomFunction1$mcLI$sp): Unit = {
      ()
    }
  }
}
{code}

The relevant part is (from UnitFunctionBridge:
{{<specialized> def apply$mcLI$sp(v1: Int): Object = foo.CustomFunction1$class.apply$mcLI$sp(UnitFunctionBridge.this, v1);}}

The return type here is wrong. It should be BoxedUnit because we implement generic, specialized interface of CustomFuction1[T1, R] and we substitute R with BoxedUnit.

This matters because the class shown above cannot be instantiated from Java:
{code}
public class Test {
  public void newForeach() {
    new foo.UnitFunctionBridge<String>() {};
  }
}
{code}

if you try to compile you'll get:
{code}
apply$mcLI$sp(int) in foo.UnitFunctionBridge cannot implement apply$mcLI$sp(int) in foo.CustomFunction1; attempting to use incompatible return type
found   : java.lang.Object
required: scala.runtime.BoxedUnit
    new foo.UnitFunctionBridge<String>() {};
{code}
