Here are the corresponding definitions:

{code}
type Symbol >: Null <: SymbolApi

type TermSymbol >: Null <: Symbol with TermSymbolApi
trait TermSymbolApi extends SymbolApi { this: TermSymbol => ... }
{code}

If one thinks about it, it's clear why TermSymbol erases to SymbolApi. Symbol is the first component of a compound type, and it erases to SymbolApi. 

I'll change TermSymbol to say <: TermSymbolApi with Symbol, but in the meanwhile we could think why not scan other components of compound types looking for a base class that refines the erasure of the first component.
