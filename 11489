I have a problem with name-based pattern matching actually still generating tuples.
given such definitions
```scala
type If
implicit val IfTag: ClassTag[If]
trait DeconstructorCommon[T >: Null <: Tree] {
    var field: T = null
    def get: this.type = this
    def isEmpty: Boolean = field eq null
    def isDefined = !isEmpty
    def unapply(s: T): this.type ={
      field = s
      this
    }
  }
trait IfDeconstructor extends DeconstructorCommon[If]{
    def _1: Tree
    def _2: Tree
    def _3: Tree
  }
```
the pattern 
{code} val If(condp, thenp, elsep) = tree{code}
gets compiled into bytecode equivalent to
```scala
            Tuple3 tuple3;
            Object object = tree;
            Option option = this.scala$tools$nsc$backend$jvm$BCodeBodyBuilder$PlainBodyBuilder$$$outer().int().IfTag().unapply(object);
            if (option.isEmpty()) throw new MatchError(object);
            Object object2 = option.get();
            BackendInterface.IfDeconstructor ifDeconstructor = (BackendInterface.IfDeconstructor)this.scala$tools$nsc$backend$jvm$BCodeBodyBuilder$PlainBodyBuilder$$$outer().int().If().unapply(object2);
            if (ifDeconstructor.isEmpty()) {
                throw new MatchError(object);
            }
            Object condp = ((BackendInterface.IfDeconstructor)ifDeconstructor.get())._1();
            Object thenp = ((BackendInterface.IfDeconstructor)ifDeconstructor.get())._2();
            Object elsep = ((BackendInterface.IfDeconstructor)ifDeconstructor.get())._3();
            Tuple3 tuple32 = tuple3 = new Tuple3(condp, thenp, elsep);
            Object condp2 = tuple32._1();
            Object thenp2 = tuple32._2();
            Object elsep2 = tuple32._3();
```

ie tuples Options are not created indeed, but tuples are
