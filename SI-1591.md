It is possible to create several instances of the same inner object in a multithreaded context which may cause inconsistent singleton access. 

This is best illustrated on the sample below.

--- Scala ---


{code}
abstract class MyType

class InnerObjectTest {
  object unique extends MyType
}

{code}

--- javap -private -c -l ---


{code}
private InnerObjectTest$$unique$$ unique$$module;
...
public final InnerObjectTest$$unique$$ unique();
  Code:
   0:   aload_0
   1:   getfield        SI-18; //Field unique$$module:LInnerObjectTest$$unique$$;
   4:   ifnonnull       19
   7:   aload_0
   8:   new     SI-20; //class InnerObjectTest$$unique$$
   11:  dup
   12:  aload_0
   13:  invokespecial   SI-23; //Method InnerObjectTest$$unique$$."<init>":(LInnerObjectTest;)V
   16:  putfield        SI-18; //Field unique$$module:LInnerObjectTest$$unique$$;
   19:  aload_0
   20:  getfield        SI-18; //Field unique$$module:LInnerObjectTest$$unique$$;
   23:  areturn
 


{code}

If you look at the bytecode generated by the compiler, the unique() method initializes a private field named "unique$$module" to a reference to a new instance of type "!InnerObjectTest$$unique$$" but there is no synchronization - if several threads access the 'unique()' method concurrently, there is a small chance that they get different objects.

Object access/initialization code should be the same as lazy val access/initialization code
(In r23059) Closes SI-1591. Treat nested objects as lazy vals. Updated some tests. Review by dragos
Reverted, because it is causing SI-3879.
Looking at the byte code generated by Scala 2.8.1.final, it seems that this bug has not been fixed or reoccurred after the above commit.
Inner objects in 2.8.1.final are NOT singletons in multi-threaded environments.

2.9.0-1 looks ok.
