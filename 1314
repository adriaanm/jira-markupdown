Refinement: looks like another solution to this is just to avoid the anonymous type:

{code}
class Syntax[A](tail: =>Stream[A]) {
def ::(hd: A) = Stream.cons(hd, tail)
}

implicit def convertStream[A](str: =>Stream[A]) = new Syntax(str)

val nats: Stream[Int] = 0 :: nats.map(_ + 1)
{code}

The above works fine, while the original (using an anonymous inner-class) does not.
