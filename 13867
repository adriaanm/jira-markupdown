The type inferencer get's confused when using getOrElse instead of match.

The following code works:

{code}
abstract case class Base()
class BaseA() extends Base()
class BaseB() extends Base()

class BaseHolder[T]

case class BaseCompare[I <: Base]( val base: BaseHolder[I] )

class testClass {
  val baseList = List[BaseCompare[_ <: Base ]]()

  def getHolding[I <: Base]( diff:BaseCompare[I] ) : BaseCompare[I] = {
    val holder:BaseCompare[I] = baseList.find(_.base == diff.base) match {
      case Some(base) => base
      case None => throw new IllegalStateException("Expected data not found")
    }
    holder
  }
}
{code}

Where this gives an error:

{code}
abstract case class Base()
class BaseA() extends Base()
class BaseB() extends Base()

class BaseHolder[T]

case class BaseCompare[I <: Base]( val base: BaseHolder[I] )

class testClass {
  val baseList = List[BaseCompare[_ <: Base ]]()

  def getHolding[I <: Base]( diff:BaseCompare[I] ) : BaseCompare[I] = {
    val holder:BaseCompare[I] = baseList.find(_.base == diff.base) getOrElse(
      throw new IllegalStateException("Expected data not found")
    )
    holder
  }
}
{code}

This results in

{code}
type mismatch;
 found   : test.BaseCompare[_$$1] where type _$$1 <: test.Base
 required: test.BaseCompare[I]
{code}
