When using the `to` method to generate a Double Range, the result was is not the same as Range.Double.
```scala
scala> val possibleValues1 = Range.Double.inclusive(5.0,10.0,5.0/3.0)
possibleValues1: scala.collection.immutable.NumericRange[Double] = NumericRange(5.0, 6.666666666666667, 8.333333333333334)

scala> val possibleValues2 = 5.0 to (10.0,5.0/3.0)
possibleValues2: scala.collection.immutable.NumericRange.Inclusive[Double] = NumericRange(5.0, 6.666666666666667, 8.333333333333334, 10.0)

scala> possibleValues2.toArray
res0: Array[Double] = Array(5.0, 6.666666666666667, 8.333333333333334, 10.0)
```

I have noticed that `Range.Double` internally generates a Range using `Range.BigDecimal` and then converting it to Double ([code|https://github.com/scala/scala/blob/2.12.x/src/library/scala/collection/immutable/Range.scala#L481]) whereas `FractionalProxy.to` creates a NumericRange of Type Double,
```scala
  def to(end: T): ResultWithoutStep  = new Range.Partial(NumericRange.inclusive(self, end, _))
```

Which of the two is correct or expected behavior?



