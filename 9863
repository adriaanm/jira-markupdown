If you have mixed Java/Scala sources, scalac has to parse and typecheck everything other than method/field RHSs. The error isn't coming from an "extra check", its just coming from a flawed attempt to reuse Scala's typechecker for Java sources which have slightly different semantics.

In general, if the Java source can be separately compiled, scalac should also be able to jointly compile it.

We've got this code in Typers which looks like it ought to apply to this case. We'll have to investigate why it doesn't.

{code}
        if (!reallyExists(sym)) {
          def handleMissing: Tree = {
            def errorTree = missingSelectErrorTree(tree, qual, name)
            def asTypeSelection = (
              if (context.unit.isJava && name.isTypeName) {
                // SI-3120 Java uses the same syntax, A.B, to express selection from the
                // value A and from the type A. We have to try both.
                atPos(tree.pos)(gen.convertToSelectFromType(qual, name)) match {
                  case EmptyTree => None
                  case tree1     => Some(typed1(tree1, mode, pt))
                }
              }
              else None
            )
{code}
