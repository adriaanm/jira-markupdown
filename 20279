Here is a snippet to illustrate the problem:
```scala
class Foo[A] {
  def compose(a: Foo[A]): Foo[A] = new Foo[A]
  def compose(b: Bar[A]): Bar[A] = new Bar[A]

  // non overloaded method
  def composeBar(b: Bar[A]): Bar[A] = new Bar[A]
}

class Bar[A] {
  def compose(a: Foo[A]): Bar[A] = new Bar[A]
  def compose(b: Bar[A]): Bar[A] = new Bar[A]
}

object Test {
  val fooS = new Foo[String]
  val barS = new Bar[String]
  def barA[A] = new Bar[A]

  // foos and bars compose together
  fooS compose fooS
  barS compose barS
  fooS compose barS
  barS compose fooS

  // here it fails with the following error
  // error: overloaded method value compose with alternatives:
  // (b: Bar[String])Bar[String] <and>
  // (a: Foo[String])Foo[String]
  // cannot be applied to (Bar[Nothing])
  fooS compose barA
  
  // but it works if you add a type annotation or a non overloaded method
  fooS compose barA[String]
  fooS composeBar barA
}
```

This issue is particularly important for monocle because all optics (Iso, Lens, Prism, ...) compose together which means we need to define 8 different compose methods instead of a single method overloaded 8 times.
