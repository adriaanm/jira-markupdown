The compiler rejects code which should be perfectly valid. Using type ascription to upcast the value is a workaround for this.

{code}
sealed trait Key
case object SilverKey extends Key
case object GoldKey extends Key

trait KeyHole {
  type K <: Key
}

trait Door {
  val h: KeyHole
  type K = Key with h.K
  val key: K
}

// pattern type is incompatible with expected type
def bad(door: Door): Unit = {
  door.key match {
    case SilverKey =>
    case GoldKey =>
  }
}

// compiles fine
def good(door: Door): Unit = {
  (door.key: Key) match {
    case SilverKey =>
    case GoldKey =>
  }
}
{code}
