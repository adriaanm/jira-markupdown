{code}
rk:test rkuhn$ cat static.scala 
import annotation.static

object Static {

  val i1 = { println("i1"); 1 }
  val l1 = { println("l1"); 1l }
  @static val si1 = { println("si1"); i1 }
  @static val sl1 = { println("sl1"); l1 }
  println("sl1=" + sl1)

  def main(args: Array[String]) {}
}
rk:test rkuhn$ scalac static.scala 
rk:test rkuhn$ scala Static
si1
i1
l1
sl1=0
sl1
{code}

What this means is that saying “static fields are initialized first” can easily be subverted, and the fact is not blatantly visible in the code. It is one of those things where you need to read the whole class to find out in which order things will run.

Given how the two kinds of initialization code live in the same lexical space, it would be much better if initialization would also proceed linearly, following the lexical structure. One possibility to do this would be to have the static initializer block run the whole thing and compute the values to be put into all fields of the MODULE instance, and then these values are passed in as constructor arguments. The down-side would be that “this” is not available. I’d rather have this restriction (and require a @static annotation on the object itself) than erratic initialization order changes (which might not even be known at compile time). Semantics of a missing @static annotation on the object could then be to run the whole initialization within the MODULE constructor, giving you “this” but taking away finality of static fields.
