Minimized.
{code}
(for (x <- (1 to 10)) yield { if (x % 2 == 0) Nil.seq else Nil.par }).flatten
{code}
There seems to be something more serious here, because it is looking for an implicit view from an inferred refinement type, which seems expensive.

1) Inferred type of the for comprehension is GenSeq { long list of decls }
2) The call to flatten requires an implicit A => TraversableOnce[B]
3) The inferred type from 1) enters implicit search as the "A" without any further processing.

Shouldn't the refinements be stripped, or at least pruned?
