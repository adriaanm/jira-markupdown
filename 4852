Paul,

Many thanks for clarifying that Scala was indeed doing something different to what I thought and for have the generosity to leave this open for a little longer!

I do think this is an unnecessary ambiguity and potentially very hard to track down as a bug.

Currently if you define a function with a by name parameter you can't omit it when you call it:
```scala
scala> def test(f: => Unit) { f }
test: (f: => Unit)Unit

scala> test
<console>:7: error: missing arguments for method test in object $$iw;
follow this method with `_' if you want to treat it as a partially applied function
       test
       ^
```

Also, you cannot omit the arguments for a class declaration/constructor except in the case we are talking about (which I think is an exception to the rules):
```scala
scala> class Test(f: => Unit) { f }
defined class Test

scala> new Test
res17: Test = Test@68e415b8
```

â€¦and the case of default parameters:
```scala
scala> class Test(x: Int = 1) { println(x) }
defined class Test

scala> new Test
1
res19: Test = Test@57cd6a32
```

I would have thought that we would provide a safer and more consistent experience if the omission of a non default parameter always resulted in an error message.  If developers wanted to be able to instantiate a class with an optional (by name) function parameter, they could provide a default.  They can as always pass a null entry by providing empty brackets.  e.g.:
```scala
// Providing a default function if use may require no parameter to be supplied...
scala> class Test(f: => Unit = () => Unit) { f }
defined class Test

// Pass an empty parameter where no default is supplied...
scala> new Test()
res21: Test = Test@4a5d484a
```
