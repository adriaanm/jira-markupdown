I think this might be related to some of the issues uncovered in SI-5488.

The basic gist is that while AnyRef specialization is working for simple type combinations (e.g. @specialized(Int, AnyRef) it seems to be breaking for "full specialization". Here's the code:

{code}
import scala.{specialized => spec}

// specialized on Int/AnyRef only
class C1[@spec(Int, AnyRef) A, @spec(Int, AnyRef) B](v:A, w:B)

// specialized on everything
class C2[@spec(Unit, Boolean, Byte, Char, Short, Int, Long, Float, Double, AnyRef) A, @spec(Unit, Boolean, Byte, Char, Short, Int, Long, Float, Double, AnyRef) B](v:A, w:B)

// specialized on everything except AnyRef
class C3[@spec(Unit, Boolean, Byte, Char, Short, Int, Long, Float, Double) A, @spec(Unit, Boolean, Byte, Char, Short, Int, Long, Float, Double) B](v:A, w:B)

object Test {
  def main(args:Array[String]) {
    // as expected, this specializes properly to C1$mcLI$sp
    println(new C1("abc", 123).getClass.getName)

    // this tries to use C2$mcLI$sp but fails to compile due to a bug
    println(new C2("abc", 123).getClass.getName)
    //test.scala:18: error: type mismatch;
    // found   : String("abc")
    // required: A$sp
    //    println(new C3("abc", 123).getClass.getName) // explodes
    //            ^
    //one error found

    // as expected, this uses the generic C3
    println(new C3("abc", 123).getClass.getName)
  }
}
{code}

Commenting out the second println allows the whole thing to compile and run as expected.

This error crops up when substituting C2$mcLI$sp for C2 in the tree, and the typing the new tree. I'm not sure why it works for C1 but not for C2. The trees look the same, at least as far as I can tell (e.g. using log output). Probably I need to figure out how to hook up a debugger and take a closer look.
