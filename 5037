I was going to say this is fixed in trunk, because it no longer crashes the repl.  But while creating a test case to guard it I found it still crashes scalac.
{code}
class Lift[T] {                                                          
   def apply[R](f: F0[R]): T => R = f.f

   class F0[R](val f: T => R)
   object F0 {
      implicit def f2f0[R](fn: T => R): F0[R] = new F0(fn)
   }
}

object Test {
  def main(args: Array[String]): Unit = {
    (new Lift[String])((_: String).length)
  }
}
{code}
In the repl a type error (and the type error looks right to me):
{code}
<console>:8: error: type mismatch;
 found   : (String) => Int
 required: _1.F0[?] where val _1: Lift[String]
           (new Lift[String])((_: String).length)
                                          ^
{code}
Same crash outside.
{code}
	at scala.tools.nsc.ast.TreeGen.mkAttributedQualifier(TreeGen.scala:82)
	at scala.tools.nsc.ast.TreeGen.mkAttributedQualifier(TreeGen.scala:45)
	at scala.tools.nsc.ast.TreeGen.mkAttributedRef(TreeGen.scala:107)
	at scala.tools.nsc.ast.TreeGen.mkAttributedStableRef(TreeGen.scala:149)
	at scala.tools.nsc.ast.TreeGen.mkAttributedQualifier(TreeGen.scala:60)
{code}
