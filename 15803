= problem =
Manifest.equals is extremely slow in scala.2.8.1.final. While there is a noticable improvement (about 2x to 3x) in unreleased 2.9.0, it is still very slow.

= analysis =
Below is a short benchmark to estimate the performance of Manifest.equals. It is not very accurate, but enough to demonstrate perforamnce slower by a factor of 50x to 100x when comared to AnyValManifest.
```scala
import scala.reflect._


object ManifestBench {
  def main(args: Array[String]) {
    test()
    test()
    test()
  }

  final val iterations = 10*1000*1000
  final val opIterations = 300

  
  def test() {
    println("\nTesting...")
    var start = 0L

   
    start = System.currentTimeMillis
    testValManifest(iterations)
    System.gc()
    val testValManifestTime = System.currentTimeMillis - start

    start = System.currentTimeMillis
    testClassManifest(iterations)
    System.gc()
    val testClassManifestTime = System.currentTimeMillis - start

    start = System.currentTimeMillis
    testManifest(iterations)
    System.gc()
    val testManifestTime = System.currentTimeMillis - start

    start = System.currentTimeMillis
    testFlops(iterations)
    System.gc()
    val testFlopsTime = System.currentTimeMillis - start

    println("\nResults:")
    println("Val Manifest time: " + testValManifestTime + ".")
    println("Class Manifest time: " + testClassManifestTime + ".")
    println("Manifest time: " + testManifestTime + ".")
    println("Flops time: " + testFlopsTime + ", " +
            opIterations*3 + " floating point operations per iteration.")
  }
  
  final val StringClassManifest = ClassManifest.classType[String](classOf[String])
  final val StringManifest = Manifest.classType[String](classOf[String])
  private final def getManifest(i: Int) = {
    i & 0x3 match {
      case 0 => Manifest.Int
      case 1 => Manifest.Float
      case 2 => StringClassManifest
      case 3 => StringManifest
    }
  }
  final def testValManifest(iterations: Int) {
    var a = 0
    val m = Manifest.Int

    var i = 0; while (i < iterations) {
      if (m == getManifest(i)) a += 1

      i += 1
    }

    println(a)
  }

  final def testClassManifest(iterations: Int) {
    var a = 0
    val m = StringClassManifest

    var i = 0; while (i < iterations) {
      if (m == getManifest(i)) a += 1

      i += 1
    }

    println(a)
  }

  final def testManifest(iterations: Int) {
    var a = 0
    val m = StringManifest

    var i = 0; while (i < iterations) {
      if (m == getManifest(i)) a += 1

      i += 1
    }

    println(a)
  }

  final def testFlops(iterations: Int) {
    var a = 0
    val m = StringManifest

    var i = 0; while (i < iterations) {
      a += doSomeFloatingOps(i)

      i += 1
    }

    println(a)
  }

  final def doSomeFloatingOps(x: Int) :Int = {
    var a = 0.0

    // Floating point operations: 2 muls 1 add per iteration
    var i = 0; while (i < opIterations) {
      a += i*1.1*x

      i += 1
    }

    a.toInt
  }
}
```

= enhancement recommendation =
Manifests are very likely to be cached as global variables. Starting equals() implementation with a quick test for (this eq that) should significanly improve performance when comparing cached manifests.

It is possible to use a workaround method:
```scala
def compare(m1: Manifest[_], m2: Manifest[_]) : Boolean = {
  if (m1 eq m2) true else (m1 == m2)
}
```

However nothing can be done to improve the performance of pattern matching without patching the Manifest.equals method:
```scala
m match  {
  case ManifestCache.MyManifest => //
  case ManifsetCache.AnotherManfiest => //
}
```
