Note that the problem is in the {{map}} call, the compiler never even reaches the {{collect}} at the end. And it isn't an {{Int}} vs {{Integer}} thing, the same thing happens with e.g. {{String}}.

One workaround is to explicitly annotate the return type in the call to {{map}}:

{code}
scala> 1.to(10).asJava.stream().map[Int](_ + 1).collect(Collectors.toList[Int])
res3: java.util.List[Int] = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
scala> Seq("foo").asJava.stream().map[String](_.reverse)
res4: java.util.stream.Stream[String] = java.util.stream.ReferencePipeline$3@69d2c460
{code}

But note that {{java.util.List[Int]}} isn't really a proper type since Java doesn't allow primitive types as type parameters. What type you might want instead depends on what you're doing.

A more generally applicable workaround here is to use scala-java8-compat (https://github.com/scala/scala-java8-compat), which exists exactly to improve interop in situations like this:

{code}
scala> import scala.compat.java8.StreamConverters._
scala> 1.to(10).seqStream.map(_ + 1).toScala[Vector]
res0: Vector[Int] = Vector(2, 3, 4, 5, 6, 7, 8, 9, 10, 11)

scala> import java.util.stream.Collectors
scala> 1.to(10).seqStream.map(_ + 1).boxed.collect(Collectors.toList())
res1: java.util.List[Integer] = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
{code}

and so on.
