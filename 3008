After playing around a bit more, seems it might be something more basic about unification and existential types:

{code}
// to help me see how scala is unifying two types
scala> case class Unify[A](a : A, b : A)
defined class Unify

// A generic container with no variance on its parameter
scala> case class X[A](a: A)
defined class X

// Two container instances with different type parameters
scala> val (x, y) = (X(1), X("a"))
x: X[Int] = X(1)
y: X[java.lang.String] = X(a)

// Let's try unify these types:
scala> Unify(x, y)              
res46: Unify[X[_ >: java.lang.String with Int]] = Unify(X(1),X(a))
{code}

It has inferred an existential type here: X[A] forSome {type A >: String with Int}

This seems wrong - the only possible value for 'type A >: String with Int' would be 'Any', and X[Any] is not a supertype of X[Int] or of X[String], since X has no variance.

This is confirmed by the following errors:

{code}
scala> Unify(x,y) : Unify[X[Any]]
<console>:28: error: type mismatch;
 found   : X[Int]
 required: X[Any]
       Unify(x,y) : Unify[X[Any]]
             ^
<console>:28: error: type mismatch;
 found   : X[java.lang.String]
 required: X[Any]
       Unify(x,y) : Unify[X[Any]]

scala> x : X[Any]
<console>:15: error: type mismatch;
 found   : X[Int]
 required: X[Any]
{code}

So why did it infer that type?

If it wants to infer an existential type it seems that X[A] forSome {type A} should be a valid supertype for both. But if you try and give it a helping hand to infer this, it doesn't work:

{code}
scala> val y : X[A] forSome {type A} = X("a")
y: X[_] = X(a)

scala> val x : X[A] forSome {type A} = X(1)  
x: X[_] = X(1)

scala> Unify(x,y)
<console>:17: error: type mismatch;
 found   : Unify[X[_ >: A(in object $$iw) with A]] where type A, type A(in object $$iw)
 required: Unify[X[_ >: A(in value res54) with A(in value res54)]] forSome { type A(in value res54); type A(in value res54) }
       val res54 = 
{code}
