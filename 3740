I saw Eric's [post to scala-lang](https://groups.google.com/forum/#!topic/scala-language/pPGjYI6r5GE):
```scala
case class Converted[+T](t: () => T)
implicit def convert[T](t: =>T) = Converted(() => t)
  
var evaluated = false
val t: Converted[Int] = { evaluated = true; 1 }

// prints true
evaluated
```

The above behavior looks pathological given the following explicit application does not trigger the side effect:
```scala
convert { evaluated = true; 1 }
```

Here are the relevant sections in the Scala Language Specification:
```
h3. 7.3 Views

Implicit parameters and methods can also define implicit conversions called views. A view from type _S_ to type _T_ is defined by an implicit value which has function type _S=>T_ or _(=>S)=>T_ or by a method convertible to a value of that type.

Views are applied in three situations.

1. If an expression _e_ is of type _T_, and _T_ does not conform to the expressionâ€™s expected type _pt_. In this case an implicit _v_ is searched which is applicable to e and whose result type conforms to _pt_. The search proceeds as in the case of implicit parameters, where the implicit scope is the one of _T => pt_. If such a view is found, the expression _e_ is converted to _v(e)_.

....

The implicit view, if it is found, can accept is argument e as a call-by-value or as a call-by-name parameter. However, call-by-value implicits take precedence over call-by-name implicits.

h4. 4.6.1 By-NameParameters

Syntax:
{code}    ParamType ::= '=>' Type{code}

The type of a value parameter may be prefixed by _=>_, e.g. _x: => T_. The type of such a parameter is then the parameterless method type _=> T_. This indicates that the corresponding argument is not evaluated at the point of function application, but instead is evaluated at each use within the function. That is, the argument is evaluated using _call-by-name_.
```

Because the block evaluating to 1 does not conform to Converted[Int], it's the first condition of view that's being used, not the missing method or incompatible arg case. According to the spec, this converts the expression *e* to *v(e)*, which in this case is:
```scala
convert { evaluated = true; 1 }
```

Unless *t.t* is invoked, I don't see why this block should be evaluated.
