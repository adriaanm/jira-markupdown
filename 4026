Hi,

I think that your bug is triggered by a (correct) fix we added in RC2.

When annotating a constructor argument, the annotation only ends up on the actual argument of the constructor, but not on any of the generated fields / getters / setters. Due to a bug, this was different in RC1 (and before), the annotation would end up on the fields as well.

What you need to do is add a meta-annotation to the annotation type, see documentation here: http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/scala/annotation/target/field.html

In your case, you probably want something like
```scala
import annotation.target.field

@Entity
@Table(name = "origo_routable_entity")
@PrimaryKeyJoinColumn(name = "entity_id")
class RoutableEntity(
	@(OneToOne @field)(fetch = FetchType.LAZY, optional = false)
	@(JoinColumn @field)(name = "calendar_entry_id")
	@BeanProperty
	var calendarEntry: CalendarEntry,
```

You can define type aliases to improve the readability
```scala
object MyAnnotations {
  type OneToOne = jpa.OneToOne @field
  type JoinColumn = jpa.JoinColumn @field
}
```

and then import / use these annotations instead of the original ones.
