A bit more analysis:

{code}
scala> abstract class A { def a() }; abstract class B extends A { def a() }
defined class A
defined class B

scala> object C extends B { override def a() = super.a() }
<console>:9: error: method a in class B is accessed from super. It may not be abstract unless it is overridden by a member declared `abstract' and `override'
       object C extends B { override def a() = super.a() }
                                                     ^

scala> import reflect.{mirror => m}
import reflect.{mirror=>m}

scala> m.classToType(classOf[B]).member(m.newTermName("a")).modifiers
res1: Set[scala.reflect.api.Modifier] = Set(deferred)

scala> class A { def a() {} }; abstract class B extends A { def a() }
defined class A
defined class B

scala> object C extends B { override def a() = super.a() }
defined module C

scala> m.classToType(classOf[B]).member(m.newTermName("a")).modifiers
res2: Set[scala.reflect.api.Modifier] = Set()

scala> C.a()
java.lang.AbstractMethodError: A.a()V
	at C$.a(<console>:10)
	at .<init>(<console>:12)
	at .<clinit>(<console>)
{code}

Key question: When does the symbol for {{method B#a}} lose the {{DEFERRED}} flag? Without it, the check in {{SuperAccessors}} doesn't catch this problem.
