There's weird behavior exhibited by isAsSpecific in Infer.scala: https://github.com/scala/scala/blob/ccfa36071f0623d64474f37b12d40a838aac1b4e/src/compiler/scala/tools/nsc/typechecker/Infer.scala#L808.

In particular, it thinks that:
```scala
isAsSpecific((x: Int => Int)Nothing, (x: MyFunction1[Int,Int])Nothing) = true
```

In order to check specificity, isAsSpecific calls isCompatible (https://github.com/scala/scala/blob/ccfa36071f0623d64474f37b12d40a838aac1b4e/src/compiler/scala/tools/nsc/typechecker/Infer.scala#L294) passing Int => Int and MyFunction1[Int, Int] as arguments to that method.

The isCompatible check succeeds because it falls through into the isCompatibleSam case. It thinks that Int => Int is compatible with MyFunction1[Int, Int]. 

After isCompatible returns true, isAsSpecific concludes that the overload with Int => Int is as specific as the overload with MyFunction1[Int, Int]. As a result, overload resolution fails with an ambiguity.

I think that isCompatible works incorrectly. Not every Int => Int is compatible with MyFunction1[Int, Int]. Only lambdas are compatible with that type. Am I correct in pointing this out, or that was done deliberately?
