In {{g}} below, I was surprised to see that {{math.max(Int,Int)}} expands to {{(x: Int, y: Int) => math.max(x, y)}} which then changes the overload selection to {{(x: Int, y: Int) => math.max(x.toLong, y.toLong)}}. Equally erroneous but somehow more natural would be {{math.max(x,y).toLong}}.

Applicability includes result type, but all that's required is weak conformance.

{code}
scala> def f(x: Int, y: Int): Long = math.max(x,y) //print

def f(x: scala.Int, y: scala.Int): scala.Long = scala.math.`package`.max(x, y).toLong // : <notype>

scala> def f(x: Int, y: Int): Long = math.max(x,y) //print
f: (x: Int, y: Int)Long

scala> def f[A >: Long](x: Int, y: Int): A = math.max(x,y) //print

def f[A >: scala.Long](x: scala.Int, y: scala.Int): A = scala.math.`package`.max(x.toLong, y.toLong) // : <notype>

scala> def f[A >: Long](x: Int, y: Int): A = math.max(x,y) //print
f: [A >: Long](x: Int, y: Int)A

scala> def g[A >: Long]: (A,A)=>A = math.max //print

def g[A >: scala.Long]: _root_.scala.Function2[A, A, A] = {
  ((x: Int, y: Int) => scala.math.`package`.max(x.toLong, y.toLong))
} // : <notype>

scala> def g[A >: Long]: (A,A)=>A = math.max //print
<console>:11: error: type mismatch;
 found   : (Int, Int) => Long
 required: (A, A) => A
       def g[A >: Long]: (A,A)=>A = math.max //print
                                         ^

{code}
There's a [SO question|http://stackoverflow.com/questions/18108965/reducing-an-array-of-float-using-scala-math-max] which I must have understood because I added the debug output to the answer. Supposedly it shows when type inference wins.
