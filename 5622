I have a problem that I can not solve easily. I am experimenting with a user interface library that can have different native implementations.

A {{Window}} for example might be an OS window, same with {{Stage}}. So when a {{Window}} instance is created I want to call the underlying native engine to create the appropriate object for that component.

I tried it with the code below, but the {{delayedInit}} method is called twice when an instance of {{Stage}} is created, once for the {{body}} of {{Window}} and once for the {{body}} of {{Stage}}. As far as I can tell there is no way to tell from within the {{Native}} trait if I am executing the last body.

{code}
trait Native extends DelayedInit {
  def delayedInit(body: => Unit) = {
    body
    println("object created")
    //create native object for this 
  }
}

class Window extends Native {

  val windowProperty: Boolean = false
}

class Stage extends Window {

  val stageProperty: Boolean = false
}
{code}

I see two workarounds:
1. Traversing all of the components created in a hierarchy and creating their native counterparts if needed
2. Let all the components that are native override a method that does exactly the same thing: {{create native object for this}}

Both of these workarounds are problematic: 1. is bad for performance and 2. goes against the DRY principle.

This would be easily solved by a {{OnCreate}} trait as suggested.

Can this problem be solved without the {{OnCreate}} trait?
