I don't know precisely what's happening here, other than it's a contravenes the safe construction guideline "Don't implicitly expose the "this" reference" [1]

[1] http://www.ibm.com/developerworks/java/library/j-jtp0618/index.html

Here we can see the problem without `scala.concurrent._`:
```scala



object Test {
  import ExecutionContext.Implicits._

  def main(args: Array[String]) {
    println("main()")
  }
  println("init Test")

  def delegate(): String = {println("delegate"); "abc"}

  val l = new java.util.concurrent.CountDownLatch(1)
  new Thread {
    override def run() {
      delegate()
      l.countDown()
    }
  }.start()
  l.await()
}

/*
"Thread-1" prio=5 tid=7fca45948800 nid=0x115985000 in Object.wait() [115984000]
   java.lang.Thread.State: RUNNABLE
  at Main$$anon$1.run(fut.scala:17)

"main" prio=5 tid=7fca44801800 nid=0x10db68000 waiting on condition [10db65000]
   java.lang.Thread.State: WAITING (parking)
  at sun.misc.Unsafe.park(Native Method)
  - parking to wait for  <7eb120c90> (a java.util.concurrent.CountDownLatch$Sync)
  at java.util.concurrent.locks.LockSupport.park(LockSupport.java:156)
  at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:811)
  at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:969)
  at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1281)
  at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:207)
  at Main$.<init>(fut.scala:21)
  at Main$.<clinit>(fut.scala)
  at Main.main(fut.scala)
*/
```
