Me neither, but I notice:
```scala
// java6
class java.util.Vector$1 extends java.lang.Object implements java.util.Enumeration
// java7
class java.util.Vector$1 extends java.lang.Object implements java.util.Enumeration<E>
```
And here's Mr. E:
```scala
scala> classOf[java.util.Vector[_]].getGenericInterfaces.head
res0: java.lang.reflect.Type = java.util.List<E>
// or for that matter
scala> classOf[java.util.Vector[String]].getGenericInterfaces.head
res1: java.lang.reflect.Type = java.util.List<E>
```
What is this all about? Why won't it infer (or even allow) Vector[String] ?
```scala

scala> val v = new java.util.Vector[String]
v: java.util.Vector[_] = []

scala> val v: java.util.Vector[String] = new java.util.Vector[String]
<console>:7: error: type mismatch;
 found   : java.util.Vector[?0] where type ?0
 required: java.util.Vector[String]
       val v: java.util.Vector[String] = new java.util.Vector[String]
                                         ^
```
This has a weirdly familiar feel. You get one bite at the apple, then it's over.
```scala
scala> val v: java.util.Vector[String] = new java.util.Vector[String](5)
v: java.util.Vector[String] = []

scala> val v: java.util.Vector[String] = new java.util.Vector[String](5)
<console>:7: error: type mismatch;
 found   : Int(5)
 required: java.util.Collection[_ <: String]
       val v: java.util.Vector[String] = new java.util.Vector[String](5)
                                                                      ^
```
