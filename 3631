```scala
trait Base { def name: String }
trait OverrideLazy extends Base { override def name = "One" }
trait AbstractOverrideLazy extends Base { abstract override def name = super.name }

class ShouldNotLoop extends Base with OverrideLazy with AbstractOverrideLazy // super.name refers to OverrideLazy's name

/* Decompiled to Java

public interface Base {
    public abstract String name();
}

public interface OverrideLazy extends Base {
    public abstract String name();
}

public interface AbstractOverrideLazy extends Base {
    public abstract String AbstractOverrideLazy$$super$name();
    public abstract String name();
}

public abstract class OverrideLazy$class {
  public static String name(OverrideLazy $this) { return "One"; }
  public static void $init$(OverrideLazy overridelazy) {}
}

public abstract class AbstractOverrideLazy$class { 
  public static String name(AbstractOverrideLazy $this) { return $this.AbstractOverrideLazy$$super$name(); }
  public static void $init$(AbstractOverrideLazy abstractoverridelazy){}
}


import scala.runtime.BoxedUnit;

public class ShouldNotLoop implements OverrideLazy, AbstractOverrideLazy {
    private String name$lzycompute() {
        synchronized(this) {
            if(!bitmap$0) {
                name = AbstractOverrideLazy.class.name(this);
                bitmap$0 = true;
            }
            BoxedUnit _tmp = BoxedUnit.UNIT;
        }
        return name;
    }

    public String name() { return bitmap$0 ? name : name$lzycompute(); }

    public String AbstractOverrideLazy$$super$name() { return name(); }

// when replacing the `lazy val`s by `def`s, we get the correct superaccessor
//    public String AbstractOverrideLazy$$super$name() { return OverrideLazy.class.name(this); }

    public ShouldNotLoop()
    {
        OverrideLazy.class.$init$(this);
        AbstractOverrideLazy.class.$init$(this);
    }

    private final String name;
    private volatile boolean bitmap$0;
}

*/
```
