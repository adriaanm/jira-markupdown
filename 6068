Well this is an interesting one.  We're missing an entire category of superaccessor.  Watch what java does with these classes:
{code}
// A.java
package a;

class A {
  public void foo1() { }
  public void foo2() { }
  public void foo3() { }
}
// A2.java
package a;

public class A2 extends A { }
{code}
Now look at A2.  It gets accessor methods for every method in A even though it can access them just fine since it's in the same package.  But its subclasses won't be able to, and thanks to separate compilation it has to assume the worst and put in forwarders for everything.  Nice.

{noformat}
public class a.A2 extends a.A{
public a.A2();
  Code:
   0:	aload_0
   1:	invokespecial	#1; //Method a/A."<init>":()V
   4:	return

public void foo3();
  Code:
   0:	aload_0
   1:	invokespecial	#2; //Method a/A.foo3:()V
   4:	return

public void foo2();
  Code:
   0:	aload_0
   1:	invokespecial	#3; //Method a/A.foo2:()V
   4:	return

public void foo1();
  Code:
   0:	aload_0
   1:	invokespecial	#4; //Method a/A.foo1:()V
   4:	return

}
{noformat}
Of course if you make A public, A2 gets nothing.
