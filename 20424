As per [this Stackoverflow question](http://stackoverflow.com/questions/42423441/compile-error-with-implicit-class-method-named-clone), following fails to compile:
```scala
class Foo(val bar: String)

object Foo {
  implicit class Enrich(foo: Foo) {
    def clone(x: Int, y: Int): Int = x + y
  }
}

object Main extends App {
  val foo = new Foo("hello")
  println(foo.clone(1, 2))    // <- does not compile
}
```
```scala
-Ytyper-debug bonkers immediately after finding a suitable candidate upon subsequent search:

```
|-- foo.clone(1, 2) : pt=Unit EXPRmode (site: method main in Main)
|    |    |    |    |-- foo.clone BYVALmode-EXPRmode-FUNmode-POLYmode (silent: method main in Main)
|    |    |    |    |    |-- foo EXPRmode-POLYmode-QUALmode (silent: method main in Main)
|    |    |    |    |    |    \-> foo.type (with underlying type my.awesome.pkg.Foo)
|    |    |    |    |    [search #1] start `my.awesome.pkg.Foo`, searching for adaptation to pt=foo.type => ?{def clone: ?} (silent: method main in Main) implicits disabled
|    |    |    |    |    |-- my.awesome.pkg.Foo.Enrich TYPEmode (site: method Enrich in Foo)
|    |    |    |    |    |    \-> my.awesome.pkg.Foo.Enrich
|    |    |    |    |    |-- Foo TYPEmode (site: value foo in Foo)
|    |    |    |    |    |    \-> my.awesome.pkg.Foo
|    |    |    |    |    |-- Int TYPEmode (site: method clone in Enrich)
|    |    |    |    |    |    \-> Int
|    |    |    |    |    |-- Int TYPEmode (site: value x in Enrich)
|    |    |    |    |    |    \-> Int
|    |    |    |    |    |-- Int TYPEmode (site: value y in Enrich)
|    |    |    |    |    |    \-> Int
|    |    |    |    |    [search #1] considering pkg.this.Foo.Enrich
|    |    |    |    |    |-- pkg.this.Foo.Enrich BYVALmode-EXPRmode-FUNmode-POLYmode (silent: method main in Main) implicits disabled
|    |    |    |    |    |    \-> (foo: my.awesome.pkg.Foo)my.awesome.pkg.Foo.Enrich
|    |    |    |    |    [search #1] success inferred value of type foo.type => ?{def clone: ?} is SearchResult(pkg.this.Foo.Enrich, )
|    |    |    |    |    [search #2] start `my.awesome.pkg.Foo`, searching for adaptation to pt=(=> foo.type) => ?{def clone: ?} (silent: method main in Main) implicits disabled
|    |    |    |    |    \-> <error>
Main.scala:6: error: method clone in class Object cannot be accessed in my.awesome.pkg.Foo
 Access to protected method clone not permitted because
 prefix type my.awesome.pkg.Foo does not conform to
 object Main in package pkg where the access take place
    foo.clone(1, 2) // <- does not compile
```

Perhaps indirectly related to [SI-6760](https://issues.scala-lang.org/browse/SI-6760) but overloaded method had different signature than `Object.clone`.

This does compile under 2.10.6. Biggest difference I see in the type tree is that 2.10.6 tried to cook the method parameters while 2.11.8 doesn't:

2.11.8:
```scala
DefDef( // def clone(x: Int,y: Int): Int in class Enrich
 <method>
 "clone"
```

2.10.6:
```scala
DefDef( // def clone(x: Int,y: Int): Int in class Enrich
 <method> <triedcooking>
  "clone"
```
