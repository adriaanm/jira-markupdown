Inspired by sjson and sbinary etc., scalaxb generates plain case classes and XML data binding "type class" instances separately.
- http://scalaxb.org/typeclass

I used to implement fromXML and toXML in companion objects before, but switching to type classes has repaid many times over.

h4. clean interface

{code} 
trait ApiFaultable {
  val exceptionCode: generated.ExceptionCode
  val exceptionMessage: String
}

case class ApiFault(exceptionCode: generated.ExceptionCode,
  exceptionMessage: String) extends ApiFaultable
{code} 

Notice there's no mention of XML here. This is easier to wrap the head around.
{code}scalaxb.fromXML[ApiFault](xml){code} works the same way {code}scalaxb.fromXML[Int](xml){code} works.

h4. customizability

The type class pattern also allows ad-hoc polymorphism.
Suppose the generated parser combinator parses something like {code}Order(Address("x", "x"), Address("x", "x"), 2){code}

The user is stuck with this structure, which is ok. Since type class is resolved at the call site, user can customize XML output of _any_ of the types appearing in the expression {{Order}}, {{Address}}, {{String}}, and {{Int}}.

Yes, taking this approach puts some burden on the compiler. It's been able to take the load for many of the generated code until now. Given the size of the code, I don't think 600 implicits are that insane. Shouldn't the compiler scale to handle any number of implicits linearly?

(Let me know if this is not the appropriate forum to discuss this)
