Existentials as arguments to `unapply` result in a compilation error:

Minimal example:
```scala
  trait Match {
    type X
    def unapply(x: X): Option[String]
  }

  def foo(m: Match): m.X => String = {
    case m(s) => s
  }
```

yields
```
an unapply result must have a member `def isEmpty: Boolean
[error]     case m(s) => s
[error]          ^
[error] one error found
[error] (compile:compile) Compilation failed
```

In contrast, a variant using universal types works just fine:
```scala
  trait Match[X] {
    def unapply(x: X): Option[String]
  }

  def foo[X](m: Match[X]): X => String = {
    case m(s) => s
  }
```


Might be related to the following issues:
- [https://issues.scala-lang.org/browse/SI-6680]
- [https://issues.scala-lang.org/browse/SI-8128]
