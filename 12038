A.P. Marki: You said "The warning is non-trivial because if the init throws, the lazy val is still uninitialized, and the init will run again on subsequent invocations."

Are you saying that since this code will, of necessity throw, then the dead code is the code which assigns a value to the lazy val foo ? That "code" is invisible to the scala programmer. 

To me there's no question that there is no dead code here. Given a trait:
{code}
trait B {
   def foo: FooType
}
{code}
I can create many polymorphic descendents of this. 
{code}
class C extends B {
  override lazy val foo = new FooType
}
class D extends B {
  // On this class, lazy val foo doesn't make any sense to use
  override lazy val foo = throw new Exception("don't use this on D objects")
}
{code}
Clearly the above makes sense. If I have an object reference of type B, then demanding the B.foo lazy val might return a value, or might throw an exception.

In the OO fat-interface pattern, one often has methods/lazy-vals that are expressed on classes but not implementable, so an explicit throw is the only sensible thing to put in them. 

So there should be no dead-code warning associated with the class D lazy val foo. 
