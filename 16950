Utilizing JTree within Scala (JTree is it's own problem!) and came across this issue.

Context: In Java, a class named jdcMutableTreeNode extends javax.swing.tree.DefaultMutableTreeNode (to solve an unrelated issue).  Then in Scala, the WrapTreeNode extends jdcMutableTreeNode (and provides most of the logic for the application).

This Scala code:
```
        val treeNodes = model.getPathToRoot(this)
        val path = new TreePath(treeNodes)
        tree.expandPath(path)

throws this Exception (at tree.expandPath):

Exception in thread "AWT-EventQueue-0" java.lang.ClassCastException: [Ljavax.swing.tree.TreeNode; cannot be cast to javax.swing.tree.TreeNode
	at javax.swing.tree.DefaultTreeModel.isLeaf(Unknown Source)
	at javax.swing.JTree.expandPath(Unknown Source)
	at WrapTreeNode.sortChildren(dsTree.scala:184)
	at SwingRePaint.runDownTree(dsTree.scala:342)
	at SwingRePaint$$anonfun$runDownTree$1.apply$mcVI$sp(dsTree.scala:364)
	at scala.collection.immutable.Range.foreach$mVc$sp(Range.scala:75)
	at SwingRePaint.runDownTree(dsTree.scala:362)
	at SwingRePaint.run(dsTree.scala:334)
	at java.awt.event.InvocationEvent.dispatch(Unknown Source)
	at java.awt.EventQueue.dispatchEventImpl(Unknown Source)
	at java.awt.EventQueue.access$000(Unknown Source)
	at java.awt.EventQueue$3.run(Unknown Source)
	at java.awt.EventQueue$3.run(Unknown Source)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.security.ProtectionDomain$1.doIntersectionPrivilege(Unknown Source)
	at java.awt.EventQueue.dispatchEvent(Unknown Source)
	at java.awt.EventDispatchThread.pumpOneEventForFilters(Unknown Source)
	at java.awt.EventDispatchThread.pumpEventsForFilter(Unknown Source)
	at java.awt.EventDispatchThread.pumpEventsForHierarchy(Unknown Source)
	at java.awt.EventDispatchThread.pumpEvents(Unknown Source)
	at java.awt.EventDispatchThread.pumpEvents(Unknown Source)
	at java.awt.EventDispatchThread.run(Unknown Source)
```

Couldn't quite figure out where the **[Ljavax.swing.tree.TreeNode** type came from.  If I stop it in the Eclipse debugger, everything looks as expected (path is listed as a TreePath by Eclipse, but also shows [[Ljavax.swing.tree.TreeNode;@88fdaf] if you click on TreePath in the Value pane).

Anyway, as a workaround added this method in Java, invoked it instead of the above code, and it works as expected.  (The **tree.isCollapsed(path)** was omitted from the Scala code above just so I could force the Exception.  In the original Scala code it was present and worked OK.)
```
  /** From Scala kept getting a weird class case Exception                    */
  public void makeSureNodeExpanded(JTree tree, DefaultTreeModel model, jdcMutableTreeNode node){
    TreePath path = new TreePath(model.getPathToRoot(node));
    if(tree.isCollapsed(path))
      tree.expandPath(path);
  }
```

