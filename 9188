If I apply the straightforward encoding into member types, this is what I get:
```scala
  trait A {
    type X
    protected[this] def f(x: X): X = x
  }

  trait B extends A {
    type X <: B
    def kaboom = f(new B {})
  }
```

This code does not typecheck - kaboom is ill typed. Interestingly, The dotc compiler does not use the straightforward encoding, but instead would type B as follows:
```scala
  trait B extends A {
    type X =+ B
    def kaboom = f(new B {})
  }
```

The "=+" is not available in user code, and has no foundation in DOT. It means in effect something like "covariant alias binding". With this change, the code compiles, and exhibits the same unsoundness hole. 

Now, as far as I know variant aliases is the most significant deviation of dotc from DOT. It is telling that this deviation leads directly to an unsoundness hole. Why did I add variant aliases? Because, without them, the collections library could not be ingested. 

So, this points to three possible ways forward, which should be investigated further.

1. Get rid of -=, +=, but keep covariant protected[this]. We will not be able to read collections as they are then. We might lose too much expressiveness that way, this remains to be checked out.

2. Get rid of protected[this]. Plaster lots of @uncheckedVariance annotations over collections to make them work. This is the least invasive change, but it casts in stone the variant alias concept and with it the difference between generics and member types.

3. Declare the rebinding differently:
```scala
  trait B extends A {
    type T = B
    def kaboom = f(new B {})
  }
```

This would then invalidate the definition of C. I believe this is what Paolo was proposing to also fix the GADT problem.
Again, we'd have to check what we lose in expressiveness by doing this.
