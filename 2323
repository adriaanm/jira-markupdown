Okay, I've boiled it down to a simple test case, see attachments.

Here is the tree generated by the pattern match:
```scala
{
  var temp1: this.T1 = ({
    final class $$anon extends java.lang.Object with this.T2 with this.U1 {
      def this($$outer: anonymous class $$anon): anonymous class $$anon = {
        $$anon.super.this();
        ()
      };
      <synthetic> <paramaccessor> private[this] val $$outer: anonymous class $$anon = _;
      <synthetic> <stable> def main$$$$anon$$$$anon$$$$$$outer(): anonymous class $$anon = $$anon.this.$$outer
    };
    new anonymous class $$anon($$anon.this)
  }: this.T1);
  if (temp1.isInstanceOf[this.T2]())
    {
      {
        {
          {
            if ($$anon.this.Extractor().unapply(temp1.asInstanceOf[this.T2]()).isEmpty().unary_!())
              {
                {
                  {
                    "Extractor(_)"
                  }
                }
              }
            else
              {
                "matched _"
              }
          }
        }
      }
    }
  else
    if (temp1.isInstanceOf[this.T1 with this.U1]())
      {
        {
          {
            {
              "matched: U1"
            }
          }
        }
      }
    else
      {
        "matched _"
      }
}
```
