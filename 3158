Thanks for solving this so quickly. I will test it when it goes into the nightly build.

An automated test is a bit tricky because the garbage collector behaves somewhat unpredictable. However, here is a piece of code which reproduces the effect for me (while a corresponding Java version works well, as you would expect):
{code}
import scala.ref.{ReferenceQueue, SoftReference}
import scala.collection.mutable.ArrayBuffer
class RefQueueTest(arr: Array[Byte], queue: ReferenceQueue[Array[Byte]])
         extends SoftReference[Array[Byte]](arr, queue) {
   override protected def finalize() {
      RefQueueTest.finalizeCount += 1
   }
}
object RefQueueTest {
   var finalizeCount = 0
   def main(args: Array[String]) {
      val queue = new ReferenceQueue[Array[Byte]]
      val buf = new ArrayBuffer[RefQueueTest]
      for (i <- 0 until 100) {
         buf += new RefQueueTest(new Array[Byte](1024), queue)
      }
      buf.clear()
      System.gc()
      Thread.sleep(500)
      System.gc()

      // The test succeeds if finalizeCount is >0 at this point.
      System.out.println("finalize count: " + finalizeCount);
   }
}
{code}
With the current (unfixed) Scala version, the finalize count is always 0 at the end. In the Java version it always seems to be 100. This is of course not strictly guaranteed as the garbage collector might decide not the free the objects or run the finalizers yet. But with 100 objects and the {{sleep}} it appears to work quite reliably. The {{sleep}} seems to be necessary to give the finalizers some time to run.
