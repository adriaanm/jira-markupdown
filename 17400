From my scala-internals post (https://groups.google.com/d/msg/scala-internals/PqK6GkZhJK0/xjZw3wQ4wYEJ), verbatim: 

Ideally, the function of Ctrl-C should depend on whether the REPL is waiting for user input, or running something in the foreground.  

Waiting at a prompt, my preference would be:

- If there's no text entered at the prompt, print a message like "(interrupt) type :quit <Enter> or Ctrl-D to exit"
  - it's handy to trap Ctrl-C here, because people often press it repeatedly without intending to completely exit their current activity--mysql client, I'm looking at you
- If there is text entered, discard it and bring up a new, empty prompt--this is what bash does.

With a foreground task running, ideally Ctrl-C should kill the task and return control to the REPL.  I guess this implies running each command in a separate thread from the REPL itself, so it can be forcibly stopped—but of course, this doesn't necessarily imply **starting a new thread for each command**—we could just keep one of them around to run user code in—until it dies, only then we start a new one.

As for the mechanics of stopping the task, so long as we're baking pie in the sky...

{code:java}
while (!thread.isDead) {
  thread.youShouldExitNow() // presumably this is a custom thread class
  thread.interrupt()
  Thread.sleep(n) // say 2-5 seconds
  if (!thread.isDead) {
    val yn = prompt "The thread hasn't exited yet. Should we try to forcibly stop it?"
    if (yn == "y") {
      thread.stop()
    } 
  }
}
{code}

If anything is running in the background, may FSM have mercy on its soul. Out of scope. :)

If we felt like being clever, we could rewrite any line that has a looping construct at the root of its tree to be breakable.  If it's a method call that loops, well, too bad.
