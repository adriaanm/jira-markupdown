```scala
object MyApp extends App {
  trait Ring[T] {
    def plus(x: T, y: T): T
    def equiv(x: T, y: T): Boolean
  }

  object Ring {
    trait Element[T <: Element[T]] { this: T =>
      def factory: Ring[T]
      def +(that: T) = factory.plus(this, that)
      def ><(that: T) = factory.equiv(this, that)
    }
  }

  object BigInteger extends Ring[java.math.BigInteger] {
    def apply(value: Int) = java.math.BigInteger.valueOf(value)
    def plus(x: java.math.BigInteger, y: java.math.BigInteger) = x.add(y)
    def equiv(x: java.math.BigInteger, y: java.math.BigInteger) = x.equals(y)
  }

  implicit def int2bigInt(value: Int) = BigInteger(value)

  trait AbstractPoly[T <: AbstractPoly.Element[T, C], C] extends Ring[T] {
    implicit def ring: Ring[C]
    def plus(x: Poly.Element[C], y: Poly.Element[C]) = apply(ring.plus(x.value, y.value))
    def equiv(x: Poly.Element[C], y: Poly.Element[C]) = ring.equiv(x.value, y.value)
    def apply(value: C): T
  }

  object AbstractPoly {
    trait Element[T <: Element[T, C], C] extends Ring.Element[T] { this: T =>
      def factory: AbstractPoly[T, C]
      def value: C
      override def toString = value.toString
    }
  }

  class Poly[C](val ring: Ring[C]) extends AbstractPoly[Poly.Element[C], C] {
    def apply(value: C) = new Poly.Element(this)(value)
  }

  object Poly {
    class Element[C](val factory: Poly[C])(val value: C) extends AbstractPoly.Element[Element[C], C]
    object Element {
      implicit def coef2poly[D <% C, C](value: D)(implicit factory: Poly[C]) = factory(value)
    }
  }

  class RF[R <: AbstractPoly.Element[R, C], C](val ring: AbstractPoly[R, C]) extends Ring[RF.Element[R, C]] {
    def plus(x: RF.Element[R, C], y: RF.Element[R, C]) = apply(ring.plus(x.value, y.value))
    def equiv(x: RF.Element[R, C], y: RF.Element[R, C]) = ring.equiv(x.value, y.value)
    def apply(value: R) = new RF.Element(this)(value)
    def apply(value: C): RF.Element[R, C] = apply(ring(value))
  }

  object RF {
    class Element[R <: AbstractPoly.Element[R, C], C](val factory: RF[R, C])(val value: R) extends Ring.Element[Element[R, C]] {
      override def toString = value.toString
    }
    object Element {
      implicit def coef2rf[D <% C, R <: AbstractPoly.Element[R, C], C](value: D)(implicit factory: RF[R, C]) = factory(value)
    }
  }

  val c = BigInteger(1)

  import Poly.Element.coef2poly
  implicit val p = new Poly(BigInteger)
  val x = p(c)

  import RF.Element.coef2rf
  implicit val q = new RF(p)
  val y = q(x)
  println(1><y)
  println(1><y) // chokes on the second occurence only (!)
}
```
```scala
scalac -language:implicitConversions MyApp.scala
MyApp.scala:76: error: value >< is not a member of Int
  println(1><y)
           ^
```
It was working in 2.11.0-M6 and previous.
