Here's the place where we should attempt to fix this in the compiler:
```scala
git diff -U8 -- src/compiler/scala/tools/nsc/typechecker/Namers.scala
diff --git a/src/compiler/scala/tools/nsc/typechecker/Namers.scala b/src/compiler/scala/tools/nsc/typechecker/Namers.scala
index e3d7bfd..451cfab 100644
--- a/src/compiler/scala/tools/nsc/typechecker/Namers.scala
+++ b/src/compiler/scala/tools/nsc/typechecker/Namers.scala
@@ -766,16 +766,17 @@ trait Namers extends MethodSynthesis {
     /* Explicit isSetter required for bean setters (beanSetterSym.isSetter is false) */
     def accessorTypeCompleter(tree: ValDef, isSetter: Boolean) = mkTypeCompleter(tree) { sym =>
       logAndValidate(sym) {
         sym setInfo {
           val tp = if (isSetter) MethodType(List(sym.newSyntheticValueParam(typeSig(tree))), UnitTpe)
                    else NullaryMethodType(typeSig(tree))
           pluginsTypeSigAccessor(tp, typer, tree, sym)
         }
+        sym.setAnnotations(tree.symbol.annotations)
       }
     }

     def selfTypeCompleter(tree: Tree) = mkTypeCompleter(tree) { sym =>
       val selftpe = typer.typedType(tree).tpe
       sym setInfo {
         if (selftpe.typeSymbol isNonBottomSubClass sym.owner) selftpe
         else intersectionType(List(sym.owner.tpe, selftpe))
```

This patch just blindly copies **all** annotations to the getter symbol in the getter's type completer. (Actually, it just shares references). The question will be whether we can do the necessary filtering here (based on meta-annotations) without risking triggering cycles.
