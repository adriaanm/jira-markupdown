> Fair enough, how about `g1 || g2 || g3`? People write the darnedest code!

Are you asking about the case with code like
```scala
x match {
  case p if g1 => ...
  case p if g2 => ...
  case p if g3 => ...
}
```
... and where the compiler cannot establish that "{{g1 || g2 || g3 === true}}"?

Exactly the same principle applies. The compiler ought to complain that the match may not be exhaustive, and give an error like:
```scala
  warning: match may not be exhaustive.
  It would fail on the following input: p 
  (Note that 'if' guard clauses assumed to be false for the purposes of exhaustiveness checks.)
```

Then the user will realise that it is unhelpful to both the compiler and to the readers of their code to expect them to infer that "{{g1 || g2 || g3 === true}}", and they should rewrite the code as follows:
```scala
x match {
  case p if g1 => ...
  case p if g2 => ...
  case p => ...
}
```

This is much easier to read; it is much easier for the compiler to verify, and (assuming that the identity is in fact true, and that the tests have no side-effects), it is completely equivalent.

Therefore I think that:
 1. the compiler should not give up on  exhaustivity checks when encountering guard checks, as it will omit useful warnings (as can be seen in the initial bug report at the top)
 2. the compiler should assume that all guards are "false" when performing exhaustivity checks, as it is simple, predictable and correct (in general)
