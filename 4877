In case it's useful: javac's behavior when generating private field accessors is to omit the generic signature on the accessor method, but to preserve the generic signature (and name) of the private field:
```scala

public class Foo
{
    public Foo () {
        new Runnable() {
            public void run () {
                _data.add("hello");
            }
        }.run();
    }

    public static void main (String[] args) throws Exception {
        System.out.println("_data: " + Foo.class.getDeclaredField("_data").getGenericType());
        for (java.lang.reflect.Method m : Foo.class.getDeclaredMethods()) {
            System.out.println(m.getName() + ": " + m.getGenericReturnType());
        }
    }

    private java.util.List<String> _data = new java.util.ArrayList<String>();
}
```
yields as output:
```scala
_data: java.util.List<java.lang.String>
main: void
access$$000: interface java.util.List
```
