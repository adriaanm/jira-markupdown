This modifier could save you from a lot of boilerplate code when you need to cache results of a pure function, very similar to the superb `lazy`.
```scala
memoized def resolveSomething(a: Int, b: Int): String =
  a.toString + b.toString
```
This would generate a code similar to the following:
```scala
private val resolveSomethingCache = collection.mutable.Map[(Int, Int), String]()
def resolveSomething(a: Int, b: Int) =
  try resolveSomethingCache((a, b))
  catch {
    case _ => {
      val result = {
        //  actual implementation relies here:
        a.toString + b.toString
      }
      resolveSomethingCache.update((a, b), result)
      result
    }
  }
```
*Please note that in the implementation above I didn't take multithreading into account.*
