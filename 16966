This modifier could save you from a lot of boilerplate code when you need to cache results of a pure function, very similar to the superb {{lazy}}.
{code}
memoized def resolveSomething(a: Int, b: Int): String =
  a.toString + b.toString
{code}
This would generate a code similar to the following:
{code}
private val resolveSomethingCache = collection.mutable.Map[(Int, Int), String]()
def resolveSomething(a: Int, b: Int) =
  try resolveSomethingCache((a, b))
  catch {
    case _ => {
      val result = {
        //  actual implementation relies here:
        a.toString + b.toString
      }
      resolveSomethingCache.update((a, b), result)
      result
    }
  }
{code}
_Please note that in the implementation above I didn't take multithreading into account._
