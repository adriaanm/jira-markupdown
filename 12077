[~sethtisue] I suppose we could consider it a documentation bug, but it's a really pervasive documentation bug.  The problem is that some mutable builders _are_ sort of reusable after calling `result`, including this very builder.  As long as you haven't filled the internal array everything works swimmingly:

{code}
scala> val a = Array.newBuilder[Int]
a: scala.collection.mutable.ArrayBuilder[Int] = ArrayBuilder.ofInt

scala> val b = { a += 1; a.result }
b: Array[Int] = Array(1)

scala> val c = { a.clear(); a += 2; a.result }
c: Array[Int] = Array(2)

scala> val d = b
d: Array[Int] = Array(1)
{code}

It's just the corner case where the builder returns an array of the right size (and thus doesn't copy) AND has been cleared and reused that we run into any trouble at all.

Unless making this work properly slows things down, I don't see much justification for the occasional disastrous behavior, even if we _do_ improve the documentation to make it really clear that you'd better not reuse builders for immutable collections.

Also, that other mutable builders also give you problems if you try to do this (because they simply return themselves) is only an argument, I think, that we should document those builders very carefully.  In some cases, the API isn't even honored:

{code}
scala> val a = collection.mutable.ListBuffer.newBuilder[Int]
a: scala.collection.mutable.Builder[Int,scala.collection.mutable.ListBuffer[Int]] = scala.collection.mutable.GrowingBuilder@7de752dd

scala> { a += 1; a.clear; a += 2; a.result }
res47: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2)
{code}

My recommendation is to make the library as sane as possible _and_ make the documentation as clear as possible regarding possible trouble spots.  Having hidden corner cases that bite you when you don't strictly adhere to a conservative reading of the docs despite apparent evidence that the desired behavior is maintained is not a nice thing to deliver to users.


