=== Background ===
While trying to weave a simple AspectJ aspect is a Scala compiler jar, 
we got a puzzling error that fails the AspectJ weaver if we use 
Scala version 2.8.1 or 2.9.0-SNAPSHOT, *but not 2.8.0*. 
Upon closer inspection (see below) there appears to be a problem 
due to inconsistent bytecode generated by the Scala compiler.
This not only fails with AspectJ, but also 
*crashes the Eclipse compiler in a plain (non-AspectJ) Java project*.

Here is the analysis based on input from AspectJ project lead Andy Clement.

The issue is with StringBuilder.max (with 2.8.1)

=== What steps will reproduce the problem ? ===
Here is the bytecode generated by the Scala compiler:

{code}
public java.lang.Object max(scala.math.Ordering);
 Code:
  Stack=2, Locals=2, Args_size=2
  0:   aload_0
  1:   aload_1
  2:   invokestatic    SI-1024; //Method
scala/collection/TraversableOnce$$class.max:(Lscala/collection/TraversableOnce;Lscala/math/Ordering;)Ljava/lang/Object;
  5:   areturn
 Signature: length = 0x2
  03 FFFFFFFD
{code} 

So it calls another method then finishes with an ARETURN (i.e.
returning an object, not a primitive).  Now it is generic so we can
lookup the original signature using that attribute, the generic
signature is:
{code}
 <B:Ljava/lang/Object;>(Lscala/math/Ordering<TB;>;)C;
{code}
and that says that the method returns a char (the trailing C), so it
should have been declared 'char max(Ordering)' and finish with an
IRETURN.

Now, the compiler may be being clever and looking for the boxing to a
Character, but it seems odd that the generic signature disagrees
with the bytecode signature in that way.

In Scala 2.8.0 it was not a generic method so there is no mismatch in
signatures.

=== Seeing the problem without involving AspectJ ===
If you want to see the Eclipse compiler crashing,  create a pure java project,
give it a dependency on the 2.8.1 scala library then try to compile
this:

{code}
import scala.collection.mutable.StringBuilder;

public class CC {
       public void m() {
               StringBuilder sb = new StringBuilder();
       }
 }
{code}

Eclipse throws up an error message (an Internal compiler error)
{code}
Internal compiler error: java.lang.ClassCastException: 
org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding cannot be cast to 
org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding at 
org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.initializeTypeVariable(BinaryTypeBinding.java:944)	CC.java	/scala-library-bug/src/bug	
line 0
{code}

I can attach the project if you wish, but as you can see, 
there isn't much needed to get the Eclipse compiler to crash.

=== What versions of the following are you using? ===
  - Scala: 2.8.1 and 2.9.0-SNAPSHOT (2.8.0 works fine)
  - Java: 1.6.0_22
  - Operating system: Mac Snow Leopard
This is extremely helpful, thank you.  I have made alterations such that syntactically invalid signatures can no longer be geneerated, but this is what I was afraid was still out there.  This is important, but right now I don't know how fast I'll be able to get to it.

(See also SI-4067 which I was hoping this would be a duplicate of, but is not.)
The wrong signature is generated for a method that forwards to a trait implementation. Easiest fix would be to leave out the Scala signatures for trait forwarders. You'll get them in any case on the trait interface itself.

(In r24319) Attempt to fix SI-4214 by avoiding signature generation for mixed in and bridge methods.
(In r24344) Reversion of r24319 for causing SI-4291.  Test case to fence out SI-4291
in future attempts.  Closes SI-4291, references SI-4214, no review.
(In r24363) Another lap around the track with generic signatures.
At the root of the issue reported in SI-4214 is our old friend
(fondly remembered from the days of primitive equality)
boxed/primitive unification.

  // scala
  trait T[A] {
    def f(): A
  }
  // the generic signature spec doesn't allow for parameterizing
  // on primitive types, so this cannot remain Char.  However
  // translating it to Character, as was done, also has issues.
  class C extends T[Char] {
    def f(): Char = 'a'
  }

  // Note that neither of the signatures for f, the implementation
  // or the bridge method, matches the type parameter.
  Generic interfaces in class:
    T<java.lang.Character>
  Generic signatures:
    public char C.f()
    public java.lang.Object C.f()

After this commit, primitive type parameters are translated into
Object instead of the boxed type.  It was martin's idea, so no review.
Closes SI-4214.
Replying to [comment:18 ramnivas]:
> I tried this a couple of days back with my original code (weaving AspectJ into Scala). First, I met with an issue that is now resolved in AspectJ nightly. Now I still see a VerifyError in the same place (class: scala/collection/mutable/StringBuilder, method: minBy signature: (Lscala/Function1;Lscala/math/Ordering;)Ljava/lang/Object;)

A couple days back is probably too far, as I was still wrestling this until fairly recently.  Here is what the signature of minBy for instance looks like in the current nightly; I think you will only see the error above if you have an older build.
{code}
scala> classOf[StringBuilder].getMethods.filter(_.getName == "minBy").head.toGenericString
res0: java.lang.String = public <B> char scala.collection.mutable.StringBuilder.minBy(scala.Function1<java.lang.Object, B>,scala.math.Ordering<B>)
{code}
Paul,

I sent you the project. 

I have additional input from the AspectJ lead. Problem still looks like StringBuilder.  The signature of minBy (and similarly maxBy) in the bytecode is:

public Object minBy(scala.Function1 f, scala.math.Ordering cmp)

but the generic signature attribute for it is:

<B:Ljava/lang/Object;>(Lscala/Function1<Ljava/lang/Object;TB;>;Lscala/math/Ordering<TB;>;)C

The trailing 'C' indicating the return type is of type primitive char
- this doesn't match the bytecode return type of Object.

Here is a crude reflection test program - it discovers the bytecode
return type and the generic return type.

{code}
import java.lang.reflect.Method;
import java.lang.reflect.Type;

import scala.collection.mutable.StringBuilder;

public class Main {
       public static void main(String[] args) {
               StringBuilder sb = new StringBuilder();
               Method[] ms = StringBuilder.class.getDeclaredMethods();
               for (Method m : ms) {
                       if (m.getName().equals("minBy")) {
                               Class<?> c = m.getReturnType();
                               System.out.println("Bytecode return type: " + c);
                               Type t = m.getGenericReturnType();
                               System.out.println("Generic return type : " + t);
                               if (t instanceof Class) {
                                       if (((Class) t).isPrimitive() && !c.isPrimitive()) {
                                               System.out.println("Incompatible");
                                       }
                               }
                       }
               }
       }
}
{code}
The following program generates an invalid signature.  It is again the primitive type parameter problem.
{code}
import scala.collection.mutable

object Test {
  def f[A, B] = new mutable.HashMap[A, B] { }
  def g[A] = new mutable.HashMap[A, Int] { }
  def h[A] = new mutable.HashMap[A, Int] { override def default(k: A) = 0 }
}
{code}
Methods f and g are marked bridge as expected.
{code}
public B scala.collection.mutable.HashMap.default(A) (bridge) in Test$$$$anon$$2
public B scala.collection.mutable.HashMap.default(A) (bridge) in Test$$$$anon$$3
{code}
The third class gets these:
{code}
bridge=false public int Test$$$$anon$$3.default(A)
bridge=true  public java.lang.Object Test$$$$anon$$3.default(java.lang.Object)
{code}
But Int is not a valid return type for the non-bridge method, because all code based on HashMap will be looking for an object on the stack.

As far as I can see, there isn't any valid way to implement a generically defined method and have primitives appearing in the signature in type parameter positions.  My only idea (this is what I was talking about at villars) is to implement additional bridges, like:
{code}
public java.lang.Integer Test$$$$anon$$3.default(java.lang.Object)
{code}
But that may be infeasible.

So the signature bombs are still in there.  I found this one in SeqLike.
{code}
private def occCounts[B](sq: Seq[B]): mutable.Map[B, Int] = {
  val occ = new mutable.HashMap[B, Int] { override def default(k: B) = 0 }
  for (y <- sq.seq) occ(y) += 1
  occ
}
{code}

See also SI-4388.
