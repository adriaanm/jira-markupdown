Consider the code:
```scala
trait A extends DelayedInit {
  println("A ConstructionCode")

  def delayedInit(body: => Unit) = {
    body
    postConstructionCode
  }
  protected def postConstructionCode: Unit = {
    println("A PostConstructionCode")
  }
}
trait B extends A {
  println("B ConstructionCode")
  override protected def postConstructionCode: Unit = {
    super.postConstructionCode
    println("B PostConstructionCode")
  }
}

trait C extends B {
  println("C ConstructionCode")
  override protected def postConstructionCode: Unit = {
    super.postConstructionCode
    println("C PostConstructionCode")
  }
}
object Test {
  def main(args: Array[String]) {
    val c = new C {}
  }
}
```
This produces the output:
```scala
A ConstructionCode
B ConstructionCode
C ConstructionCode
```
But when the constructed "C" has a non-empty constructor, such as:
```scala
    val c = new C { println("New C ConstructionCode") }
```
Then the DelayedInit works and generates:
```scala
A ConstructionCode
B ConstructionCode
C ConstructionCode
New C ConstructionCode
A PostConstructionCode
B PostConstructionCode
C PostConstructionCode
```
