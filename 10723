I minimized that down to:
```scala
abstract class InaccessibleType {
  def foo[T, U](implicit ev: Ordering[T])
  def convertTo[T: Ordering]: T = ???

  foo[Long, Double]
  foo
  convertTo[String] // erroneous or inaccessible type
}
```

Scala 2.11 exhibits the same failure from v2.11.0-M2-256-g3f21f00 (the relevent merge from 2.10.x to master that I found using `git what-branch --reference master ef04619`.), until this fix from @hubertp restored reporting of the diverging implicit error: https://github.com/scala/scala/pull/2428

That fix turned out to be so vital, that it was backported to 2.10.x under a forward compatibility flag: https://github.com/dotta/scala/commit/fdead2b3793fd530e05331649e655576f30e59e9
```
scalac-hash v2.10.3 -Xdivergence211 sandbox/test.scala
sandbox/test.scala:7: error: ambiguous implicit values:
 both method Tuple9 in object Ordering of type [T1, T2, T3, T4, T5, T6, T7, T8, T9](implicit ord1: scala.math.Ordering[T1], implicit ord2: scala.math.Ordering[T2], implicit ord3: scala.math.Ordering[T3], implicit ord4: scala.math.Ordering[T4], implicit ord5: scala.math.Ordering[T5], implicit ord6: scala.math.Ordering[T6], implicit ord7: scala.math.Ordering[T7], implicit ord8: scala.math.Ordering[T8], implicit ord9: scala.math.Ordering[T9])scala.math.Ordering[(T1, T2, T3, T4, T5, T6, T7, T8, T9)]
 and object Long in object Ordering of type scala.math.Ordering.Long.type
 match expected type Ordering[T]
  foo
  ^
one error found
```

So I think we can use that flag as a workaround for `sparkle`, and see what other problems arise (ie, why are there ambiguous/diverging implicits now?). It would also be prudent to submit that minimization as a test case to lock down the progression.
