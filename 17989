After migrating from 2.9.2 to 2.10 my team has encountered a runtime {{ClassFormatError}}, which I've managed to reduce to a simple single-file reproduction case which involves a type parameter, type alias and a partial function. The sample is reproduced here ([full code as a gist|https://gist.github.com/holograph/4770065]):

{code}
case class Container( v: String )
 
trait Base[ T <: AnyRef ] {
  type UserType = T
	protected def defect: PartialFunction[ UserType, String ]
}
 
trait Derived extends Base[ Container ] {
  protected def defect = { case c: Container => c.v.toString }
}
 
object Test extends Derived with App {
	println( defect( Container( "8" ) ) )
}
{code}

The generated class file for Derived.defect clearly has duplicate method signatures:

{code}
wanamingo:tmp tomer$ scalap -cp . 'com.tomergabel.examples.Derived$$anonfun$defect$1'
package com.tomergabel.examples;
final class Derived$$anonfun$defect$1 extends scala.runtime.AbstractPartialFunction with scala.Serializable {
  def this(com.tomergabel.examples.Derived): scala.Unit;
  def applyOrElse(scala.Any, scala.Function1): scala.Any;
  def isDefinedAt(scala.Any): scala.Boolean;
  def isDefinedAt(com.tomergabel.examples.Container): scala.Boolean;
  def applyOrElse(scala.Any, scala.Function1): scala.Any;
}
object Derived$$anonfun$defect$1 {
  final val serialVersionUID: scala.Long;
}
{code}

Fortunately this can be worked around by qualifying the derived method with a full return type:

{code}
  protected def defect: PartialFunction[ Container, String ] = { case c: Container => c.v.toString }
{code}
