It changed in 2.10.2, and we didn't expect it to: that's the main problem. 

As per the mail I just sent (which I'll reproduce here for the record), this facet of implicit search isn't specced, so the status quo is the spec. The implementation intends to exclude `e` from the implicit search as it doesn't have an explicit result type, and is defined after the point of the search. But after the change, the "doesn't-have-a-result-type" check fails, as `e`-s symbol has its type elaborated earlier.

I guess as the 2.10.2 guardian, James ought to make a call on what to do. Two questions to answer: 1) leave it or revert it; 2) invest time into pinning down the behaviour with tests or deem it effectively untestable.
```
On Wed, May 22, 2013 at 12:23 AM, Bill Venners <bill@artima.com> wrote:
Seems odd that the compiler would judge this code a forward reference error rather than decide it should look in the companions. If it doesn't find anything in the companions it makes sense it could issue an error that includes a note about the forward reference as a helpful clue, but not if there is something in the companion objects. In that case I'd expect it should use the implicit in the companion.

The way things are specced (which isn't a bible, but also shouldn't be ignored): dsfs
First, eligible are all identifiers x that can be accessed at the point of the method call without a prefix and that denote an implicit definition (§7.1) or an implicit parameter. An eligible identifier may thus be a local name, or a member of an enclosing template, or it may be have been made accessible without a prefix through an import clause (§4.7). If there are no eligible identifiers under this rule, then, second, eligible are also all implicit members of some object that belongs to the implicit scope of the implicit parameter’s type, T . 

A forward reference is still in-scope. Remember, that forward references are allowed in certain circumstances:

scala> def foo { println(x); def foo = 0; def x = "x" }

foo: Unit

scala> foo

x

I won't go into the exact rules here (it's spelled out in Chapter 4 of the Spec, if you're interested). Suffice to say that they are useful for creating mutually recursive sets of local defs or lazy vals.

But, I'm pretty sure we don't want to entangle these forward reference rules with implicit search. Not only is it hard (or maybe impossible) for the compiler to detect the forward reference errors *before* completing the implicit search, but how could someone reading the code reason about it?

As you can see, the implementation already extends beyond the spec in ruling out *potential* forward references that don't have an explicit result type. Why? Well, consider this code:

{

  implicit val y = /*: InferredY */ = { calyY }

  implicit def x /*: InferredX */ = { calcX } 

}

This introduces the possibility of cyclic dependency in the inferred types of x and y. The code the Paul posted attempts to rule that out. But it does so in a fairly fragile way, and the patches I linked have bumped that off kilter. We'll investigate exactly why, but I don't know if it will be a blocker for 2.10.2. I will probably argue in favour of a conservative approach of reverting those commits; but we are still in the untenable position of having compiler behaviour that we can barely write tests for. But such are the pleasures of our job!

In general, you're witnessing the downside of providing an API that essentially requires your users to understand the mechanics of implicit search. An alternative API would not place `Equality.default` in the companion object, and instead you would require users to manually import `Equality.Implicits.default` in places where they really wanted to use default equality.

In the meantime, I would strongly recommend that you annotate the types of your Equality type class, and update your examples and documentation to do the same. In doing so, you will not expose yourself and your users to the esoteric parts of implicit search.

If you want to restrict the scope of an implicit, simply introduce a new scope:

{

  // use Equality.default here

  {

    implicit val customEquality: Equality[A] = (....)

   // use customEquality

  }
```
