Whoops, agreed. (EDIT: maybe we can avoid using function types - but objects are also not type-polymorphic, and changing that makes no sense).

And the obvious fixes require using a method instead of a companion object, at least for the implicit conversion (EDIT: which is the original encoding). I can imagine moving `unapply` to the method instead:
```scala
implicit def Foo = new {
  def apply(x: Int) = new Foo(x)
  def unapply(x: Foo) = ...
}
```
but not only this doesn't work nowadays, I'm not even sure it is a good idea, since `Foo.unapply` could refer to different methods. If that's not a problem, that encoding might be superior, but requires significant changes.

It seems that the only alternative is that the implicit conversion's name is derived in a documented way from the class name, either only for case classes (which preserves compatibility) or also for other classes (which ensures consistency).
