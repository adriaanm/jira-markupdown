I see the problem.

The original issue occurred when using simple case classes, like this:

File project1/Project1.scala
```scala
class Project1
```

File project2/Project2.scala
```scala
class Project2(val project1: Project1)
```

File project3/Project3.scala
```scala
case class Project3(val project2: Project2)
```

The reproduction scenario was done by decompiling the class file for Project3 and then writing the simplest class that would trigger the problem.

I think it is a pity that nothing can be done. It will tie projects closer together than seems to be necessary. Having a very simple case class in one project will expand this project's dependencies to the transitive closure of its direct dependencies (I guess). This is bad news for modularisation in OSGi (at least) as you will have to declare your ''all'' transitive dependencies. Also, generally it is a pity that all your transitive dependencies must be present at compile time.

Would it be possible to loosen up on type inference when a class's transitive dependencies are not present at compile time (like Project1 is not)? In this case the compiler could only infer that the least upper bound of 'project2' and 'null' is 'Any' as it has no access to Project1. Maybe a compiler option could allow this behaviour. I understand that it is problematic as the compiler will the infer different result type depending on this compiler option.

Alternatively, something could maybe be done regarding the code that is implicitly produced when compiling a case class. Something along the lines:
```scala
class Project3(val project2: Project2)  {
  def works = project2
  def fails(b: Boolean) : Project2 = {
    val nullProject2 : Project2 = null
    if (b) project2 else nullProject2
  }
}
```
(Unfortunately, this also does not compile, but I think it should.)
