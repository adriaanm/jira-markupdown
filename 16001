```scala
// Thrilling java class J.java.
package j;

public class J {
  public void f1() { }
  public static void f2() { }
}

// I need to rename it to "JName".  This works, but only a file by
// file basis, and I need to rename it in 2471 places.
import j.{ J => JName }

object Test {
  (new JName).f1()
  JName.f2()
}

// Or I could do this, except I can't (unless J is in scala.)
package object s {
  type JName = j.J
  val JName = j.J
}
// It works if J is a scala object, but if those are java static
// methods we're trying to get at:
//
// s/package.scala:3: error: object J is not a value
//   val JName = j.J
//                 ^
// one error found
```

I take it the problem is that we can't allow the java "object" to be treated as a value because there's no actual value to be had, and the object is just a fiction we use as a way to refer to the static methods.

That's fine, but this seems to conflate two distinct concepts.  I don't need a value: I need a way to refer to the place where the static methods are.  I know scala doesn't have any issue with my referring to that place because it lets me do precisely that when it allows "import j.{ J => JName}", it just makes me redo it all the time.  Can we achieve higher uniformity here?
