I believe this bug is actually in superaccessors, in transformSuperSelect.
```scala
  if (sym.isModule && !sym.isMethod) {
    // the super accessor always needs to be a method. See SI-231
    superAccTpe = PolyType(List(), superAccTpe)
  }
```
It looks like this is being performed even on the pattern itself, but it isn't eliminated in uncurry and a TypeApply tree reaches the pattern matcher where it shouldn't.

I'll take it for now since I don't know who else would, but it won't fight anyone who tries to steal it.
