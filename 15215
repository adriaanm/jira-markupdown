When playing with a function that duplicates a C construct:
```scala
def cfor[@specialized(Int,Long,Double) T](t0: T, c: T => Boolean, s: T => T)(f: T => Unit) {
  var t = t0
  while( c(t) ) {
    f(t)
    t = s(t)
  }
}
```

the REPL uses specialized code if one then does
```scala
var sum = 0
cfor[Int](0, _<1000000000, _+1) { sum += _ }
```

but it seems to produce anti-specialized code (i.e. it is alarmingly slow even for generic code) if one does
```scala
var sum = 0; cfor[Int](0, _<1000000, _+1) { sum += _ }
```

i.e. one puts the captured variable on the same line.

(Incidentally, the "cfor" strategy seems not to work, since as far as I can tell the JVM no longer inlines fully if one uses several different conditionals--but that's a different issue.  I mention it here because that is a separate and much smaller source of slowdown (~10x) that should not be confused with the ~1000x effect seen in this bug.)
