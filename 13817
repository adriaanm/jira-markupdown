```scala
scala> List.separate(List.range(1,100000).map(Left(_)))
java.lang.StackOverflowError
        at scala.List.foldRight(List.scala:1067)
        at scala.List.foldRight(List.scala:1067)
        at scala.List.foldRight(List.scala:1067)
        at scala.List.foldRight(List.scala:1067)
        at scala.List.foldRight(List.scala:1067)
        at scala.List.foldRight(List.scala:1067)
        at scala.List.foldRight(List.scala:1067)
        at scala.List.foldRight(List.scala:1067)
        at scala.List.foldRig...
```

Why is List.separate using foldRight? (Or maybe the question is: why is foldRight implemented using recursion that can lead to stack overflows?) It should probably use the same logic as Iterable.partition. Here's an implementation that would work:
```scala
def separate[A,B](l: List[Either[A,B]]) = {
  val (lefts, rights) = l.partition(_.isLeft)
  (lefts.map(_.left.get), rights.map(_.right.get))
}
```
