I found that scalac infers that synchronized entire an entire method's code means that the method should be synchronized.  On Function0#apply, this means that it synchronizes the apply method.  However, it doesn't synchronize Function0#apply$mcV$sp, presumably thinking that folks will not call that method directly.  However, scalac compiles function invocations down to call that method directly.

This means that methods which are marked synchronized are not really synchronized.

{code}
class Bar(foo: () => Unit) {
  def apply(): Unit = foo()
}

class Foo extends (() => Unit) {
  def apply(): Unit = synchronized {
    println("i'm synchronized!")
  }
}
{code}

javap -c Foo (edited for clarity)

{code}
...
  public synchronized void apply();
    Code:
       0: aload_0
       1: invokevirtual #64                 // Method apply$mcV$sp:()V
       4: return

  public void apply$mcV$sp();
    Code:
       0: getstatic     #70                 // Field scala/Predef$.MODULE$:Lscala/Predef$;
       3: ldc           #72                 // String i'm synchronized!
       5: invokevirtual #76                 // Method scala/Predef$.println:(Ljava/lang/Object;)V
       8: return
{code}

javap -c Bar (edited for clarity)

{code}
  public void apply();
    Code:
       0: aload_0
       1: getfield      #15                 // Field foo:Lscala/Function0;
       4: invokeinterface #20,  1           // InterfaceMethod scala/Function0.apply$mcV$sp:()V
       9: return
{code}
