This is not so easy to fix. The invocation

{code}
newB.m()
{code}

is first transformed by named/default args to

{code}
{ val qual$1 = newB
  qual$1.m(qual$1.m$default$1)
}
{code}

In the method call {{qual$1.m}}, the qualifier tree {{Ident(qual$1)}} is created in {{blockWithQualifier}} using {{gen.mkAttributedRef}} which doesn't assign a {{SingleType}}.

That's why the qualifier has type {{B}} instead of {{SingleType(qual$1)}}. Selecting the {{m}} method therefore has an existential type
{noformat}qual$1.m: (a: A[_1.type])Unit{noformat}

Note that I applied a small change which runs the type-checker on the {{Select}} node, instead of assigning the type directly:

{noformat}
-          val f = Select(gen.mkAttributedRef(sym), selected)
-                   .setType(baseFun1.tpe).setSymbol(baseFun1.symbol)
+          val sel = Select(gen.mkAttributedRef(sym), selected)
+          val f = blockTyper.typedOperator(sel)
{noformat}



Then there's the question why {{qual$1.m$default$1}} also has an existential types, but I guess it's something along the same lines.


Anyway, I'll stop working on this for now, it seems a very cornery case, and there's no deep underlying bad bug, it's due to the singleton {{this.type}}.
