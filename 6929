This is not so easy to fix. The invocation
```scala
newB.m()
```

is first transformed by named/default args to
```scala
{ val qual$1 = newB
  qual$1.m(qual$1.m$default$1)
}
```

In the method call `qual$1.m`, the qualifier tree `Ident(qual$1)` is created in `blockWithQualifier` using `gen.mkAttributedRef` which doesn't assign a `SingleType`.

That's why the qualifier has type `B` instead of `SingleType(qual$1)`. Selecting the `m` method therefore has an existential type
{noformat}qual$1.m: (a: A[_1.type])Unit{noformat}

Note that I applied a small change which runs the type-checker on the `Select` node, instead of assigning the type directly:
```
-          val f = Select(gen.mkAttributedRef(sym), selected)
-                   .setType(baseFun1.tpe).setSymbol(baseFun1.symbol)
+          val sel = Select(gen.mkAttributedRef(sym), selected)
+          val f = blockTyper.typedOperator(sel)
```



Then there's the question why `qual$1.m$default$1` also has an existential types, but I guess it's something along the same lines.


Anyway, I'll stop working on this for now, it seems a very cornery case, and there's no deep underlying bad bug, it's due to the singleton `this.type`.
