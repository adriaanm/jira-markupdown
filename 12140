Thanks for the explanation! Good thinking about the binary compatibility thing, then let's go for annotating in the comments. I will add it to the model and get back to you once I feel like I know what I'm doing.

Just to take what you said and put it in an example:
```scala
package a
 
trait Foo[S] {
  def foo(t: S): Int = 123
}
 
/** Boo hides BooShouldNotAppearIsFoo
 *
 * @hideImplicitConversion BooShouldNotAppearIsFoo
 */
trait Boo[T]
trait ShouldNotAppear
 
object Boo {
  implicit class BooShouldNotAppearIsFoo(boo: Boo[ShouldNotAppear]) extends Foo[ShouldNotAppear]
  implicit class BooLongIsFoo(boo: Boo[Long]) extends Foo[Long]
}
```
