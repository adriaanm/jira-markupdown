I don't see a branch by that name anywhere, sorry.

Since you're poking at value class erasures, you might want to consider this one just for fun. It was brought up at PNW Scala that it would be a lot better if both these methods were specialized. But specialization is about as hip to the value class scene as is erasure.
```scala
class Meter(val m: Double) extends AnyVal

object Test {
  def fn1(f: Meter => Double)(x: Meter): Double = f(x)
  //  0: aload_1
  //  1: new           #16                 // class Meter
  //  4: dup
  //  5: dload_2
  //  6: invokespecial #19                 // Method Meter."<init>":(D)V
  //  9: invokeinterface #25,  2           // InterfaceMethod scala/Function1.apply:(Ljava/lang/Object;)Ljava/lang/Object;
  // 14: invokestatic  #31                 // Method scala/runtime/BoxesRunTime.unboxToDouble:(Ljava/lang/Object;)D
  // 17: dreturn

  def fn2(f: Double => Double)(x: Double): Double = f(x)
  // 0: aload_1
  // 1: dload_2
  // 2: invokeinterface #41,  3           // InterfaceMethod scala/Function1.apply$mcDD$sp:(D)D
  // 7: dreturn
}
```
