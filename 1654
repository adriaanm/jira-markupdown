Ok I found the source of the issue, however I am a little unsure of how to fix it, basically the fragment : PackageFragment used for ScalaCompilationUnit has a multiple packages specified, one for each level of package nesting. Deep down with the code completer, if a compilation unit is specified as having multiple packages it just defaults to take the first package defined.

To see a difference in behaviour between java and scala class put a breakpoint down in:
in the constructor of org.eclipse.jdt.internal.core.JavaElement (line 85)

When a java class is viewed here something like this appears if you look at fragment under the variables view in debug:
{code}
bproblems.javaimportissues [in src [in bproblems]]
  [Working copy] JavaImportIssuesExample.java
    package bproblems.javaimportissues
    class JavaImportIssuesExample
      void food()
{code}

for scala something like this appears:

{code}
bproblems.generics.deeper [in src [in bproblems]]
  [Working copy] SomeDeeperClass.scala
    package bproblems
    package bproblems.generics
    package bproblems.generics.deeper
    class SomeDeeperClass
      SomeDeeperClass()
      int foo()
      int bar()
      int zoo()
      int cat()     
{code}

I am trying to find out where these package fragments come from, once i do hopefully I can submit a patch, if anyone else with better knowledge of the jdt could help me I would appreciate it.
