This code:

{code}
final class WeirdInlining(val i: Int) {
  @inline def t2 = i*2
  @inline def t4 = t2*2
}
{code}

produces this bytecode for {{t2}} and {{t4}} (with {{scalac -optimise}} using 2.8.0.RC1:

{code}
public int t2();
  Code:
   0:	aload_0
   1:	invokevirtual	SI-14; //Method i:()I
   4:	iconst_2
   5:	imul
   6:	ireturn

public int t4();
  Code:
   0:	aload_0
   1:	getfield	SI-11; //Field i:I
   4:	iconst_2
   5:	imul
   6:	iconst_2
   7:	imul
   8:	ireturn
{code}

That is, somehow the one-level inlining fails (in t2, by using invokevirtual insteand of getfield), but the two-level succeeds (in t4)!  2.7.7 optimizes properly; 2.8.0.Beta1-prerelease does the same as RC1.

Perhaps this doesn't matter, since the JVM is more than smart enough to fix this on its own, but it is peculiar.
