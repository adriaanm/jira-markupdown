Miguel, here's the relevant bytecode (with Alex's fix applied):
{code}
Compiled from "check.scala"
public abstract class Inter extends java.lang.Object implements Foo$mcI$sp
public int foo$mcI$sp(int);
  Code:
   Stack=2, Locals=2, Args_size=2
   0:	aload_0
   1:	iload_1
   2:	invokestatic	#11; //Method Foo$class.foo$mcI$sp:(LFoo;I)I
   5:	ireturn

{code}

{code}
Compiled from "check.scala"
public abstract class Foo$class extends java.lang.Object

public static int foo$mcI$sp(Foo, int);
  Code:
   Stack=2, Locals=2, Args_size=2
   0:	aload_0
   1:	iload_1
   2:	invokestatic	#12; //Method scala/runtime/BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer;
   5:	invokeinterface	#18,  2; //InterfaceMethod Foo.foo:(Ljava/lang/Object;)Ljava/lang/Object;
   10:	invokestatic	#22; //Method scala/runtime/BoxesRunTime.unboxToInt:(Ljava/lang/Object;)I
   13:	ireturn
{code}

{code}
Compiled from "check2.scala"
public class Baz extends Inter
public int foo$mcI$sp(int);
  Code:
   Stack=2, Locals=2, Args_size=2
   0:	iload_1
   1:	iconst_1
   2:	iadd
   3:	ireturn
{code}

as you can see Inter just forward to Foo$class that in turns forwards to abstract, specialized method and takes care of boxing and unboxing.

The Baz class overrides specialized implementation and thus avoids boxing. I think this is really what we need.
