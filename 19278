Consider the following program:
```scala
object TestA {
  @inline final val x = 8
}
object TestB {
  def m {
    println(TestA.x)
  }
}
```
Inspecting with `scalac -print` we get what we would expect:
```
package <empty> {
  object TestA extends Object {
    final <stable> <accessor> def x(): Int(8) = 8;
    def <init>(): TestA.type = {
      TestA.super.<init>();
      ()
    }
  };
  object TestB extends Object {
    def m(): Unit = scala.this.Predef.println(scala.Int.box(8));
    def <init>(): TestB.type = {
      TestB.super.<init>();
      ()
    }
  }
}
```


However, explicitly stating the type on Int causes the inliner to fail (which is, quite surprisingly, correct behavior according to the spec [1]). The problem is that no warning is given, and users of the language would reasonably expect the inlining of the constant to continue to happen. Consider the modified example:
```scala
object TestA {
  @inline final val x: Int = 8   // Only this line has changed!
}
object TestB {
  def m {
    println(TestA.x)
  }
}
```
Inspecting with `scalac -print`, or your favorite bytecode disassembler (I've tried `javap` too), we see the problem:
```
package <empty> {
  object TestA extends Object {
    @inline final private[this] val x: Int = _;
    final <stable> <accessor> def x(): Int = TestA.this.x;
    def <init>(): TestA.type = {
      TestA.super.<init>();
      TestA.this.x = 8;
      ()
    }
  };
  object TestB extends Object {
    def m(): Unit = scala.this.Predef.println(scala.Int.box(TestA.x()));
    def <init>(): TestB.type = {
      TestB.super.<init>();
      ()
    }
  }
}
```

When tracing the inliner with the `-Ylog-inliner` option, in the second example that exhibits the bug, there is not even a mention of `TestA.x()`, not even that the inliner tried and gave up!

[1] Section 4.1 of [http://www.scala-lang.org/files/archive/spec/2.11/04-basic-declarations-and-definitions.html].
