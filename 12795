I expected the following code to compile:

{code}
trait Foo {
  type Arg
  type Prod
  def makeProd(a : Arg): Prod
}

// simulate dependent method types
case class buildProd(foo: Foo) {
  def apply(a: foo.Arg): foo.Prod = foo.makeProd(a)
}

object main {
  val myFoo = new Foo{type Arg=Int; type Prod=(Int, Int); def makeProd(i: Int) = (i, i)}
  
  buildProd(myFoo)(1)
}
{code}

Instead, the compiler complains:
{code}
15: error: method apply cannot be accessed in buildProd
 because its instance type (Foo#Arg)Foo#Prod contains a malformed type: Foo#Arg
  buildProd(myFoo)(1)
           ^
one error found
{code}

It seems foo.type gets approximated to Foo too early..
