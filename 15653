As can be seen in decompiled code, compiler is incerting an extra cast to Object[], which simply does not work on JVM.

The example is reduced from a large codebase and does not make much sense beyong demonstrating the problem.
```scala
object Main {
  def mkArray[T <: A](atype: Int) :T#AType = {
    (atype match {
      case 1 =>
        new Array[Int](10)
        // Decompiled code: return (Object[])new intr10;
      case 2 =>
        new Array[Float](10)
    }).asInstanceOf[T#AType]
  }

  def main(args: Array[String]) {
    println(mkArray[I](1))
    //java.lang.ClassCastException: [I cannot be cast to [Ljava.lang.Object;
  }
}

trait A {
  type AType <: AnyRef
}
trait I extends A {
  type AType = Array[Int]
}
trait F extends A {
  type AType = Array[Float]
}
```

Workaround: instead of casting directly ".asInstanceOf[T#AType]", cast to AnyRef first: ".asInstanceOf[AnyRef].asInstanceOf[T#AType]".
