Here is another one.  The icode checker would crash finding an unexpected type on the stack, and I eventually pinpointed that it is calculating strange lubs.  Here is a line from SymbolLoaders:
{code}
sym.setInfo(if (ok) NoType else ErrorType);
{code}
Both NoType and ErrorType have Type as a superclass, so one would expect the type of that expression to be Type.  However when calculating the lub, what it actually calculates is Product.
{code}
Pushing: REFERENCE(scala.tools.nsc.symtab.Types$$NoType)
meet2 created new stack: (List(REFERENCE(scala.tools.nsc.symtab.Types$$NoType)),
List(REFERENCE(scala.tools.nsc.symtab.Types$$ErrorType))) =>
List(REFERENCE(scala.Product))
{code}
The implementation is merely:
{code}
global.lub(t1 :: t2 :: Nil)
{code}
Before erasure the lub shows up as Product with Type.  If I read the spec correctly it's allowed to not order this with the class first; but if that is indeed allowed, there must be some interface which utilizes intersectionDominator in erasure so the right type pops out, because I can't see when "Product" is ever what you'd want.

A seemingly simpler and more direct answer is to organize compound types with the class first all the time.  Maybe there's a reason not to do that.
