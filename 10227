True - though, I'm not sure how we can clear the thunk reference, since a thunk type cannot be a {{var}}..

As for easiness - seems to me it should work.
There is only a single possible update to this cache, and that is {{putIfAbsent}}.
The {{putIfAbsent}} only atomically writes to the cache if the key previously was not there.
That means there is at most one lazy cell value that ends up in the cache.
And {{value}} is only called at the points in the code _after_ it has been atomically ensured that the callee cell is already in the cache.
Thus, the thunk only gets evaluated once, and the {{lazy val}} in {{LazyCell}} is where the blocking synchronization happens.

You could also do a fast path:

{code}
def getOrElseUpdate(k: K, fresh: =>V): V = {
    val cell = tm.lookup(k)
    if (cell != null) cell.value
    else {
      val proposedCell = new LazyCell(fresh)
      val existingCellOpt = tm.putIfAbsent(k, proposedCell)
      if (existingCellOpt.nonEmpty) existingCellOpt.get.value
      else proposedCell.value
    }
  }
{code}

