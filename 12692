To be clear, I don't know the internals of the compiler. But it is my understanding that when I call `1.foo` and the compiler sees that `Int` doesn't have a `foo` method, it will look for an implicit value that conforms to 
```scala
Int => ?{def foo: ?}
```
because it doesn't know anything about the required result type other than that it should have a method called `foo`.
And in the `clone` case, `AnyRef` had a method `def clone(): AnyRef` and also a bunch of other methods, so that makes `AnyRef` a subtype of the structural type that contains only a method `def clone: ?`.

Now aside of that, I think the compiler uses some extra internal mechanisms other than pure basic userfacing implicit search, because
```scala
scala> implicitly[AnyRef <:< Any{def clone: Any}]
<console>:8: error: Cannot prove that AnyRef <:< Any{def clone: Any}.
              implicitly[AnyRef <:< Any{def clone: Any}]
                        ^

scala> implicitly[AnyRef <:< Any{def clone(): Any}]
res1: <:<[AnyRef,Any{def clone(): Any}] = <function1>
```



