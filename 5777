In full

[[syntax trees at end of cleanup]]

{code}
package <empty> {

  class Crash extends java.lang.Object with ScalaObject {

    @volatile private[this] var bitmap$$init$$0: Int = 0;

    def S(op: Function0): Int = 0;

    def A(a: Int, b: Int): Int = 0;

    private[this] val t: Int = _;

    <stable> <accessor> def t(): Int = {
      if (Crash.this.bitmap$$init$$0.&(1).!=(0))
        Crash.this.t
      else
        throw new UninitializedFieldError("Uninitialized field: bt4.scala: 11".toString());
      Crash.this.t
    };

    private[this] val q: Int = _;

    <stable> <accessor> def q(): Int = {
      if (Crash.this.bitmap$$init$$0.&(2).!=(0))
        Crash.this.q
      else
        throw new UninitializedFieldError("Uninitialized field: bt4.scala: 13".toString());
      Crash.this.q
    };

    def this(): Crash = {
      Crash.super.this();
      Crash.this.t = 0;
      Crash.this.bitmap$$init$$0 = Crash.this.bitmap$$init$$0.|(1);
      Crash.this.q = {
        val x$$1: Int = Crash.this.S({
          (new anonymous class Crash$$$$anonfun$$1(Crash.this): Function0)
        });
        val x$$2: Int(0) = 0;
        Crash.this.A(0, x$$1)
      };
      Crash.this.bitmap$$init$$0 = Crash.this.bitmap$$init$$0.|(2);
      ()
    }

  };

  @SerialVersionUID(0) final <synthetic> class Crash$$$$anonfun$$1 extends scala.runtime.AbstractFunction0$$mcD$$sp with Serializable {

    final def apply(): Double = Crash$$$$anonfun$$1.this.apply$$mcD$$sp();

    <specialized> def apply$$mcD$$sp(): Double = {
      val xxx: Int = Crash.this.t();
      42.0
    };

    final <bridge> def apply(): java.lang.Object = scala.Double.box(Crash$$$$anonfun$$1.this.apply());

    def this($$outer: Crash): anonymous class Crash$$$$anonfun$$1 = {
      Crash$$$$anonfun$$1.super.this();
      ()
    }

  }

}

{code}
