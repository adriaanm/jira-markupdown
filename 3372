I have attached source files to reproduce the bug.
Sorry for the sloppyness in the initial ticket !!!

As I said earlyer, none of the four cases below worked in
build scala-2.8.0.r19853-b20091125020156, so someone almost
fixed that area recently.

Here's what the test case does :

{code}
  class C(
    @MyAnnotation(optionType=classOf[Long]) var j: Option[Long],
    @MyAnnotation(optionType=classOf[String]) var k: Option[String],
    @MyAnnotation(optionType=classOf[Date]) var l: Option[Date]) (

    @MyAnnotation(optionType=classOf[Int])
    var i:Option[Int]
  )
    
  def scalaReflectionTests = {
    val colAnotations =
      classOf[C].getDeclaredFields.toList.sortBy(f => f.getName).map(f => f.getAnnotations.toList).flatten

    val t1 = colAnotations.apply(0).asInstanceOf[MyAnnotation].optionType
    val t2 = colAnotations.apply(1).asInstanceOf[MyAnnotation].optionType
    val t3 = colAnotations.apply(2).asInstanceOf[MyAnnotation].optionType
    val t4 = colAnotations.apply(3).asInstanceOf[MyAnnotation].optionType

    // For these the correct type is returned :
    assert(classOf[Int].isAssignableFrom(t1), "expected classOf[Int], got " + t1.getName)
    assert(classOf[Long].isAssignableFrom(t2), "expected classOf[Long], got " + t2.getName)
    assert(classOf[Date].isAssignableFrom(t4), "expected classOf[Date], got " + t4.getName)

    // classOf[String] does not, the fact that it works for Date means that it is not
    // related to reference types, String is treated as a special case somewhere. 
    assert(classOf[String].isAssignableFrom(t3), "expected classOf[String], got " + t3.getName)
  }
{code}
