Processing a {{Stream}} using its {{withFilter}} method evaluates one more element than necessary. When processing a {{Stream}} using the {{filter}} method, only the necessary elements are evaluated.

Having a simple {{Stream}} of natural numbers:
{code:scala}
def naturals: Stream[Int] = {
   def loop(i: Int): Stream[Int] = {
      println(s"evaluate $i")
      i #:: loop(i + 1)
   }


   loop(1)
}
{code}

Calling {{map}} on a {{Stream}} filtered using {{filter}} vs. {{withFilter}} produces the same result, however, {{withFilter}} evaluates one more element:
{code:scala}
scala> naturals filter(_ % 2 == 0) map(x => x) 
evaluate 1
evaluate 2
res1: scala.collection.immutable.Stream[Int] = Stream(2, ?)

scala> naturals withFilter(_ % 2 == 0) map(x => x)
evaluate 1
evaluate 2
evaluate 3 // this one is eagerly evaluated even though we do not need it
res2: scala.collection.immutable.Stream[Int] = Steam(2, ?)
{code}

The behaviour is caused by a call to {{tail}} in [StreamWithFilter.map|https://github.com/scala/scala/blob/v2.11.5/src/library/scala/collection/immutable/Stream.scala#L539] and the same problem is in {{flatMap}}.

This is a bug, because the semantics of using {{filter}} and {{withFilter}} should be the same; {{withFilter}} should be only an optimization.  Moreover, the right behaviour is that of the {{filter}} because the {{Stream}} operations should be as lazy as possible and in this case there is no reason to evaluate the next element.

As a possible use case where the current behaviour of {{withFilter}} manifests as a bug consider the following: having a possibly endless stream of attempts to transactionally perform some computation, try to commit it and if the commit is not successful, perform the transaction anew with new current snapshot of data.
{code:scala}
val transAttempts = for {
   trans <- currentTransactionSnapshotStream
   trans.x.increment
   trans.y.decrement
   result = trans.x
   trans.commit
   if (trans.successfullyCommitted)
} yield result

val transactionResult = transAttempts.head
{code}

The above code will use {{withFilter}} and possibly perform and commit two times. The expected behaviour is that the transaction would be performed and attempted to commit only until it successfully commits the first time.
