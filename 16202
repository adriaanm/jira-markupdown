{code:java|title=IBaseInterface.java}
public interface IBaseInterface<T> { 
    void f(T t); 
}
{code}

{code:java|title=IDerivedInterface.java}
public interface IDerivedInterface extends IBaseInterface<Class> { 
    void g(Class c); 
}
{code}

{code:scala|title=Problem.scala}
object Problem { 
  def a(i:IDerivedInterface) = i.f(classOf[String]) // error!
  def b(i:IDerivedInterface) = i.g(classOf[String]) 
}
{code}

{code}
problem.scala:2: error: type mismatch;
 found   : Class[_$1] where type _$1
 required: java.lang.Class
  def a(i:IDerivedInterface) = i.f(classOf[String].asInstanceOf[Class[_]]) 
{code}

Notice the required type 'java.lang.Class', which should be transformed to an existential type when seen from IDerivedInterface. The compiler does the correct thing for the method g, which is not inherited.
