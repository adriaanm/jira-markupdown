I tried replacing `scala.concurrent.util.FuturePromise` with one that accesses `sun.misc.Unsafe.compareAndSwapObject()` officially via `AtomicReferenceFieldUpdater`, rather than unofficially via `scala.concurrent.util.Unsafe`, and that works fine in the App Engine development server:
```
package scala.concurrent.impl;

import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

public abstract class AbstractPromise {
	protected final static AtomicReferenceFieldUpdater<AbstractPromise, Object> updater = AtomicReferenceFieldUpdater
			.newUpdater(AbstractPromise.class, Object.class, "_ref");

	private volatile Object _ref;

	protected final Object getState() {
		return _ref;
	}

	protected final boolean updateState(Object oldState, Object newState) {
		return updater.compareAndSet(this, oldState, newState);
	}
}
```

Presumably the current code is a micro-optimisation that makes a noticeable difference even after Hotspot has inlined all the method calls. It would be nice if Scala could fall back to the standard Java API instead of raising `java.lang.ExceptionInInitializerError` when the internal Java classes are not accessible.
