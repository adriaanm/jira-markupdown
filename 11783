Page 116, chapter *Implicit Parameters and Conversions* , *View Bounds* subchapter 

{code:language=scala}
def sort[A <% Ordered[A]](xs: List[A]): List[A] =
  if (xs.isEmpty || xs.tail.isEmpty) xs
  else {
    val {ys, zs} = xs.splitAt(xs.length / 2)
    merge(ys, zs)
  }
```scala

The construct didn't compile with Scala 2.11 and I've replaced it with :
{code:language=scala}
def sort[A <% Ordered[A]](xs: List[A]): List[A] =
    if (xs.isEmpty || xs.tail.isEmpty) xs
    else {
      val (ys, zs) = xs.splitAt(xs.length / 2)
      merge(ys, zs)
    }
```

Moreover, it seems that the view bounds are deprecated as of Scala 2.11
scala/bug#7629

The sort sample out of which this example makes part of doesn't compile when using *implicit* keyword. This is due to the fact that the implicit  *int2ordered* function is causing ambiguity for the compiler because it provides the same functionality as the LowPriorityImplicits#intWrapper function.


I've slightly modified the sample code like this :

{code:language=scala}
  type OrderedView[A] = A => Ordered[A]

  def sort[A: OrderedView](xs: List[A]): List[A] =
    if (xs.isEmpty || xs.tail.isEmpty) xs
    else {
      val (ys, zs) = xs.splitAt(xs.length / 2)
      merge(ys, zs)
    }

  def merge[A: OrderedView](xs: List[A], ys: List[A]): List[A] =
    if (xs.isEmpty) ys
    else if (ys.isEmpty) xs
    else if (xs.head < ys.head) xs.head :: merge(xs.tail, ys)
    else ys.head :: merge(xs, ys.tail)

  implicit def num2ordered(x: Num): Ordered[Num] = new Ordered[Num] {
    override def compare(y: Num): Int =
      if (x.value < y.value) -1
      else if (x.value > y.value) 1
      else 0
  }
}

case class Num(value: Int)  {
  override def toString: String = value.toString
}
```scala

Sample code that uses the code above :

{code:language=scala}
def main(args: Array[String]) {
    val xs = List(new Num(1), new Num(4), new Num(2), new Num(6),new Num(3))
    val sortedXs = sort(xs)(num2ordered)
    print(sortedXs.mkString(","))
  }
```
