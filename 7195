Why should {{Seq}} know about {{List}}? But when you call the {{Seq.apply}} factory, you get a {{List}}, and we don't stress out over what other implementations of {{Seq}} exist. True, it's not a perfect analogy, as {{List}} doesn't appear in the signature, but I think there's a principle at work here that allows for some classes knowing about the existence of certain of their subclasses. At a conceptual level, I see {{orderingToPartialOrdering}} as a type-class-level factory that provides implicit instances of one particular type sub-class, and yes the signature makes the literal code a little leaky but that's just a necessary artifact of how implicits work.

In any case, the issue I most care about is the practical outcome: in the default implicit scope there are no instances of `PartialOrdering`, but lots of instances of `Ordering`, which leads me and others to consider using `Ordering` in my context bounds even when a `PartialOrdering` would suffice. So an `orderingToPartialOrdering` view would help with that; so would putting all of the type class instances on the type argument companions (except for the `String` problem you point out); so would defining an `Orderings` trait, putting all the definitions on that, and having both the `Ordering` and `PartialOrdering` companions extend `Orderings`. Probably there are one or two more creative solutions I haven't thought of. I just think it's a shame to have these nice mathematical type classes floating around in the standard library, one of which is artificially inconvenient to use because the most common instances are all defined on one particular subclass.
