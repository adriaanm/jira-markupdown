I was coming to report this and see it's already open.  I would add that it's not clear to me it's a programming mistake: if an abstract class declares a method signatures and an implementing class has exactly one which matches but with an undeclared return type, should it not easily infer the return type?

Either way, the error message is incredibly unhelpful in terms of indicating what has to happen for it to compile.  If you don't already know what's up, you will be head scratching.  

Here is my example, which I enclose because it is somewhat different: the "private class" in question is private not by virtue of an access modifier but because it's a member of  a constructor parameter.  In trunk as of r20562 if you make these changes:

{code}
// add these two lines to MarkupParserCommon
  type ElementType
  def mkProcInstr(position: PositionType): ElementType  

// add these two to MarkupParsers after line 71
    type ElementType = Tree
    def mkProcInstr(position: Position) = handle.procInstr(position, "", "")
{code}
And we get:
{code}
[scalacfork] /scratch/trunk2/src/compiler/scala/tools/nsc/ast/parser/MarkupParsers.scala:74: error: private value parser escapes its defining scope as part of type MarkupParser.this.parser.symbXMLBuilder.global.Tree
[scalacfork]     def mkProcInstr(position: Position) = handle.procInstr(position, "", "")
[scalacfork]         ^
{code}
Define mkProcInstr with return type Tree, and all is well.
