Replying to [comment:13 washburn]:
> Replying to [comment:11 cbordelo]:
> 
> > Actually I dont agree that the compiler needs to treat implicit conversions of Nothing and => Nothing the same way. There is a big difference in these two as the scala Actor library and my library shows. The by-name Nothing is advertising some later computation that via a conversion could be wrapped inside an object via an implicit conversion.
> 
> You can disagree that 1 + 1 should be 2 as well, but that doesn't change the fact that the language cannot be consistent if implicits distinguished between T and => T.  The correct way to advertise that it is returning a "computation" is to actually have it return a "Computation" type.  Returning Nothing is advertising that it **DOES NOT RETURN**.  Furthermore, if Scala treated Nothing correctly to begin with, an implicit conversion would never be applicable because all projections and method calls should already succeed on the Nothing type.  
> 
> 
> > And if you look at scala Actor libray, the react method returns Nothing type so there is precedent for it and obvious usefulness for it. It does more than signal to the user that the method does not return. The compiler checks that code following a react method is in error, something that i want checked to prevent bugs.
> > If you try using the Actor library with loopWhile and andThen you'll know what I'm talking about. 
> 
> Well, if I look at the actor's library I see loopWhile and andThen are implemented without implicit conversions on Nothing.  So it does not really support your argument.
> 
> And if you use a proper "Computation" type the compiler will also report type mismatches for you as well.  So again, using Nothing gains you nothing.  You need to learn to use the type system to your advantage and using Nothing does not properly describe your intent.

Well of course the actors library could not have implicit conversions on => Nothing, when the compiler wont compile it.

The actors lib authors would have wanted the mkBody implicit conversion to have worked with this one but as you see it doesn't for the same reason as this ticket.

scala> Actor.actor { import Actor._; react { case _ => } andThen { 0 } }
<console>:9: error: value andThen is not a member of Nothing
       Actor.actor { import Actor._; react { case _ => } andThen { 0 } }

So, if you want the implicit conversion you have to wrap the react in something that will accept Nothing but return something else like Unit. And it just so happens that the mkBody implicit conversion will be applied on => Unit type (and probably most any type different than Nothing, => Nothing, etc).

ok, Here I'll create the simplest wrapper (simpler than loop, loopWhile in actor library as these have other side effects):

scala> def bar(b: => Unit):Unit = b
bar: (=> Unit)Unit

then i get the implicit conversion I wanted all along with bar wrapping the react.

scala> Actor.actor { import Actor._; bar {react { case _ => }} andThen { 0 }}
res7: scala.actors.Actor = scala.actors.Actor$$$$anon$$1@144426c

The point is that one should not have to trick the compiler and "wrap" the Nothing to some other type so as to get a by-Name implicit conversion.
And via the "bar" function you can see that I did get the actors by-name implicit conversion to occur on the "Nothing" result of react.


Finally my use of Nothing is with the same intent as the actors library, so your advice if it made sense would also apply to the Scala actors library authors who have made thorough use of Nothing as a return type.
In my case I wanted to improve the type checking some more and instead of many of the => Unit paramters, I thought => Nothing would better check/describe my need.
