The core problem is that SBT, by deafault, has scala-library.jar in a parent classloader of the application classes.

When we deserialize a List, we go through custom deserizalization code in object:

{code}
    // Java serialization calls this before readResolve during de-serialization.
    // Read the whole list and store it in `orig`.
    private def readObject(in: ObjectInputStream) {
      val builder = List.newBuilder[A]
      while (true) in.readObject match {
        case ListSerializeEnd =>
          orig = builder.result()
          return
        case a =>
          builder += a.asInstanceOf[A]
      }
    }
{code}

The `ObjectInputStream` provided by the JVM here internally resolves classes with the classloader the owner of closest enclosing method in the call stack. This is handled in `ObjectInputStream#resolveClass`.

{code}
protected Class<?> resolveClass(ObjectStreamClass desc)
	throws IOException, ClassNotFoundException
    {
	String name = desc.getName();
	try {
	    return Class.forName(name, false, latestUserDefinedLoader());
	} catch (ClassNotFoundException ex) {
	    Class cl = (Class) primClasses.get(name);
	    if (cl != null) {
		return cl;
	    } else {
		throw ex;
	    }
	}
    }
{code}

This ticket against OpenJDK suggests that this behaviour is buggy and instead the current thread's context class loader should be used. But the response is that the current behaviour is as specified.
https://bugs.openjdk.java.net/browse/JDK-4340158

Here's a further minimization:

{code}
// src/test/scala/issue/Meh.scala
class Meh
{code}

{code}
// src/test/scala/issue/Main.scala
package issue

import java.io.{ObjectOutputStream, ObjectInputStream, ByteArrayOutputStream, ByteArrayInputStream}

object Test {
  def main(args: Array[String]): Unit = {
    val obj = List(new Meh)
    val arr = serialize(obj)
    val obj2 = deserialize[List[Meh]](arr)
    assert(obj == obj2)
  }

  def serialize[A](obj: A): Array[Byte] = {
    val o = new ByteArrayOutputStream()
    val os = new ObjectOutputStream(o)
    os.writeObject(obj)
    o.toByteArray()
  }

  def deserialize[A](bytes: Array[Byte]): A = {
    val s = new ByteArrayInputStream(bytes)
    val is = new ObjectInputStream(s)
    is.readObject().asInstanceOf[A]
  }
}
{code}

I'm not sure if we can do anything to fix this in our custom serialization code. I would appreciate ideas from serialization experts.
