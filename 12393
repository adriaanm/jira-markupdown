would you agree this illustrates the same issue, but with less code?
```
class W[T <: AnyRef](val f: T) {
  type F = f.type
  type SelfW = W[T] { type F = W.this.F }
  def error(w: SelfW) = w.f: w.F
}

S.scala:4: error: type mismatch;
 found   : w.f.type (with underlying type T)
 required: w.F
    (which expands to)  W.this.f.type
  def error(w: SelfW) = w.f: w.F
                          ^
one error found
```

