Hi Paul,

I beg to disagree. Java generates different class names for the closest Java equivalent to my program I can come up with, namely:
{code}
interface Function1 {
    int apply(int x);
}

class Main {
    static Function1 succ() {
        return new Function1() { public int apply(int x) { return x + 1; } };
    }

    static Function1 Succ() {
        return new Function1() { public int apply(int x) { return x + 1; } };
    }

    public static void main(String[] args) {
        System.out.println(succ().apply(20) + Succ().apply(20));
    }
}
{code}

Here, javac names the first anonymous class {{Main$$1}} and the second {{Main$$2}}. It used to be the same with scalac, but I remember some discussion with Sean (McDirmid) who didn't like that behaviour, because (IIRC) it made it hard to identify the piece of source code that led to the creation of a given "anonymous" class. The scalac behavior was then changed to the current one, but it has the problem illustrated in my original report.

I think a naming scheme that mixes the current one (based on the name of enclosing entities) and the javac one (based on numbering) could solve the problem.

I still consider this to be a bug, but maybe I misunderstood what you mean by "The identical issue exists in Java". In fact, I cannot imagine a legal Java program leading to a problem similar to the one discussed here. I would be very happy if you could clarify what you mean by giving an example.

Thanks,
Michel.
