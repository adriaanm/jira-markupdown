Now the method withFilter of scala.collection.immutable.Stream is defined in scala.collection.TraversableLike. This lead to some problemsï¼š
{code}
scala> val nums = Stream.from(1)
nums: scala.collection.immutable.Stream[Int] = Stream(1, ?)

scala> val even = for(n <- nums if n%2 == 0) yield n
java.lang.OutOfMemoryError: Java heap space
        at scala.collection.TraversableOnce$$class.toList(TraversableOnce.scala:393)
        at scala.collection.mutable.WrappedArray.toList(WrappedArray.scala:25)
        at scala.collection.immutable.List$$.apply(List.scala:448)
        at scala.collection.mutable.LazyBuilder.$$plus$$eq(LazyBuilder.scala:24)
        at scala.collection.mutable.LazyBuilder.$$plus$$eq(LazyBuilder.scala:21)
        at scala.collection.TraversableLike$$WithFilter$$$$anonfun$$map$$2.apply(TraversableLike.scala:775)
        at scala.collection.immutable.Stream.foreach(Stream.scala:195)
        at scala.collection.TraversableLike$$WithFilter.map(TraversableLike.scala:774)
        at .<init>(<console>:6)
        at .<clinit>(<console>)
        at RequestResult$$.<init>(<console>:9)
        at RequestResult$$.<clinit>(<console>)
        at RequestResult$$scala_repl_resul...
scala>
{code}

I think we should override withFilter in Stream like following(not test):

{code}
abstract class Stream[+A] extends LinearSeq[A] 
                             with GenericTraversableTemplate[A, Stream]
                             with LinearSeqOptimized[A, Stream[A]] {
self =>
  ...
  
  final override def withFilter(p: A => Boolean): WithFilter = new StreamFilter(p)
  
  class StreamFilter(p: A => Boolean) extends WithFilter(p) {
  
    def map[B, That](f: A => B)(implicit bf: CanBuildFrom[Repr, B, That]): That = 
      (if(isEmpty) Stream.Empty
	   else if(p(head)) new Stream.Cons(f(head), tail.withFilter(p).map(f).asInstanceOf[Stream[B]])
       else tail.withFilter(p).map(f).asInstanceOf[Stream[B]]
	  ).asInstanceOf[That]
	
    def flatMap[B, That](f: A => Traversable[B])(implicit bf: CanBuildFrom[Repr, B, That]): That = 
	  (if(isEmpty) Stream.Empty
       else if(p(head)) f(head).toStream append tail.withFilter(p).flatMap(f).asInstanceOf[Stream[B]]
	   else tail.withFilter(p).flatMap(f).asInstanceOf[Stream[B]]
	  ).asInstanceOf[That]
 
    def foreach[U](f: A => U): Unit = 
      for (x <- self) 
        if (p(x)) f(x)

    def withFilter(q: A => Boolean): WithFilter = 
      new StreamFilter(x => p(x) && q(x))
  }
}
{code}
