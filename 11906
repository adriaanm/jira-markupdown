Quick answer to whether it should be synchronized: no, as far as I can see.

Long answer:
I didn't check what gets generated, but if the following accessor is generated:
```scala
  // generated accesssor:
  // public attr()LOuter$attr$ = {
  //   if (attr$module == null) attr$lzycompute()
  //   else attr$module
  // }
```

and at the same time, the `attr$module` field is not volatile, then the lazy accessors for nested objects are not thread-safe -- it is possible that some thread reads a non-{{null}} `attr$module` reference to a nested object whose constructor did not yet complete (because the statements inside the `synchronized` block can be reordered with the constructor body of singleton object).

This bug could manifest itself:
a) during concurrent access to {{Outer}}'s {{attr}} field
b) possibly during serialization if the reference to the `Outer` object somehow escapes to another thread

So, to fix this bug, the accessor method does not need to be synchronized.
However, the long-term fix should be to make `attr$module` volatile:
- this, along with the existing `synchronized` in `attr$lzycompute` fix the problem (a)
- if you also care about `Outer` object reference escaping to another thread, this should also fix (b), as far as I can see
