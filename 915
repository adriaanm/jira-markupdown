Let me push back once; I won't make a big todo over this, though I'd really like this to work.

My use case is fairly simple: I want to make an almost perfectly transparent way of distributing tasks over the network for scientific computing. MapReduce, if you will.
{code}
val nums = distributor.distribute(Range(0 to 1000));
nums.map{x * 200}.reduce{_+_}; // reduce because we need full associativity from the operator.
{code}

The only thing blocking this library is this change, or a reasonable work around. I'd really like to avoid having to say "new SerializableFunction{ def apply(x : Param) = /*...*/ } when Scala just needs this one thing. 

As for safety, a class marked serializable can only be serialized if all of its members can be serialized (and so on down the heirarchy) thanks to the JVM's runtime checks. Automatically attaching @serializable to closures would in no way effect the safety of operations, and only closures that included fully serializable members would be serializable anyway, which is what the static check is attempting to do. That is, anything your check would catch is caught by the JVM anyway, and as it stands, it's blocking otherwise perfectly serializable functions from being serialized.

Regarding the safety:
{code}
class A;
@serializable class B(val a:A);

object C {
  def main(args:Array[String]) {
    import java.io._;

    val out = new ObjectOutputStream(new FileOutputStream("foo"));
    out.writeObject(new B(new A));
    out.close();
  }
}
{code}

Compiling and running this code yields:

{code}
java.io.NotSerializableException: A
        at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1156)
{code}

I can't think of a single instance where undesired behavior would occur if the check in place were removed and replaced with a pass. Moreover, the current check  stops code that statically cannot be shown to be serializable, but is in fact serializable, from being serialized, but the error signaling this failure still occurs at runtime. In other words, the static check doesn't seem to actually statically guarantee me anything useful.

Perhaps I'm wrong, but it seems like this couldn't reasonably pose any problems in the JVM. If I'm wrong, is the only workaround for me to force users to use the Java-like syntax of new SerializableFunction[A,B] { def apply(x : A):B = { } }? Dare I ask for a compiler flag?[[BR]]
