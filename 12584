Looks like an oversight in the implementation to me. `Typer::preSelectOverloaded` is responsible for filtering out alternatives based on arity (also based on the "shape type" of function literal arguments), but this is bypassed in this case.
```scala
      def preSelectOverloaded(fun: Tree): Tree = {
        if (fun.hasSymbolField && fun.symbol.isOverloaded) {
```

We have:
```
fun = A.this.f[Int] / TypeApply(Select(...., f), TypeTree(Int))
fun.hasSymbolField = false
fun.tpe = OverloadedType((f: Any => Int, v: Int)Unit <and> (f: Any => Int)Unit)
fun.fun.symbol.info = [T](f: Any => T, v: Int)Unit <and> (f: Any => T)Unit
```

After filtering, we can end up with a new symbol: either a single method symbol, or a new overloaded symbol with fewer alternatives. This needs to be assigned back to the tree `fun`. We can't just assign

The fix is conceptually easy enough ("generalize that code a little!") but there are a lot of details to line up. I took a hacky attempt at it : https://github.com/scala/scala/compare/2.12.x...retronym:ticket/10074?expand=1

but I'm not planning to pursue this right now.
