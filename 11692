Here's another simpler repro that shows the same underlying problem. Notice the unwanted SAM.

{noformat}
% cat sandbox/test.scala
trait Sam { def apply(): Unit }
abstract class Test {
  def foo(): Sam
  val f: Sam = foo /* no parens */
}

% qscalac -Xprint:typer sandbox/test.scala
[[syntax trees at end of                     typer]] // test.scala
package <empty> {
  abstract trait Sam extends scala.AnyRef {
    def apply(): Unit
  };
  abstract class Test extends scala.AnyRef {
    def <init>(): Test = {
      Test.super.<init>();
      ()
    };
    def foo(): Sam;
    private[this] val f: Sam = Test.this.foo();
    <stable> <accessor> def f: Sam = Test.this.f
  }
}

% qscalac -Xprint:typer -Xexperimental sandbox/test.scala
[[syntax trees at end of                     typer]] // test.scala
package <empty> {
  abstract trait Sam extends scala.AnyRef {
    def apply(): Unit
  };
  abstract class Test extends scala.AnyRef {
    def <init>(): Test = {
      Test.super.<init>();
      ()
    };
    def foo(): Sam;
    private[this] val f: Sam = {
      {
        def apply$body(): Unit = {
          Test.this.foo();
          ()
        };
        @SerialVersionUID(value = 0) final class $anonfun extends AnyRef with Sam with Serializable {
          def <init>(): <$anon: Sam> = {
            $anonfun.super.<init>();
            ()
          };
          final override <synthetic> def apply(): Unit = apply$body()
        };
        new $anonfun()
      }
    };
    <stable> <accessor> def f: Sam = Test.this.f
  }
}
{noformat}

In a context that does not allow a method type, when typechecking an expression like `qual.foo` where `foo` is a method with a single, empty parameter list, the compiler tries, in order:
  - eta expansion, if the expected type if a function type (or a SAM under -Xexperimental)
  - applying the expression to an empty parameter list

In these examples, we don't get to the second measure.

Here's a analagous situation with plain-old-functions:

{code}
object Test {
  def foo(): () => String = () => ""
  val f: () => Any = foo

  def main(args: Array[String]): Unit = {
    println(f()) // <function0>
  }
}
{code}

So even though SAMs are behaving consistently with functions, they introduce a pretty subtle source incompatibility.

I've updated the bug title to reflect the essence of the problem. I'll leave it to [~apm] to craft a puzzler around this.
