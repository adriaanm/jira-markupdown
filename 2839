to make this more concrete, consider this (edited!) debugging output:
```scala
typing implicit with undetermined type params: List(type Repr1, type El1, type Repr2, type El2)  
tree: Test.this.MyTuple2.apply[Array[Int], Array[Int]](Test.this.as, Test.this.as).zipped[Repr1, El1, Repr2, El2]

typed impl?? conformsOrViewsAs:[A,B](implicit evidence$$1: Function1[A,B]) Predef.<%<[A,B] 
   ==> Predef.<%<.conformsOrViewsAs 
   with pt = Predef.<%<[Array[Int],collection.this.TraversableLike[El1,Repr1]], 
     wildpt = Predef.<%<[Array[Int],collection.this.TraversableLike[?,?]]

typed implicit Predef.<%<.conformsOrViewsAs:[A, B](implicit evidence$$1: Function1[A,B]) Predef.<%<[A,B], 
   pt = Predef.<%<[Array[Int], collection.this.TraversableLike[?,?]]

typing implicit with undetermined type params: List(type B)
tree: Predef.<%<.conformsOrViewsAs[Array[Int], B]
```

I think it would be better if the undetermined type param `B` in the last two lines would track the constraint `B <: Collection.this.TraversableLike[?El1, ?Repr1]` (where these are type variables introduced when typing the top-level implicit)


test code (+predef is modified to move <:< and conforms to LowestPriorityImplicits):
```scala
import scala.collection.{TraversableLike, IterableLike}

object Test {
  case class MyTuple2[+T1, +T2](_1:T1, _2:T2) {
    def zipped[Repr1, El1, Repr2, El2](implicit w1: T1 <%< TraversableLike[El1, Repr1], w2: T2 <%< IterableLike[El2, Repr2]): Zipped[Repr1, El1, Repr2, El2] = new Zipped[Repr1, El1, Repr2, El2](_1, _2)
    class Zipped[+Repr1, +El1, +Repr2, +El2](coll1: TraversableLike[El1, Repr1], coll2: IterableLike[El2, Repr2])
  }

  val as = Array(1, 2, 3)
  MyTuple2(as, as) zipped
}
```
