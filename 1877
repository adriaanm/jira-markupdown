Thank you for pointing out that both getter and setter must be defined in the same class for code to compile. Here is a workaround based on that.

{code}
object Main {
    def main(args: Array[String]) = {
        val m = new Mutable()
        m.a += 10
        m.b += 10 // WORKS
    }
}

abstract class Abstract {
    var a = 0;
    def b = a;
}

class Mutable extends Abstract {
    override def b = a // makes it work
    def b_=(v: Int) { this.a = v }
}
{code}

My take on the language specification �4.2.
(I am merely presenting my logic on the subject matter in a straight-forward fashion, please consider it as a constructive argument rather than criticism).

{code}
A variable declaration var x : T is equivalent to declarations of a getter function x
and a setter function x _=, deﬁned as follows:
def x : T
def x _= ( y : T ): Unit
{code}
This simply states that variable declaration is equivalent to declaration of a getter and a setter. There are no restriction placed, specifically there is no "getter and setter must be in the same class" restriction.
{code}
An implementation of a class containing variable declarations may deﬁne these
variables using variable deﬁnitions, or it may deﬁne setter and getter functions di-
rectly.
{code}
This paragraph merely elaborates on the equivalence definition. It states how implementations MAY define a var. The verb MAY is non-restrictive and does not cover all the options, this verb merely hints on the possibilities (e.g.: I may go for a walk, or I may go see a movie. However I may just stay home and watch tv).
If the restriction "getter and setter must be in the same class" was intended, the specification would explicitly say: "An implementation of a class containing variable declarations may deﬁne these variables using variable deﬁnitions, or it MUST deﬁne setter and getter functions directly."

May and must are not interchangeable in general, however in your interpretation, you are clearly rewriting may into must: "The specification is not completely clear, but can be read to say that both setter and getter must be defined in the same class..."

By similar logic, the sentence
{code}
This long and boring proof may be right.
{code}
can be turned into
{code}
This long and boring proof must be right.
{code}
A change with very clear consequences.

Since may is non-restrictive, when another option appears, then the original definition must be used to handle such option. So we should consider
{code}
A variable declaration var x : T is equivalent to declarations of a getter function x
and a setter function x _=, deﬁned as follows:
def x : T
def x _= ( y : T ): Unit
{code}
In the code to reproduce the problem both getter and setter are declared and defined. So misbehaviour of += must be a bug.

Granted, this can be a minor bug with a time-consuming fix. However an improvement would not require a change in specifications.
