Many months later, I still think this should be changed.  In response to the first comment from Donna, this behavior has EVERYTHING to do with the change to takeWhile.  While I'm sure the change was intended to tackle performance issues, it clearly changed behavior of takeWhile on BufferedIterator.

{code:java}

// enrich wrapper to give original functionality
class EnrichedIterator[T](it: Iterator[T]) {
  def takeWhileOriginal(p: T=>Boolean) = {
    val self = it.buffered
    new Iterator[T] {
      def hasNext = { self.hasNext && p(self.head) }
      def next() = (if (hasNext) self else Iterator.empty).next()
    }
  }
}
implicit def enrichIterator[T](it: Iterator[T]) = new EnrichedIterator(it)
{code}

With the original takeWhile.

{code:java}
scala> val x = List(1,2,3,4,5,6,7).iterator.buffered
x: java.lang.Object with scala.collection.BufferedIterator[Int] = non-empty iterator

scala> x.takeWhileOriginal(_<5).toList
res2: List[Int] = List(1, 2, 3, 4)

scala> x.next
res3: Int = 5
{code}

With the new takeWhile.

{code:java}
scala> val x = List(1,2,3,4,5,6,7).iterator.buffered
x: java.lang.Object with scala.collection.BufferedIterator[Int] = non-empty iterator

scala> x.takeWhile(_<5).toList
res6: List[Int] = List(1, 2, 3, 4)

scala> x.next
res7: Int = 6
{code}
