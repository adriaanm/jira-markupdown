The problem with `==` is that you can't distinguish it from a `Boolean` expression which is totally valid, too. Of course, the difference is that `isSeek` is an argument name. So this produces the same confusion as with catching symbols versus backtick escaping, e.g.
```scala
val isSeek: Boolean = ???

def m(a: Any) = a match {
  case Advance(t = time, { println("hi there"); false == isSeek }) => ...
}
```

To use the value, you would need to write `false == `isSeek``

Here is another suggestion, using the left-arrow from for-comprehensions:
```scala
case Advance(t <- time, false <- isSeek)

case Person(LegalToDrink(a) <- age)
case Person(ltd @ LegalToDrink(a) <- age)
case Person(ltd: LegalToDrink <- age)
```

The advantage of this IMO is that it doesn't introduce any new syntactic concept or variant, but is well established. On the other hand, in for-comprehensions the left-arrow indicates that the symbol is a looping variable, something that is not the case here.

-----

A third suggestion would be to require guards for `==`. Something like
```scala
    case Advance(t <- time) if !isSeek =>
```

One would then be free to use `=` instead of `<-`, e.g.
```scala
case Advance(t = time) if !isSeek =>

case Advance(val t = time) if !isSeek =>
```
