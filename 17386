For all functions {{f}} and {{g}},
{code}Success(a) map { f compose g }{code}
should produce the same result as
{code}Success(a) map g map f{code}

However, in the following example:
{code}
def divideByZero(a: Int): Int = a / 0
def numberOrDefault(a: => Int): Int =
  try a catch { case _: ArithmeticException => 42 }
{code}
the property we want is not satisfied:
{code}
Success(1) map { numberOrDefault compose divideByZero } === Success(42)
Success(1) map divideByZero map NumberOrDefault === Failure(ArithmeticException)
{code}

In order to satisfy the functor composition law in the above case, we need something like the following implementation for {{Failure.map}}:
{code}def map[U](f: T => U): Try[U] = Try[U](f(throw exception)){code}

This allows the possibility of going from a {{Failure}} to a {{Success}}, which is correct if {{Try}} is attempting to mimic the semantics of exception handling.

*EDIT:* The same can be said for {{Failure.flatMap}}, by the way. It should also be possible for the function passed to {{flatMap}} to catch the contained exception and produce a {{Success}}, as above.
