after fixing SI-513, pos/bug1001 failed -- it turns out there was another bug hiding under SI-513's shroud 

This test case is derived from pos/bug1001, and may also be related to scala/bug#1159
```scala
class A 
trait B[T <: B[T]] extends A
class C extends B[C]
class D extends B[D]

class Data { 
  // force computing lub of C and D
  val data: List[A] = List(new C, new D)    // inferred existential type does not meet T's bound B[T]
}
```

output with printLubs enabled: 
```scala
lub of List(D, C) at depth 2
  lub of List(D, C) at depth 1
    lub of List(D, C) at depth 0
    lub of List(D, C) is A
  lub of List(D, C) is B[_1] forSome { type _1 >: D with C <: A }
lub of List(D, C) is B[_2] forSome { type _2 >: D with C{} <: B[_1] forSome { type _1 >: D with C{} <: A } }
```

clearly,  `_2` in `B[_2] forSome { type _2 >: D with C{} <: B[_1] forSome { type _1 >: D with C{} <: A } }` is not a subtype of `B[_2]`

I don't know how to fix this more constructively but to detect f-bounded type params in  `mergePrefixAndArgs` and pretend `depth == 0`:
```scala
  def mergePrefixAndArgs(tps: List[Type], variance: Int, depth: Int): Option[Type] = tps match { // ...
    case TypeRef(_, sym, _) :: rest =>
//...
      val args = List.map2(sym.typeParams, List.transpose(argss)) {
        (tparam, as) =>
          if (depth == 0 || (tparam.info.bounds contains tparam)) //@M can't deal with f-bounds
```
