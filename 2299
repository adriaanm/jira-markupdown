If you send the `"how many?"` messages synchronously (`countActor !? "how many?"`), i.e., waiting for a reply after each of those, then you get the 334 output also outside the REPL. Arguably, this behavior is correct in the context of asynchronous messaging: only when waiting for a reaction before continuing to send further messages can you tell how many messages the receiver sees in its mailbox.

The important point (*) is this: if all messages are sent asynchronously, the sender is never able to tell at which point the receiver decides to process the messages in its mailbox. Depending on the time when the receiver processes its messages, it sees a different number of them.

This is where the different observed behavior comes from: in trunk (2.8) the receiver may not immediately check whether it can process an incoming message, since that checking task is submitted to a thread pool, and may thus run after the sender has sent additional messages. The main reason for this change is that it allows to shield the sender from any exceptions being thrown while doing the matching in the receiver. This change was introduced based on feedback from the use of actors in lift. Doing the message matching on the sender's thread could lead to exceptions propagating from the receiver to the sender in unexpected ways. What's more, it could lead to deadlocks if there are locks acquired during the matching (e.g., using pattern guards). Note that the order in which messages sent from the same actor are processed is unaffected by this change. This means the receiver continues to process the messages in the same order they were sent.

Another important point is that even in the implementation of 2.7.x, a third actor that sends messages to the same receiver could cause the receiver to see a non-deterministic number of messages in the mailbox, since the two senders run asynchronously.

Because of the point (*) I mentioned above, a sender should never depend on the number of asynchronous messages that have arrived in the receiver's mailbox before the receiver processes a message. If the sender wants to be sure the receiver did not receive another asynchronous message from the sender, it should wait for a reply.

Therefore, I think that the above example exposes an implementation detail that a client should not depend upon. Asynchronous messaging simply __is fundamentally different__ from synchronous messaging. If you want a synchronous reaction, use a synchronous send.
