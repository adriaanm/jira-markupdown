(comment by extempore):

This is induced by the use of a type constructor as a bound. Much simplified:
```scala

// J.java
public class J<T> {
  public static void f(java.lang.Class<? extends J> cls) { }
  // correctly it should be like this, and then it would work.
  // unfortunately that doesn't mean we don't have to deal with it.
  // public static void f(java.lang.Class<? extends J<?>> cls) { }
}
// S.scala
class S extends J[AnyRef]

object Test {    
  def main(args:Array[String]) {
    J.f(classOf[S])
  }
}
```


This results in:
```scala

S.scala:5: error: type mismatch;
 found   : java.lang.Class[S](classOf[S])
 required: java.lang.Class[_ <: J]
    J.f(classOf[S])
               ^
one error found
```


I don't immediately see how to work around it from the scala side alone, because scala is picky about how we express these things.
```scala

// nope
J.f(classOf[S]: Class[_ <: J[_]])

S.scala:5: error: type mismatch;
 found   : Class[_$1(in method main)] where type _$1(in method main) <: J[_]
 required: java.lang.Class[_ <: J]
    J.f(classOf[S]: Class[_ <: J[_]])
                  ^
one error found

// nope
J.f(classOf[S]: Class[J[_]])

S.scala:5: error: type mismatch;
 found   : java.lang.Class[S](classOf[S])
 required: Class[J[_]]
Note: S <: J[_] (and java.lang.Class[S](classOf[S]) <: java.lang.Class[S]), but Java-defined class Class is invariant in type T.
You may wish to investigate a wildcard type such as `_ <: J[_]`. (SLS 3.2.10)
    J.f(classOf[S]: Class[J[_]])
               ^
one error found

// naturally, nope
J.f(classOf[S]: Class[J])

S.scala:5: error: class J takes type parameters
    J.f(classOf[S]: Class[J])
                          ^
one error found
```
