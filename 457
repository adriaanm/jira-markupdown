I disagree.  I would rather fix the semantics.

The HashMap has to be parameterized with a reference type, so
in the hash are java.lang.Integer's, but on the way back, I'm
pretty sure the null is being passed through to {{unboxToInt}}
in scala.runtime.BoxesRunTime:

    public static int unboxToInt(Object i) {
        return i == null ? 0 : ((Integer)i).intValue();
    }

I tested checking out trunk and changing that 0 to 123 and getting
a null returned 123 :)

I think in this case you would want to Scala be smart enough not to
take the Integer back to a primitive int, especially since it's being
compared to a null.

The workaround is to explicitly use java.lang.Integer's, at least for the
hash value:

{code}
scala> val foo = new java.util.HashMap[Int, Integer]
foo: java.util.HashMap[Int,Integer] = {}

scala> foo.get(0) == null
res0: Boolean = true
{code}

As an aside, I don't like the idea of null Int's, nor any of the other
integer, boolean, floating poing types magically being converted to 0's.
I think you just have to be aware of those conversions with nulls.  I
like the idea of having {{unboxToInt}} throwing an exception.
