minimized:

{code}
class Test {
  def foo(id: Int = 1, p: Int)

  def test() {
    val x = foo(p = 2)
    val id = x + 1
  }
}
{code}

gives 

{noformat}
A.scala:7: error: recursive value x needs type
    val id = x + 1  // !!! reports: recursive value x needs type
             ^
A.scala:5: warning: type-checking the invocation of method foo checks if the named argument expression 'id = ...' is a valid assignment
in the current scope. The resulting type inference error (see above) can be fixed by providing an explicit type in the local definition for id.
    val x = foo(p = 2)
            ^
one warning found
one error found
{noformat}

Unfortunately, the warning message doesn't say that the "named argument expression 'id = ...'" was generated by the compiler and is not visible in the source code.
