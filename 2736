I fixed the pattern matcher not to depend on the behavior, but I think putting the require in is a mistake.  First of all, if we're going to do it to drop we should do it to take as well, and either way it will draw in other methods implemented in terms of drop such as slice.  There is a test case called slices.scala which explicitly depends on negative indices working, using tests like this:
```scala
  println(List(1, 2, 3, 4).slice(-1, 1))
  println(List(1, 2, 3, 4).slice(1, -1))
  println(List(1, 2, 3, 4).slice(-2, 2))
```
And drop and take are implemented in many many locations other than List specifically, so this needs to reach down all the way to Traversable.  It represents a definitely breaking change which cannot be indicated via an annotation and where failure doesn't manifest until runtime, and doing it consistently requires altering every collections class in this way.

As usual I'm fine with breaking things, but not without some comprehensive vision behind it.  If we are going to force failure for negative indices anywhere, then every method which utilizes indices needs to be considered at the least.

Separately: why does List implement take and drop at all? What is true about "List" which is specialized beyond what is true of "LinearSeq" that would warrant reimplementing those methods (and any number of others)? If the reasons are only historical then now is a good time to do some trimming.
