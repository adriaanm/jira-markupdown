Given the following test code:
{code}
trait a {
  object foo {
    def bar = List(1,2).map(_*2)
  }
}

trait b {
  object foo {
    def bar = List(1,2).map(_*2)
  }
  class foo { }
}
{code}

...the generated bytecode for a$$foo$$ contains references to the non-existent a$$foo, as does the anon function generated for the map.  In the case of b (which defines a class of the same name as the object) the references incorrectly point to the class instead of the object.  This can be seen by way of reflection:

{code}
scala> Class.forName("a$$foo$$").getDeclaredClasses
res0: Array[java.lang.Class[_]] = Array()
scala> Class.forName("a$$foo").getDeclaredClasses
java.lang.ClassNotFoundException: a$$foo

scala> Class.forName("b$$foo$$").getDeclaredClasses
res1: Array[java.lang.Class[_]] = Array()
scala> Class.forName("b$$foo").getDeclaredClasses 
res2: Array[java.lang.Class[_]] = Array(class b$$foo$$$$anonfun$$bar$$2)
{code}

I came across this attempting to use proguard on the scala jars. It objects to processing them because of inconsistent InnerClasses attributes due to the above issue - for instance there are references to the non-existent class scala/tools/nsc/symtab/Definitions$$definitions .
