Imagine you have an expression 'e' of type W[Bar], and there is also a class X defined with type W[Foo].  If you match 'e', you will get warnings that there is no case clause for type X-- even though 'e' couldn't possible be an instance of X, as W[Foo] is not a subtype of W[Bar].  In fact, if you attempt to add a case clause for type X, you will get an error because the compiler (correctly) identifies that this case is impossible.

Example code below:
```scala
  sealed trait Foo
  sealed trait Bar extends Foo
  sealed trait W[T >: Bar <: Foo]
  sealed case class X() extends W[Foo]
  sealed case class Y() extends W[Bar]
  sealed case class Z[T >: Bar <: Foo](
    z1: W[T]
  ) extends W[T]

  object Main {
    def func(w: W[Bar]): Int = {
      w match {
        // Error if I include it, warning if I do not!
        // case X() => 2
        case Y() => 1
        case Z(z) => func(z)
      }
    }
  }
```
