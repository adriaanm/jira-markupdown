Yeah, I'd definitely like to solve these with restrictions. We have to watch out for classes that the compiler creates in there as well as ones the user does.

{code}
class C(a: Any)
object F {
  def byname(a: => Any) = println(a)
  def hof(a: () => Any) = println(a())
}

// java.lang.NullPointerException
//   at O1$$anonfun$$init$$1.apply(<console>:11)
//
// The thunk's apply method accesses the MODULE$
// field before it is set.
//
//   0: getstatic #23; //Field O1$.MODULE$:LO1$;
//   3: invokevirtual #26; //Method O1$.O1$$x$1:()Ljava/lang/String;
object O1 extends C({
  def x = "".toString
  F.byname(x)
})

// java.lang.NullPointerException
//   at O2$$anonfun$$init$$1.apply(<console>:11)
object O2 extends C({
  lazy val x = "".toString
  F.byname(x)
})

// java.lang.NullPointerException
//   at O3$$anonfun$$init$$1.apply(<console>:11)
object O3 extends C({
  def x = "".toString
  F.hof(() => x)
})

// java.lang.VerifyError: (class: O5$, method: <init> signature: ()V) Expecting to find object/array on stack
object O4 extends C({
  object Nested
  Nested
})


// Okay, the nested classes don't get an outer pointer passed,
// just an extra param for `x: String`.
object O6 extends C({
  val x = "".toString
  F.byname(x); F.hof(() => x); (new { val xx = x }.xx)
})


// no-symbol does not have an owner
//   ...
//   at scala.tools.nsc.transform.ExplicitOuter$OuterPathTransformer.outerSelect(ExplicitOuter.scala:229)
class C1 extends C({
  def x = "".toString
  F.byname(x)
})
class C2 extends C({
  lazy val x = "".toString
  F.byname(x)
})
class C3 extends C({
  def x = "".toString
  F.hof(() => x)
})
class C4 extends C({
  def x = "".toString
  object Nested { def xx = x}
  Nested.xx
})

// java.lang.VerifyError: (class: C5, method: <init> signature: ()V) Expecting to find object/array on stack
class C5 extends C({
  def x = "".toString
  val y = {
    object Nested { def xx = x}
    Nested.xx
  }
})

// okay, for same reason as O6
class C6 extends C({
  val x = "".toString
  F.byname(x); F.hof(() => x); (new { val xx = x }.xx)
})


{code}
