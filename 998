The parser phase output for I.java as interface and abstract class give a clue (using scalac 2.10.1) - note the abstract class has no type forwarder for the enum:

Interface:
```scala
[[syntax trees at end of                    parser]] // I.java
package <empty> {
  private[<empty>] object I extends  {
    def <init>() = _;
    object E extends  {
      def <init>() = _;
      <stable> <static> val E1: E = _;
      <static> def values(): scala.Array[E] = _;
      <static> def valueOf(x: String): E = _
    };
    <static> class E extends _root_.java.lang.Enum[E] {
      import E._;
      def <init>() = _
    }
  };
  abstract private[<empty>] trait I extends _root_.java.lang.Object {
    import I._;
    def <init>() = _;
    protected type E = I.E
  }
}
```

Abstract class:
```scala
[[syntax trees at end of                    parser]] // I.java
package <empty> {
  private[<empty>] object I extends  {
    def <init>() = _;
    object E extends  {
      def <init>() = _;
      <stable> <static> val E1: E = _;
      <static> def values(): scala.Array[E] = _;
      <static> def valueOf(x: String): E = _
    };
    <static> class E extends _root_.java.lang.Enum[E] {
      import E._;
      def <init>() = _
    }
  };
  abstract private[<empty>] class I extends _root_.java.lang.Object {
    import I._;
    def <init>() = _
  }
}
```
