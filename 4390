here's my working hypothesis:
```scala
class Dep(x: Int)(implicit val nameClash: String)

object Test extends Application {
  implicit val nameClash: String = "meh"

  def meth(implicit w: String) = 1

  // when typing Meh's default constructor Meh.this.nameClash (inherited from Dep)
  // shadows Test.nameClash, thus, when inferring the argument `w` in the call to meth,
  // Test.nameClash is not eligible statically, Meh.this.nameClash is picked (which then causes the VerifyError)
  // BUG: Meth.this.nameClash should not be in (the implicit) scope during the super constructor call in the first place
  class Meh extends Dep(meth) 
  /*
    class Meh extends Dep {
      def this() {
        this(Test.this.meth(Meh.this.nameClash))(Test.this.nameClash)
      }
    }
  */
  
  new Meh
}
```

thus, when in a constructor of the class C, and moreover in a context that is enclosed by the self/super constructor call of that constructor,  the members of C are not in scope and the **outer** of the class C is the next outer (its implicits are also in scope here)

this leads to the following pearl:
```scala
val nextOuter = if (owner.isConstructor) (if(enclInSelfSuperCall) outer.outer.outer.outer else outer.outer.outer) else outer
```

since the only decent numbers are 0 and 1, I propose we encapsulate `outer.outer.outer` into something more descriptive -- but what?
