When a null value is cast as a Java collection, and an implicit converter from `scala.collection.convert.WrapAsScala` is in scope, the converter will be passed null and return a wrapped collection with null as the underlying collection. Calling any bridge method provided by the wrapper will result in a `NullPointerException`. This can cause unexpected behavior in an application that relies on interacting with a wrapper collection, but does not have access to the underlying java reference in order to determine whether it is a collection or null. In this scenario, the application gets the collection wrapper via whatever means, and tries to operate upon it - thus generating a somewhat counter-intuitive exception.

An example of this issue in the wild can be seen at [scalafx issue #178](https://github.com/scalafx/scalafx/issues/178), and an example of code that generates such a wrapper [before the issue was fixed](https://github.com/scalafx/scalafx/blob/ad60d5faee687b71d3c0474510d3f3dd081ea351/scalafx/src/main/scala/scalafx/stage/FileChooser.scala#L138).
Added a [test suite](https://github.com/RomanHargrave/scala/commit/a72853eea534fe210c6a252ec8617eeb46a66aad) to demonstrate null conversion bug.
I have opened [pr #4266](https://github.com/scala/scala/pull/4266), which fixes this issue.
The previous PR had some problems with jenkins, so I have closed it and opened [#4267](https://github.com/scala/scala/pull/4267) in its place.
