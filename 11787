Here's what I see from that method:

{code}
      def AdaptTypeError(tree: Tree, found: Type, req: Type) = {
        // SI-3971 unwrapping to the outermost Apply helps prevent confusion with the
        // error message point.
        def callee = {
          def unwrap(t: Tree): Tree = t match {
            case Apply(app: Apply, _) => unwrap(app)
            case _                    => t
          }
          unwrap(tree)
        }

        // If the expected type is a refinement type, and the found type is a refinement or an anon
        // class, we can greatly improve the error message by retyping the tree to recover the actual
        // members present, then display along with the expected members. This is done here because
        // this is the last point where we still have access to the original tree, rather than just
        // the found/req types.
        val foundType: Type = req.dealiasWiden match {
          case RefinedType(parents, decls) if !decls.isEmpty && found.typeSymbol.isAnonOrRefinementClass =>
            val retyped    = typed (tree.duplicate.clearType())
            val foundDecls = retyped.tpe.decls filter (sym => !sym.isConstructor && !sym.isSynthetic)
            if (foundDecls.isEmpty || (found.typeSymbol eq NoSymbol)) found
            else {
              // The members arrive marked private, presumably because there was no
              // expected type and so they're considered members of an anon class.
              foundDecls foreach (_.makePublic)
              // TODO: if any of the found parents match up with required parents after normalization,
              // print the error so that they match. The major beneficiary there would be
              // java.lang.Object vs. AnyRef.
              refinedType(found.parents, found.typeSymbol.owner, foundDecls, tree.pos)
            }
          case _ =>
            found
        }
        assert(!foundType.isErroneous && !req.isErroneous, (foundType, req))

        issueNormalTypeError(callee, withAddendum(callee.pos)(typeErrorMsg(foundType, req)))
        infer.explainTypes(foundType, req)
      }
{code}

{noformat}
% qscalac -Xprint:jvm /Users/jason/code/scala3/src/compiler/scala/tools/nsc/typechecker/ContextErrors.scala | grep --context=100 'def AdaptTypeError'
{noformat}
{code}
...
      def AdaptTypeError(tree: reflect.internal.Trees$Tree, found: reflect.internal.Types$Type, req: reflect.internal.Types$Type): Unit = {
        val foundType: reflect.internal.Types$Type = {
          case <synthetic> val x1: reflect.internal.Types$Type = req.dealiasWiden();
          case5(){
            if (x1.$isInstanceOf[reflect.internal.Types$RefinedType]())
              {
                <synthetic> val x2: reflect.internal.Types$RefinedType = (x1.$asInstanceOf[reflect.internal.Types$RefinedType](): reflect.internal.Types$RefinedType);
                {
                  val decls: reflect.internal.Scopes$Scope = x2.decls();
                  if (decls.isEmpty().unary_!().&&(found.typeSymbol().isAnonOrRefinementClass()))
                    matchEnd4({
                      val retyped: reflect.internal.Trees$Tree = ContextErrors$TyperContextErrors$TyperErrorGen.this.$outer.typed(tree.duplicate().clearType());
                      val foundDecls: reflect.internal.Scopes$Scope = retyped.tpe().decls().filter({
                        (new <$anon: Function1>(ContextErrors$TyperContextErrors$TyperErrorGen.this): Function1)
                      });
                      if (foundDecls.isEmpty().||(found.typeSymbol().eq(ContextErrors$TyperContextErrors$TyperErrorGen.this.$outer.$outer().$asInstanceOf[tools.nsc.typechecker.Analyzer]().global().NoSymbol())))
                        found
                      else
                        {
                          foundDecls.foreach({
                            (new <$anon: Function1>(ContextErrors$TyperContextErrors$TyperErrorGen.this): Function1)
                          });
                          ContextErrors$TyperContextErrors$TyperErrorGen.this.$outer.$outer().$asInstanceOf[tools.nsc.typechecker.Analyzer]().global().refinedType(found.parents(), found.typeSymbol().owner(), foundDecls, tree.pos())
                        }
                    })
                  else
                    case6()
                }
              }
            else
              case6()
          };
          case6(){
            matchEnd4(found)
          };
          matchEnd4(x: reflect.internal.Types$Type){
            x
          }
        };
        ContextErrors$TyperContextErrors$TyperErrorGen.this.$outer.$outer().$asInstanceOf[tools.nsc.typechecker.Analyzer]().global().assert(foundType.isErroneous().unary_!().&&(req.isErroneous().unary_!()), {
          (new <$anon: Function0>(ContextErrors$TyperContextErrors$TyperErrorGen.this, req, foundType): Function0)
        });
        ContextErrors$TyperContextErrors$TyperErrorGen.this.$outer.$outer().ErrorUtils().issueNormalTypeError(ContextErrors$TyperContextErrors$TyperErrorGen.this.callee$1(tree), ContextErrors$TyperContextErrors$TyperErrorGen.this.$outer.$outer().$asInstanceOf[tools.nsc.typechecker.TypeDiagnostics]().withAddendum(ContextErrors$TyperContextErrors$TyperErrorGen.this.callee$1(tree).pos()).apply(ContextErrors$TyperContextErrors$TyperErrorGen.this.$outer.$outer().ErrorUtils().typeErrorMsg(foundType, req)).$asInstanceOf[String](), ContextErrors$TyperContextErrors$TyperErrorGen.this.contextTyperErrorGen());
        ContextErrors$TyperContextErrors$TyperErrorGen.this.$outer.infer().explainTypes(foundType, req)
      };
{code}
