For certain inputs, the result of Iterator.span, followed by toSeq and toList, is wrong. If span is directly followed by toList, everything is fine.
```scala
def spanA(list: List[Int], x: Int) =
  list.iterator.span(_ == x) match {
    case (a,b) => (a.toList, b.toList)
  }

def spanB(list: List[Int], x: Int) =
  list.iterator.span(_ == x) match {
    case (a,b) => (a.toSeq, b.toSeq) match {
      case (a,b) => (a.toList, b.toList)
    }
  }

println("A1: " + spanA(List(1, 2, 3), 1) )
println("B1: " + spanB(List(1, 2, 3), 1) )

println()

println("A2: " + spanA(List(1, 2, 1), 1) )
println("B2: " + spanB(List(1, 2, 1), 1) )
```

results in
```scala
A1: (List(1),List(2, 3))
B1: (List(1),List(2, 3))

A2: (List(1),List(2, 1))
B2: (List(1, 1),List(2))
```

Interestingly, the misbehaviour only seems to occur here when the last element of the input list equals the first, even though the span operation should never even look at the last element in these example cases.
