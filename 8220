I've come up with a similarly puzzling case without inheritance.

{code}
class Foo[@specialized(Int) A] {
  def foo[@specialized(Int) B](f: Function2[B, A, B])(b: B, a: A): B = f(b, a)
}

class Bar[@specialized(Int) A] {
  val aFoo = new Foo[A]
  def fun(a: A, b: A): A = a
  def bar(a: A, b: A): A = aFoo.foo(fun)(a, b)
}
{code}

In the byte code, do I understand correctly that the foo invocation (invokevirtual #43) is invoking the non-specialized Foo class's (specialized) method? My profiling reveals boxing & unboxing.

{code}
public class Bar$mcI$sp extends Bar<java.lang.Object> {
  public final Foo<java.lang.Object> aFoo$mcI$sp;

  public int bar$mcI$sp(int, int);
    Code:
       0: aload_0       
       1: invokevirtual #31                 // Method aFoo:()LFoo;
       4: new           #33                 // class Bar$mcI$sp$$anonfun$bar$mcI$sp$1
       7: dup           
       8: aload_0       
       9: invokespecial #37                 // Method Bar$mcI$sp$$anonfun$bar$mcI$sp$1."<init>":(LBar$mcI$sp;)V
      12: iload_1       
      13: iload_2       
      14: invokevirtual #43                 // Method Foo.foo$mIcI$sp:(Lscala/Function2;II)I
      17: ireturn       
}
{code}

This is certainly undesirable, but is it somehow necessary?
