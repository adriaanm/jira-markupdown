I can't remember if I've opened this; I don't see it.

Even without leaking via dealiasing and widening, we fail to recognize subtypes. The third category of camouflage is the upper bounds of abstract types.  This one will be harder to fix.
{code}
trait A {
  val x: java.lang.Object
  type A2 <: x.type
  val y2: A2

  val q = (y2: x.type)        // fails
  val q2 = ((y2: A2): x.type) // works
}
{code}
