I try to do the performance test with this code
```scala
class ScalaColls(n: Int) {
	val a = Array.fill(n)(new Object)
	
	def f(x: AnyRef) = x ne null
		
	def withForEach = {
		var b = false
		a.foreach(f)
	}
	
	def withWhile = {
		var i = 0;
		var b = false;
		while(i < n) {
			b = f(a(i))
			i += 1
		}
	}
}
```

and I found that 'withForEach' method works 8-10 times slower than 'withWhile'. If we look inside IndexedSeqOptimied we see
```scala
  override /*IterableLike*/
  def foreach[U](f: A =>  U): Unit = {
    var i = 0
    val len = length
    while (i < len) { f(this(i)); i += 1 }
  }
```

It seems 'foreach' and 'while-loop solution' would have just the same performance but they don't. Probably it's caused by wrong compilation IndexedSeqOptimized for Arrays that's using some Array-wrapper in byte-code instead of plain java-array.

By the way 'withWhile' has just the same speed as similar method written in Java. It means Scala and Java byte-codes are just the same for them. They must be just the same for all Array's seq-like methods too. Ten times is a great performance hit that can force a programer to use while-loop solutions instead of functional ones.
