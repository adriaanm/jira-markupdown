After thinking about this some more, I think our conclusion from yesterday's discussion was wrong. The crucial point is that an object's singleton type should not be violated, and while Slick does that at the moment and it is also used in the code example above, it is only a tangent. I don't see a good reason why the **implementation** of an object should not be cloned as long as the clone does not pretend to have the same singleton type as the original. Here is a modified example without the unsoundness of the original one:
```scala
object ObjectIdentityTest {
   def main(args: Array[String]) { new ObjectIdentityTest() }

   abstract class Base extends Cloneable {
     override def clone(): Base = super.clone().asInstanceOf[Base]
     def foo = { println("  hashCode = "+this.hashCode()); true }
     def bar: Unit
   }

   object A extends Base { def bar = List(1).filter(_ => foo) }
}

class ObjectIdentityTest {
   import ObjectIdentityTest._

   println("Original A:")
   A.foo
   A.bar

   val clonedA = A.clone()
   println("Cloned A:")
   clonedA.foo
   clonedA.bar
}
```
