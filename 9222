aka "a bridge too far".

{noformat}
[log erasure] computing bridges for anonymous class $anonfun
[log erasure(->explicitouter)] overriding-pairs? method applyOrElse matches method applyOrElse in trait PartialFunction ([A1 <: <empty>.this.Container, B1 >: lang.this.String](<param> <synthetic> <triedcooking> x1: A1, <param> <synthetic> default: scala.this.Function1[A1,B1])B1/class scala.reflect.internal.Types$PolyType vs. [A1 <: <empty>.this.Container, B1 >: lang.this.String](<param> x: A1, <param> default: scala.this.Function1[A1,B1])B1/class scala.reflect.internal.Types$PolyType) == true
[log erasure] generating bridge from method applyOrElse (<method> final override <bridge>): (<param> x: Object, <param> default: Function1)Object in trait PartialFunction to method applyOrElse: (<param> <synthetic> <triedcooking> x1: Container, <param> <synthetic> default: Function1)Object
[log erasure] overriding-pairs? method isDefinedAt matches method isDefinedAt in trait PartialFunction ((<param> <synthetic> <triedcooking> x1: <empty>.this.Container)scala.this.Boolean/class scala.reflect.internal.Types$MethodType vs. (<param> x: <empty>.this.Container)scala.this.Boolean/class scala.reflect.internal.Types$MethodType) == true
{noformat}
