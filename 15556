Summary: I think  Map[_,_]#Inner should be equivalent to x3 rather than an error.
```scala
object Test {
  class Map[T1, T2] {
    class Inner
  }
  def f[T1, T2] = { val m = new Map[T1, T2] ; new m.Inner }
  
  // fails - is seen as something like
  // Map[t1, t2] forSome { type t1 ; type t2; } # Inner
  var x1: Map[_,_]#Inner = f[String, Int]
  // error: unbound wildcard type
  //   var x1: Map[_,_]#Inner = null
  
  // syntactically valid, but doesn't do what one probably wants
  var x2: Map[t1 forSome { type t1 }, t2 forSome { type t2 }]#Inner = f[String, Int]
  // error: type mismatch;
  //  found   : Test.Map[String,Int]#Inner
  //  required: Test.Map[t1 forSome { type t1 },t2 forSome { type t2 }]#Inner
  //   var x2: Map[t1 forSome { type t1 }, t2 forSome { type t2 }]#Inner = f[String, Int]
  
  // Winner?
  var x3: Map[t1, t2]#Inner forSome { type t1 ; type t2; } = f[String, Int]
}
```
