{code}
object A {
  class A {
    def foo = 1
  }
  class B {
    def foo = 2
  }

  class Z {
    implicit def i2a(i: Int): A = new A

    def foo(x: Int) = 123
  }

  class G {
    implicit def i2b(i: Int): B = new B

    def foo(x: Int) = 124
  }

  object G extends Z
  object K extends G

  import K._
  import G._

  123.foo

  foo(11)
}
{code}

Here two example describing this problem. It's implicit overloading resolution bug and ordinary overloading resolution. However problem is similar, so let's describe problem for method foo.

Method foo is defined in class G and in class Z. Class G has companion object, which is inherited from Z. So according to SLS 6.26.3 class G is derived from class Z. So in terms of relative weight method foo in class G must be more specific than method foo in class Z.

I can imagine that compiler calculates relative weight for foo in object K and object G, then any of them is not derived other one. However my vision of word "defined" is that method 'foo' is written in some class, because it's perfectly works in the following case:
{code}
class B {
  class A
  class B extends A
  class C {
    def foo(x: B) = 1
  }
  class D extends C {
    def foo(x: A) = 2
  }

  object E extends D {
    foo(new B)
  }
}
{code}
