The following minimization illustrates the bug:
```scala
abstract class Piol extends java.util.PrimitiveIterator.OfLong {
  def hasNext = ???
  def nextLong() = ???
}

abstract class Foo[Whatever] { def pi: Whatever }

class Bar extends Foo[Piol] {
  def pi: Piol = new Piol {
    // This ends up private, but shadows the public one.
    // Buggy; gives IllegalAccessError when called.
    def forEachRemaining(c: java.util.function.Consumer[_ >: Long]) { ??? }
  }
}

class Baz extends Foo[Piol] {
  def pi: Piol = new Piol {
    // This is correctly public (and overrides the default method)
    def forEachRemaining(c: java.util.function.Consumer[_ >: java.lang.Long]) { ??? }
  }
}

class Quux {
  def pi: Piol = new Piol {
    // This is also correct (overrides default)
    def forEachRemaining(c: java.util.function.Consumer[_ >: java.lang.Long]) { ??? }
  }
}

class Bippy {
  def pi: Piol = new Piol {
    // Compile error if uncommented--incomprehensible unless you guess that
    // Long != Long (java.lang vs. scala) but at least it doesn't work.
    // def forEachRemaining(c: java.util.function.Consumer[_ >: Long]) { ??? }
  }
}
```

Note that *only* when the return type is a generic (even if the exact type is specified) does the compiler silently...do...I'm not even sure what it's doing.  It's confused about what `Long` should be, and somehow that causes it to emit the method as `private` even though it's not marked `private` and it is identical after erasure to a `public` method.

The `Bippy` version (where the return type is not in any way generic) does not exhibit this problem, and `Baz` and `Quux` show that it works the way it ought to if you get the correct type in place.
