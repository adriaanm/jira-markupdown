I ran probably into the same problem. The simplest way to reproduce it are these two lines:
{code}
(1 to 10000000).toStream.foldLeft(0)(_+_)
(1 to 10000000).toStream.reduceLeft(_+_)
{code}
Both are semantically equivalent. The first one runs correctly, and the second one throws an OutOfMemoryError.

The reason for this is that reduceLeft calls foldLeft for the actual work. foldLeft it itself allows the garbage collection of the already processed part of the stream because it discards the reference to the original head of the stream by using tailrecursion. On the other hand, the call to reduceLeft is forwarded to foldLeft, and thus the stackframe of reduceLeft holds a reference to the original head of the stream during the full time of the call, such that nothing can be garbage collected.

I suppose the only way to fix this is some code duplication: if reduceLeft does it's own work instead of forwarding the call, this is solved. 

I would guess this applies to other methods of Stream as well, rendering it a little bit dangerous to use - compare [http://stackoverflow.com/questions/4132924/functional-processing-of-scala-streams-without-outofmemory-errors/4134541SI-4134541 this comment]. 8-}
