The following object declares two functions which are identical except in their use of type parameterization.  They take two arguments and return the top of the stack trace, which I use to determine if a specialized version of the method was invoked.
```scala
object Test1 {
  def f1[@specialized A] (a: A, b: Any) = new Exception().getStackTrace()(0)
  def f2[@specialized A, B] (a: A, b: B) = new Exception().getStackTrace()(0)

  def main(args: Array[String]) {
    println("f1: "+f1(1,"some ref"))
    println("f2: "+f2(1,"some ref"))
  }
}
```

Both methods are specialized on their first type parameter.  f1's second argument is of type Any.  f2 has a second, unspecialized, type parameter and declares it's second argument to be of that type.

I would expect the main method to invoke specialized versions of both methods, since I'm passing an Int in to the sole specialized parameter.  However, the specialized variant is only getting invoked on f1:
```scala
f1: Test1$.f1$mIc$sp(X.scala:3)
f2: Test1$.f2(X.scala:4)
```

I verified that specialized versions are generated for f2.  They are just not invoked.  I also inspected the bytecode to verify that using the stack trace this way gives me accurate results.
