Ok, I'm finally able to reproduce what I was originally seeing (but not without some additional complexity).
```scala
trait Foo[@specialized(Int) A] {
  def foo[@specialized(Int) B](init: B)(f: (B, A) => B): B = init
}

class Bar[@specialized(Int) A] extends Foo[A] {
  def bar1(init: A)(f: (A, A) => A): A = foo[A](init)(f)
  def bar2(init: A)(f: (A, A) => A): A = super.foo[A](init)(f)
}
```

In Bar$mcI$sp, we see the following: method bar2 delegates to the abstract base class specialized method Foo$mcI$sp$class.foo$mIcI$sp, without boxing; whereas method bar1 delegates to the inherited Foo$mcI$sp.foo (non-specialized) method. How is 'super' achieving this here, and is this a bug?
```scala
 public int bar1$mcI$sp(int, scala.Function2<java.lang.Object, java.lang.Object, java.lang.Object>);
    Code:
       0: aload_0       
       1: iload_1       
       2: invokestatic  #43                 // Method scala/runtime/BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer;
       5: aload_2       
       6: invokeinterface #45,  3           // InterfaceMethod Foo$mcI$sp.foo:(Ljava/lang/Object;Lscala/Function2;)Ljava/lang/Object;
      11: invokestatic  #49                 // Method scala/runtime/BoxesRunTime.unboxToInt:(Ljava/lang/Object;)I
      14: ireturn       
    
  public int bar2$mcI$sp(int, scala.Function2<java.lang.Object, java.lang.Object, java.lang.Object>);
    Code:
       0: aload_0       
       1: iload_1       
       2: aload_2       
       3: invokestatic  #33                 // Method Foo$mcI$sp$class.foo$mIcI$sp:(LFoo$mcI$sp;ILscala/Function2;)I
       6: ireturn       
```
