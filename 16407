The following demonstrates a method which is inlined until its class is specialized, after which it isn't, because the specialized version of the (declared final) method is not final.  As a debugging aid, the specialized one is inlined if the call site is in a constructor, just not if it's in the body of a regular method.
```scala
class C[U]() {
  @inline final def apply(x: U): U = x
}

class C2[@specialized(Boolean) U]() {
  @inline final def apply(x: U): U = x
}

class B {
  private val cNormal = new C[Boolean]()
  private val cSpec   = new C2[Boolean]()
  
  final def m1 = cNormal(true)
  final def m2 = cSpec(true)
  // ./a.scala:14: warning: Could not inline required method apply$mcZ$sp because it can be overridden.
  //   final def m2 = cSpec(true)
  //                       ^
  // one warning found

  // however, here it inlines
  cNormal(true)
  cSpec(true)
}
```
