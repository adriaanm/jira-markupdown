The following code should not compile, but does:
{code}
trait X
trait A { def f: Option[X] }
object B {
    private class Y extends X { val y = 42 }
}
class B extends A {
    override def f = Some(new B.Y)
}
{code}
This piece of code contains a programming mistake which should be detected by the compile: the line
{code}
override def f = Some(new B.Y)
{code}
should instead read
{code}
override def f: Option[X] = Some(new B.Y)
{code}
because otherwise the result type will be inferred as Option[B.Y], revealing the private class Y through the public method f, so that any other module can access Y.y:
{code}
println((new B).f.get.y)  // prints 42
{code}
The error is correctly detected if object B is private or Y is a member of class B.
[[BR]][[BR]]
Tested with versions 2.7.7.RC1 and 2.7.3final.
