The implementation of lambdas in Java 8 is more performant[1] than the current implementation of lambdas in Scala. Moreover it is more lightweight in that no synthetic class definitions are emitted; this means fewer classes to classload [2], translating into compilation speed and perm-gen benefits. The generated bytecode is also much shorter [3], allowing for more inlining opportunities. Lastly, as no new anonymous class instance is created per execution (rather an invokedynamic+ execution local class call takes place), this helps with garbage collection (fewer heap allocations). This may also help with cache locality.

A presentation [4] by Vlastimik Mencik claims that Scala 2.12.x will target Java 8 but it's not clear if indy (invokedynamic) will be used or not. So I'm starting this to track progress and potentially get confirmation about whether this is a formal decision, given that Martin Odersky seems to be saying [5] this is not possible without breaking binary compatibility.

In my humble view, the benefits are too great to ignore and this impacts myself and a lot of us who want to continue using functional concepts in high-performance applications.

[1] p32, http://www.slideshare.net/jaxlondon2012/lambda-a-peek-under-the-hood-brian-goetz
[2] p6-7, http://www.slideshare.net/czechscala/java-8-under-the-hood
[3] http://www.javacodegeeks.com/2014/01/compiling-lambda-expressions-scala-vs-java-8.html
[4] p13, http://www.slideshare.net/czechscala/java-8-under-the-hood
[5] 
I have now completed a preliminary set of benchmarks for simple "foreach" lambdas (but not closures) using JMH; the results are extremely interesting!

// Here's the Java version
@State(Scope.Thread)
public class Main
{
  private final List<String> testValues = Arrays.asList("a", "bb", "c", "dd", "e", "ff");

  @GenerateMicroBenchmark
  public void myTest()
      throws InterruptedException
  {
    testValues.forEach( p -> p.length() );
  }
}

Iteration   1: 129700.223 ops/ms
Iteration   2: 129887.216 ops/ms
Iteration   3: 129932.265 ops/ms
Iteration   4: 129925.015 ops/ms
Iteration   5: 129940.037 ops/ms
Iteration   6: 130211.447 ops/ms
Iteration   7: 130111.218 ops/ms
Iteration   8: 130020.330 ops/ms
Iteration   9: 129785.982 ops/ms
Iteration  10: 130034.805 ops/ms
Iteration  11: 130027.400 ops/ms
Iteration  12: 129799.267 ops/ms
Iteration  13: 130067.029 ops/ms
Iteration  14: 129933.144 ops/ms
Iteration  15: 129782.205 ops/ms
Iteration  16: 130047.119 ops/ms
Iteration  17: 129964.672 ops/ms
Iteration  18: 129829.663 ops/ms
Iteration  19: 130142.463 ops/ms
Iteration  20: 129720.404 ops/ms

Result : 129943.095 ±(99.9%) 123.534 ops/ms
  Statistics: (min, avg, max) = (129700.223, 129943.095, 130211.447), stdev = 142.262
  Confidence interval (99.9%): [129819.561, 130066.629]


// Here's the Scala version
@State(Scope.Thread)
class MyBenchmark {

  final val testValues = Array("a", "bb", "c", "dd", "e", "ff").toBuffer

  @GenerateMicroBenchmark
  def test() {
  	testValues.foreach(x => x.length())
  }
}

Iteration   1: 121176.798 ops/ms
Iteration   2: 121206.352 ops/ms
Iteration   3: 122627.047 ops/ms
Iteration   4: 122361.254 ops/ms
Iteration   5: 122044.951 ops/ms
Iteration   6: 121160.859 ops/ms
Iteration   7: 121245.793 ops/ms
Iteration   8: 122784.802 ops/ms
Iteration   9: 121072.250 ops/ms
Iteration  10: 121485.324 ops/ms
Iteration  11: 121488.497 ops/ms
Iteration  12: 121888.145 ops/ms
Iteration  13: 120965.945 ops/ms
Iteration  14: 121130.525 ops/ms
Iteration  15: 121521.937 ops/ms
Iteration  16: 122170.860 ops/ms
Iteration  17: 122369.025 ops/ms
Iteration  18: 121495.005 ops/ms
Iteration  19: 122511.899 ops/ms
Iteration  20: 121582.566 ops/ms

Result : 121714.492 ±(99.9%) 504.060 ops/ms
  Statistics: (min, avg, max) = (120965.945, 121714.492, 122784.802), stdev = 580.476
  Confidence interval (99.9%): [121210.432, 122218.552]


So basically it seems the Java version of lambdas executing a simple foreach lambda is a bit faster than Scala's version, when using the defacto mutable list data structure in each language. However this could be attributed to the differences in implementation of mutable lists of each language; it is not conclusive (although most people will realistically see this kind of performance for lists).

The best results we could get would be from some data structure which is implemented in the same way in both languages (or is exactly the same) such as an array.
However, the reason I benchmarked against lists is that (and this is baffling... can it really be the case?), I could not find a foreach() method on Java 8 arrays.
This is very frustrating...

On the other hand, Scala does allow me to run a foreach lambda on an array, so I tried this as well, as I tend to use *a lot* of arrays in my Scala code.
Actually I try to avoid mutable collections due to their drawbacks and prefer Arrays/Seqs.


// Scala array version
@State(Scope.Thread)
class MyBenchmark {

  final val testValues = Array("a", "bb", "c", "dd", "e", "ff")

  @GenerateMicroBenchmark
  def test() {
  	testValues.foreach(x => x.length())
  }
}

Iteration   1: 158810.042 ops/ms
Iteration   2: 158133.661 ops/ms
Iteration   3: 158151.405 ops/ms
Iteration   4: 157634.051 ops/ms
Iteration   5: 158225.598 ops/ms
Iteration   6: 158189.632 ops/ms
Iteration   7: 158677.971 ops/ms
Iteration   8: 158221.994 ops/ms
Iteration   9: 158284.515 ops/ms
Iteration  10: 157807.267 ops/ms
Iteration  11: 158571.406 ops/ms
Iteration  12: 158202.246 ops/ms
Iteration  13: 158525.803 ops/ms
Iteration  14: 158286.323 ops/ms
Iteration  15: 157755.862 ops/ms
Iteration  16: 158437.783 ops/ms
Iteration  17: 158230.546 ops/ms
Iteration  18: 158245.174 ops/ms
Iteration  19: 158617.236 ops/ms
Iteration  20: 158382.108 ops/ms

Result : 158269.531 ±(99.9%) 260.444 ops/ms
  Statistics: (min, avg, max) = (157634.051, 158269.531, 158810.042), stdev = 299.928
  Confidence interval (99.9%): [158009.087, 158529.975]


So there, Scala lambdas may execute faster than Java's, if you use arrays; not necessarily because of their implementation, but because of their flexibility!

If we remove the `ArrayBuffer` vs `ArrayList` noise and just profile lambda vs anon functions against `ArrayList`

{code}
/*
 * Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package org.sample;

import org.openjdk.jmh.annotations.GenerateMicroBenchmark;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.logic.BlackHole;

import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;

@State(Scope.Benchmark)
public class MyBenchmark {
    private final List<String> testValues = Arrays.asList("a", "bb", "c", "dd", "e", "ff");

    @GenerateMicroBenchmark
    public void lambda() throws InterruptedException { testValues.forEach(p -> new BlackHole().consume(p.length())); }

    @GenerateMicroBenchmark
    public void anonClass() throws InterruptedException {
        Consumer<String> action = new Consumer<String>() {
            public void accept(String x) {
                new BlackHole().consume(x.length());
            }
        };
        testValues.forEach(action);
    }
}
{code}

{noformat}
% (export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/; $JAVA_HOME/bin/java -version )

java version "1.8.0-ea"
Java(TM) SE Runtime Environment (build 1.8.0-ea-b124)
Java HotSpot(TM) 64-Bit Server VM (build 25.0-b66, mixed mode)

% (export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/; $JAVA_HOME/bin/java -jar target/microbenchmarks.jar )
...
Benchmark                     Mode   Samples         Mean   Mean error    Units
o.s.MyBenchmark.anonClass    thrpt       200     1656.678        7.368   ops/ms
o.s.MyBenchmark.lambda       thrpt       200     1627.326        9.527   ops/ms
{noformat}

I suspect the slight win for the lambda is the fact it is statically hoisted, as it doesn't close over any free variables.
@Grzegorz- Well the 'claims' were substantiated with citations. I mean Brian Goetz said they are much more performant, I just reference his talk. I wonder if they overfitted some performance use case...

@Jason- I don't really think something kicking in would've had a large effect, this benchmark uses a single core.
Also, the reason I used lists is because I want to use them idiomatically, the way they will be used.
However I was thinking of doing another benchmark in isolation (using Scala however), but given the bytecode would look the same I think what you've done would be very similar, so thanks for doing it!

Nice one Jason!

