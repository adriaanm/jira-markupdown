I think it's easier to look at the test case than at the code, especially a year later. The patch also includes all the changes necessary for all the tests to pass, which shows in various ways how it differs from code presently being generated.
{code}
// All eight combinations of class/object nesting to three levels.
package s {
  object o1 {
    object o2 { object o3; class o3 }
    class o2  { object o3; class o3 }
  }
  class o1 {
    object o2 { object o3; class o3 }
    class o2  { object o3; class o3 }
  }
}

// Yes, that's the only way to write these types.
show[s.o1.o2.o3.type]("O-O-O")
show[s.o1.o2.o3]("O-O-C")
show[p.o3.type forSome { val p: s.o1.o2 }]("O-C-O")
show[s.o1.o2#o3]("O-C-C")

show[p.o2.o3.type forSome { val p: s.o1 }]("C-O-O")
show[p.o2.o3 forSome { val p: s.o1 }]("C-O-C")
show[p.o3.type forSome { val p: s.o1#o2 }]("C-C-O")
show[s.o1#o2#o3]("C-C-C")

// Now again, but calling getClass on an instance instead
// of using the type to summon a class object. This should
// print the same eight lines as above.
showRef("O-O-O", s.o1.o2.o3)
showRef("O-O-C", new s.o1.o2.o3)
showRef("O-C-O", (new s.o1.o2).o3)
showRef("O-C-C", { val p = new s.o1.o2 ; new p.o3 })
showRef("C-O-O", (new s.o1).o2.o3)
showRef("C-O-C", { val p = (new s.o1).o2 ; new p.o3 })
showRef("C-C-O", { val p = (new s.o1) ; (new p.o2).o3 })
showRef("C-C-C", { val p = new s.o1 ; val q = new p.o2 ; new q.o3 })

Nesting  Outer       Simple  Full
-------  ----------  ------  ----------
O-O-O    s.o1$$o2$   o3$     s.o1$$o2$$o3$
O-O-C    s.o1$$o2$   o3      s.o1$$o2$$o3
O-C-O    s.o1$$o2    o3$     s.o1$$o2$o3$
O-C-C    s.o1$$o2    o3      s.o1$$o2$o3
C-O-O    s.o1$o2$    o3$     s.o1$o2$$o3$
C-O-C    s.o1$o2$    o3      s.o1$o2$$o3
C-C-O    s.o1$o2     o3$     s.o1$o2$o3$
C-C-C    s.o1$o2     o3      s.o1$o2$o3

O-O-O    s.o1$$o2$   o3$     s.o1$$o2$$o3$
O-O-C    s.o1$$o2$   o3      s.o1$$o2$$o3
O-C-O    s.o1$$o2    o3$     s.o1$$o2$o3$
O-C-C    s.o1$$o2    o3      s.o1$$o2$o3
C-O-O    s.o1$o2$    o3$     s.o1$o2$$o3$
C-O-C    s.o1$o2$    o3      s.o1$o2$$o3
C-C-O    s.o1$o2     o3$     s.o1$o2$o3$
C-C-C    s.o1$o2     o3      s.o1$o2$o3
{code}
