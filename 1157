It's generally a bad idea to write benchmarks that are whole contained in the main method because JITs can't optimise it properly (it requires on-stack replacement). Furthermore, that test causes a lot of allocation due to the usage of Range with large values (and subsequent GC). The casts themselves are a small part of the benchmark in the end.

Here's an improved version. Still, given how optimized casts are, it's perfectly possible that the code in the benchmark to prevent HotSpot from optimising the method call completely dominates the benchmark. Also, there's the risk that the f call could be optimised completely.
```scala
  def f(i: Iterator[_]) = i.hasNext

    def main(args: Array[String]) {
      test()
    }
    
    def test() {
      var i = 0
      while (i < 10) {
        val time = System.currentTimeMillis
        val result = inner()
        i += 1
        println("Time: " + (System.currentTimeMillis - time))
        println("Value: " + result)
      }
    }
    
    def inner() = {
      //val empty = Iterator.empty // checkcast occurs within loop
      val empty: Iterator[_] = Iterator.empty // checkcast outside loop
      var i = 0L
      while (i < 10000000000L) {
        f(empty)
        i += 1
      }
      i
    }
}
```

Using the version with the cast and without took the same time in my machine. Interestingly, both versions take about 4.8s after the initial JIT of the inner method, but from the 3rd iteration onwards (when the JIT recompiles the inner method) they both take 7.1s. Seems like HotSpot tries to optimise the code a bit more, but makes it worse. At any rate, both versions perform the same.
