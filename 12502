The local object has lazy val semantics, so the example is the same as:
```scala
class C { def c: C = ??? }
lazy val c: C = c.c             // doesn't warn
```

but the bug is that `Foo()` is not rewritten to `new Foo()`. That optimization side-steps the issue.

I also missed the part where order of local companions matters. The "existing object" must come first textually. The spec says "if a companion object exists already," but it's not obvious to me if that phrase means, "before a companion was synthesized" or "textually before this case class definition was processed by the compiler." I think the former is surely preferable but the latter got voted into office.

