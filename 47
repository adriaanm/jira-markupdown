For future reference, if you instead declare parse1 like this:
{code}
  def parse1[T <: SubNonterminal](nts: List[T]): ParseResult[Output] =
  // def parse1(nts: List[SubNonterminal]): ParseResult[Output] =
{code}
then it compiles.  Of course those should be equivalent, but as we can see they're not (maybe monomorphic vs. polymorphic code paths?)
