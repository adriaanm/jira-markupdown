Regardless of the insolubility of the problem in the general case, it would sure be nice to improve on this. Bytecode transcripts are after compiling under -optimise with current head in the neighborhood of 2.11.0-M6.
```scala
final class Foo(val value: Int) extends AnyVal

final object Foo {
  @inline def apply(x: Int): Foo = new Foo(x)

  // Isn't allowed to extend AnyVal due to wrapping value class
  // Doesn't do any good not to use an implicit class
  @inline implicit final class FooOps(val x1: Foo) {
    @inline def bar(x2: Foo): Foo = Foo(x1.value + x2.value)
  }
}

class A {
  // Super-optimal - implies possible omniscience on part of constant folder
  def superoptimal: Int = 5 + 5
  // 0: bipush        10
  // 2: ireturn

  // Optimal - implies only that inlining works
  def optimal: Int = (5: Int) + (5: Int)
  // 0: iconst_5
  // 1: iconst_5
  // 2: iadd
  // 3: ireturn

  def actual: Int = (Foo(5) bar Foo(5)).value
  //  0: getstatic     #20                 // Field Foo$.MODULE$:LFoo$;
  //  3: getstatic     #20                 // Field Foo$.MODULE$:LFoo$;
  //  6: astore_1
  //  7: astore_2
  //  8: new           #22                 // class Foo$FooOps
  // 11: dup
  // 12: iconst_5
  // 13: invokespecial #26                 // Method Foo$FooOps."<init>":(I)V
  // 16: getstatic     #20                 // Field Foo$.MODULE$:LFoo$;
  // 19: astore_3
  // 20: astore        4
  // 22: getstatic     #20                 // Field Foo$.MODULE$:LFoo$;
  // 25: aload         4
  // 27: invokevirtual #29                 // Method Foo$FooOps.x1:()I
  // 30: iconst_5
  // 31: iadd
  // 32: istore        6
  // 34: astore        5
  // 36: iload         6
  // 38: ireturn
}
```
