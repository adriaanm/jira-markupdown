Hi, I've forked/updated the gist:

https://gist.github.com/4517945

There was couple of bugs in the first version, as you might have noticed.

This version removes the thread-local data (set's to null) after top-level call, so no trace is left. I think it's better so. But if you think it is better to keep the data there to avoid per-top-list-allocation, then it should not be an instance of a scala class (ListSerializationCtrl), but an Array[Boolean] instance, so the hypothetical class-loader leak is prevented.

The version sets inLoop = false directly after write/read in finally block, so that when an exception is thrown the data is in correct state. I first thought it is enough to just remove (set to null) the TLS data in the top-level try/finally, but this way is safer; it's possible to imagine serialization-data which could leave the TLS data in wrong state (if one does e.g serialization within serialization). This is paranoid, but I measured the cost of try/finally there (against setting inLoop = false not within finally) and it was not recognizeable, so no reason to not have that.

It also supports the 2.9 serialization format data, at least according my testing. I wrote the object using oldWriteObject() and read correctly using the new readObject().

I've moved the ListSerializationCtrl class and thread-local variable out of List object. This is mainly to have it private and not private[scala] because the List.tlSerCtrl would be visible from Java in IDEs. So now ListSerializationStart/End/Ctrl are all private classes close to each other.

Finally I did some performance testing. List of size S, serialized/deserialized N times into/from a byte-array:

List size | repeated | 2.9.(ms) | this code(ms) | current 2.10.(ms)
  10      |   2000x  |  33      |   46          |  50
  20      |   2000x  |  40      |   62          |  70
  500     |   200x   |  44      |   86          |  105

So this code is actually faster then the current 2.10. code. That was a pleasant surprise. I don't have definitive explanation on that. I think the code is ready, but I didn't yet have time to learn how to do pull request, or what is the next step.
