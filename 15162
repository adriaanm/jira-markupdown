Compiling the following with -optimize
{code}
class Base {
  @inline def foo(n: Int) = n
}

object Test extends Base {
  def main(args: Array[String]) = {
    println(foo(42))
  }
}
{code}
yields
{code}
test2.scala:7: warning: Could not inline required method foo because bytecode was not available.
    println(foo(42))
               ^
{code}
which is rather strange this since foo is defined right there.

Here's the relevant piece of -Ydebug -Ylog:inliner output:
{code}
[log inliner] CALL_METHOD TestBase.foo (dynamic) has actual receiver: singleton class Test
[log inliner] 	looked up method: Base.foo
[log inliner] shouldLoad: singleton class Test.method foo
[log inliner] Treating CALL_METHOD TestBase.foo (dynamic)
	receiver: singleton class Test
	icodes.available: true
	concreteMethod.isEffectivelyFinal: false
test2.scala:7: warning: Could not inline required method foo because bytecode was not available.
    println(foo(42))
               ^
[log inliner] could not find icode
	receiver: singleton class Test
	method: method foo
{code}

Also, shouldn't concreteMethod.isEffectivelyFinal be true? After all the receiver is a singleton object, ergo its class final. Declaring foo final doesn't change the behavior, though.
