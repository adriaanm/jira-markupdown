The method aggregate has the following signature:

{{{
def aggregate[B](z: B)(seqop: (B, A) => B, combop: (B, B) => B): B
}}}

It is my understanding that this method exists for out-of-order folding, in particular for parallelisation. A collection is split into sub-collections into which z is folded independently using seqop. Once all sub-collections have been folded, we use comboop to combine the results of the partitioned folds. In the case of parallel folds, I would contend that it makes no sense whatsoever to use as the value of z anything other than the "zero" for the type B. For example:

{{{
   List(1, 2, 3, 4).aggregate(1)(_ + _, _ + _)
}}}

The user of the API may get 11 back from this calculation; they might also get 14! Thus the method is flawed in design.

What is more, because the same value of z is used in each partition, it is implicit that the type B must be immutable. So for example, the following gives nonsensical results

{{{
   List(1, 2, 3, 4).aggregate(new java.lang.StringBuffer)(_ append _, _ append _)
}}}

This is not documented at all and in fact it represents a completely unnecessary restriction: As {{seqop}} and {{comboop}} are both applied sequentially, if z were by-name (i.e. st a different z would be folded into each partition), the expression would not be nonsensical at all. The only thing that would be necessary is that, if z were mutable, comboop was threadsafe
