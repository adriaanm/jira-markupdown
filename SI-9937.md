From Scala, if you try to compile code that has an instance of a Kotlin sealed class, and pass it into a constructor or static method also written in Kotlin, you get a type mismatch error. When the java equivalent of a sealed class is used in a similar manner, the error does not happen. This is likely due to differences in the bytecode generated by Kotlin vs Java.

See this bug reproduced in this github project: https://github.com/mjburghoffer/scala-kotlin-innerclass-bug/tree/master

After running `mvn clean compile` the compiler will report an error like:

```scala
[INFO] Compiling 1 source files to /Users/mburghoffer/projects/scala-kotlin-innerclass-bug/scala-kotlin-innerclass-bug-scala/target/classes at 1474994823442
[ERROR] /Users/mburghoffer/projects/scala-kotlin-innerclass-bug/scala-kotlin-innerclass-bug-scala/src/main/scala/mjburghoffer/ConsumerScala.scala:12: error: type mismatch;
[ERROR]  found   : mjburghoffer.ParentSealedKotlin.ChildSealedKotlin
[ERROR]  required: mjburghoffer.mjburghoffer.
[ERROR]     new ConsumerKotlin(childSealedKotlin)
[ERROR]                        ^
[ERROR] one error found
```
Sure, looking at `SealedJava`:

```scala
// class version 50.0 (50)
// access flags 0x421
public abstract class mjburghoffer/ParentSealedJava {

  // access flags 0x1008
  static synthetic INNERCLASS mjburghoffer/ParentSealedJava$1 null null
  // access flags 0x19
  public final static INNERCLASS mjburghoffer/ParentSealedJava$ChildSealedJava mjburghoffer/ParentSealedJava ChildSealedJava

  // access flags 0x2
  private <init>()V
   L0
    LINENUMBER 5 L0
    ALOAD 0
    INVOKESPECIAL java/lang/Object.<init> ()V
    RETURN
   L1
    LOCALVARIABLE this Lmjburghoffer/ParentSealedJava; L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 0x1000
  synthetic <init>(Lmjburghoffer/ParentSealedJava$1;)V
   L0
    LINENUMBER 3 L0
    ALOAD 0
    INVOKESPECIAL mjburghoffer/ParentSealedJava.<init> ()V
    RETURN
   L1
    LOCALVARIABLE this Lmjburghoffer/ParentSealedJava; L0 L1 0
    LOCALVARIABLE x0 Lmjburghoffer/ParentSealedJava$1; L0 L1 1
    MAXSTACK = 1
    MAXLOCALS = 2
}


// class version 50.0 (50)
// access flags 0x31
public final class mjburghoffer/ParentSealedJava$ChildSealedJava extends mjburghoffer/ParentSealedJava  {

  // access flags 0x19
  public final static INNERCLASS mjburghoffer/ParentSealedJava$ChildSealedJava mjburghoffer/ParentSealedJava ChildSealedJava
  // access flags 0x1008
  static synthetic INNERCLASS mjburghoffer/ParentSealedJava$1 null null

  // access flags 0x1
  public <init>()V
   L0
    LINENUMBER 7 L0
    ALOAD 0
    ACONST_NULL
    INVOKESPECIAL mjburghoffer/ParentSealedJava.<init> (Lmjburghoffer/ParentSealedJava$1;)V
    RETURN
   L1
    LOCALVARIABLE this Lmjburghoffer/ParentSealedJava$ChildSealedJava; L0 L1 0
    MAXSTACK = 2
    MAXLOCALS = 1
}
```


Looking at `SealedKotlin`:

```scala
// class version 50.0 (50)
// access flags 0x421
public abstract class mjburghoffer/ParentSealedKotlin {

  // access flags 0x2
  private <init>()V
   L0
    LINENUMBER 3 L0
    ALOAD 0
    INVOKESPECIAL java/lang/Object.<init> ()V
    RETURN
   L1
    LOCALVARIABLE this Lmjburghoffer/ParentSealedKotlin; L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 0x1001
  public synthetic <init>(Lkotlin/jvm/internal/DefaultConstructorMarker;)V
   L0
    LINENUMBER 3 L0
    ALOAD 0
    INVOKESPECIAL mjburghoffer/ParentSealedKotlin.<init> ()V
    RETURN
   L1
    LOCALVARIABLE this Lmjburghoffer/ParentSealedKotlin; L0 L1 0
    LOCALVARIABLE $constructor_marker Lkotlin/jvm/internal/DefaultConstructorMarker; L0 L1 1
    MAXSTACK = 1
    MAXLOCALS = 2

  @Lkotlin/Metadata;(mv={1, 1, 1}, bv={1, 0, 0}, k=1, d1={"\u0000\u000c\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0002\u0008\u0003\u00086\u0018\u00002\u00020\u0001:\u0001\u0003B\u0007\u0008\u0002\u00a2\u0006\u0002\u0010\u0002\u00a8\u0006\u0004"}, d2={"Lmjburghoffer/ParentSealedKotlin;", "", "()V", "ChildSealedKotlin", "production sources for module scala-kotlin-innerclass-bug-kotlin"})
  // access flags 0x19
  public final static INNERCLASS mjburghoffer/ParentSealedKotlin$ChildSealedKotlin mjburghoffer/ParentSealedKotlin ChildSealedKotlin
}


// class version 50.0 (50)
// access flags 0x31
public final class mjburghoffer/ParentSealedKotlin$ChildSealedKotlin extends mjburghoffer/ParentSealedKotlin  {

  // access flags 0x1
  public <init>()V
   L0
    LINENUMBER 4 L0
    ALOAD 0
    ACONST_NULL
    INVOKESPECIAL mjburghoffer/ParentSealedKotlin.<init> (Lkotlin/jvm/internal/DefaultConstructorMarker;)V
    RETURN
   L1
    LOCALVARIABLE this Lmjburghoffer/ParentSealedKotlin$ChildSealedKotlin; L0 L1 0
    MAXSTACK = 2
    MAXLOCALS = 1

  @Lkotlin/Metadata;(mv={1, 1, 1}, bv={1, 0, 0}, k=1, d1={"\u0000\u000c\n\u0002\u0018\u0002\n\u0002\u0018\u0002\n\u0002\u0008\u0002\u0018\u00002\u00020\u0001B\u0005\u00a2\u0006\u0002\u0010\u0002\u00a8\u0006\u0003"}, d2={"Lmjburghoffer/ParentSealedKotlin$ChildSealedKotlin;", "Lmjburghoffer/ParentSealedKotlin;", "()V", "production sources for module scala-kotlin-innerclass-bug-kotlin"})
  // access flags 0x19
  public final static INNERCLASS mjburghoffer/ParentSealedKotlin$ChildSealedKotlin mjburghoffer/ParentSealedKotlin ChildSealedKotlin
}
```

The big difference is presence of of the following in java (that does not exist in kotlin)
```scala
  // access flags 0x1008
  static synthetic INNERCLASS mjburghoffer/ParentSealedJava$1 null null
```
Looking at `ConsumerJava`:

```scala
// class version 50.0 (50)
// access flags 0x31
public final class mjburghoffer/ConsumerJava {

  // access flags 0x19
  public final static INNERCLASS mjburghoffer/ParentSealedJava$ChildSealedJava mjburghoffer/ParentSealedJava ChildSealedJava

  // access flags 0x1
  public <init>(Lmjburghoffer/ParentSealedJava$ChildSealedJava;)V
   L0
    LINENUMBER 5 L0
    ALOAD 0
    INVOKESPECIAL java/lang/Object.<init> ()V
    RETURN
   L1
    LOCALVARIABLE this Lmjburghoffer/ConsumerJava; L0 L1 0
    LOCALVARIABLE sealedChild Lmjburghoffer/ParentSealedJava$ChildSealedJava; L0 L1 1
    MAXSTACK = 1
    MAXLOCALS = 2
}
```

vs `ConsumerKotlin`:
```scala
// class version 50.0 (50)
// access flags 0x31
public final class mjburghoffer/ConsumerKotlin {

  // access flags 0x1
  public <init>(Lmjburghoffer/ParentSealedKotlin$ChildSealedKotlin;)V
    @Lorg/jetbrains/annotations/NotNull;() // invisible, parameter 0
   L0
    ALOAD 1
    LDC "sealedChild"
    INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkParameterIsNotNull (Ljava/lang/Object;Ljava/lang/String;)V
   L1
    LINENUMBER 3 L1
    ALOAD 0
    INVOKESPECIAL java/lang/Object.<init> ()V
    RETURN
   L2
    LOCALVARIABLE this Lmjburghoffer/ConsumerKotlin; L0 L2 0
    LOCALVARIABLE sealedChild Lmjburghoffer/ParentSealedKotlin$ChildSealedKotlin; L0 L2 1
    MAXSTACK = 2
    MAXLOCALS = 2

  @Lkotlin/Metadata;(mv={1, 1, 1}, bv={1, 0, 0}, k=1, d1={"\u0000\u0012\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0000\n\u0002\u0018\u0002\n\u0002\u0008\u0002\u0018\u00002\u00020\u0001B\r\u0012\u0006\u0010\u0002\u001a\u00020\u0003\u00a2\u0006\u0002\u0010\u0004\u00a8\u0006\u0005"}, d2={"Lmjburghoffer/ConsumerKotlin;", "", "sealedChild", "Lmjburghoffer/ParentSealedKotlin$ChildSealedKotlin;", "(Lmjburghoffer/ParentSealedKotlin$ChildSealedKotlin;)V", "production sources for module scala-kotlin-innerclass-bug-kotlin"})
}
```

The big difference here is the presence of (in Java):
```scala
  // access flags 0x19
  public final static INNERCLASS mjburghoffer/ParentSealedJava$ChildSealedJava mjburghoffer/ParentSealedJava ChildSealedJava
```
The root problem is a Kotlin bug: https://youtrack.jetbrains.com/issue/KT-14069, which has been accepted by the developers and is "in progress" at the time of writing. `org.mapdb.DB$HashMapMaker` refers to an inner class without a corresponding entry in its `InnerClasses` attribute:

```
javap -cp /Users/jz/.ivy2/cache/org.mapdb/mapdb/bundles/mapdb-3.0.2.jar -v 'org.mapdb.DB$HashMapMaker' | grep 'Class.*DB$Maker'
    #5 = Class              #4            // org/mapdb/DB$Maker
~/code/scala on 2.12.x*
âš¡ javap -cp /Users/jz/.ivy2/cache/org.mapdb/mapdb/bundles/mapdb-3.0.2.jar -v 'org.mapdb.DB$HashMapMaker' | tail -n 12
  1207#4,3:1890
  *E
InnerClasses:
     static final #103; //class org/mapdb/DB$HashMapMaker$layout$1
     static final #228; //class org/mapdb/DB$HashMapMaker$verify$1
     static final #235; //class org/mapdb/DB$HashMapMaker$verify$listener$1
     static final #450; //class org/mapdb/DB$HashMapMaker$create2$1
     static final #620; //class org/mapdb/DB$HashMapMaker$open2$1
     static final #681; //class org/mapdb/DB$HashMapMaker$1
```

Changes in scalac in 2.12.1 (https://github.com/scala/scala/pull/5482/commits/bde2854588eea4e3199fc97e0af92a8b35ce1705) removed some code that must have served as a backstop to this sort of bytecode problem.

Javac seems to treat the class as a regular class and continue. By contrast, when scalac processes some other classfile that lists `Foo$Inner` as an inner class of `Foo`, it unlinks `Foo$Inner` from the package, so later attempts to use it as a top-level class result in a failed lookup. See `unlinkIfPresent` in `parseInnerClasses`.

As an experiment, removing the calls to `unlinkIfPresent` (which were added as part of a fix for #1329. The compiler then is able to typecheck client code of this JAR, but trips an assertion in the backend:

```scala
java.lang.AssertionError: assertion failed: List(Lorg/mapdb/DB$AtomicStringMaker;, Lorg/mapdb/DB$TreeSetMaker;, Lorg/mapdb/DB$AtomicIntegerMaker;, Lorg/mapdb/DB$AtomicVarMaker;, Lorg/mapdb/DB$AtomicLongMaker;, Lorg/mapdb/DB$TreeMapSink;, Lorg/mapdb/DB$IndexTreeListMaker;, Lorg/mapdb/DB$Keys;, Lorg/mapdb/DB$Maker;, Lorg/mapdb/DB$IndexTreeLongLongMapMaker;, Lorg/mapdb/DB$AtomicBooleanMaker;, Lorg/mapdb/DB$HashMapMaker;, Lorg/mapdb/DB$CatVal;, Lorg/mapdb/DB$HashSetMaker;, Lorg/mapdb/DB$Companion;, Lorg/mapdb/DB$TreeMapMaker;)
	at scala.Predef$.assert(Predef.scala:219)
	at scala.tools.nsc.backend.jvm.BTypes$ClassBType.checkInfoConsistency(BTypes.scala:896)
	at scala.tools.nsc.backend.jvm.BTypes$ClassBType.info_$eq(BTypes.scala:868)
	at scala.tools.nsc.backend.jvm.BTypesFromSymbols.setClassInfo(BTypesFromSymbols.scala:446)
```

Perhaps this assertion might be too strict.

I still need to take a look at reverting part of the commit in 2.12.1 to see how that avoids the problem. At the time, the code that was removed was believed to be dead code.
Here's a way to remove Kotlin from the equation and compare the fault tolerance of javac and scalac. This example fails in scalac 2.11.8 and 2.12.0, so it must be slightly different to the case that regressed in 2.12.1. But I believe if we this one working, other cases will fall into line:

```
% printf 'public class C$D {}; class Test1 { static C$D foo() { return new C$D(); } }' > 'sandbox/C$D.java'; javac -d /tmp 'sandbox/C$D.java'

% printf 'public class C { class D {}}; class Test2 { static void accept(C.D cd) {} }' > 'sandbox/C.java'; javac -d /tmp 'sandbox/C$D.java'

% printf 'public class Client { { Test2.accept(Test1.foo()); } }' > sandbox/Client.java && javac -d /tmp -cp /tmp sandbox/Client.java

% printf 'class ScalaClient { Test2.accept(Test1.foo()) }' > sandbox/ScalaClient.scala && ~/scala/2.11.8/bin/scalac -d /tmp -cp /tmp sandbox/ScalaClient.scala
sandbox/ScalaClient.scala:1: error: type mismatch;
 found   :
 required: C#D
class ScalaClient { Test2.accept(Test1.foo()) }
                                          ^
one error found

% printf 'class ScalaClient { Test2.accept(Test1.foo()) }' > sandbox/ScalaClient.scala && ~/scala/2.12.0/bin/scalac -d /tmp -cp /tmp sandbox/ScalaClient.scala
sandbox/ScalaClient.scala:1: error: type mismatch;
 found   :
 required: C#D
class ScalaClient { Test2.accept(Test1.foo()) }
                                          ^
one error found
```
Another reproducer project: https://github.com/rtkaczyk/mapdb212 

```
foo
```
@retronym I looked a bit into this, I don't see a good way to fix it unfortunately.

In 2.12.1+

In your example, `Test1` refers to `C$D` but doesn't have an inner class entry for it. `Test2` refers to the class and does have an inner class entry. As you say, when parsing class `_root_.C`, the symbol for `_root_.C$D` is unlinked. From this moment on, parsing classfile `Test1` leads to a fatal error `"package <empty> does not have a member C$D"`, which is handled by creating a stub symbol, but eventually the stub is accessed and the compiler returns an error.

One idea would be to keep a map from unlinked names to inner symbols. But the problem is that this depends on the order of classfile parsing: if `Test1` is parsed before `C`, the package-level `C$D` still exists.

The other solution (trying that in https://github.com/scala/scala/pull/5822) is to identify a lookup of `C$D`, split up the name, look up `C` and then search for a member `D`. A tricky part is that we don't know, at this point, whether `D` is a static or non-static inner class. So we need to look in both class C and its companion. Maybe there's a better way..
