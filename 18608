The ScalaDoc states that a [scala.collection.concurrent.TrieMap|http://www.scala-lang.org/api/current/index.html#scala.collection.concurrent.TrieMap] is thread-safe:
{quote}
A concurrent hash-trie or TrieMap is a concurrent thread-safe lock-free implementation of a hash array mapped trie.
{quote}

But the method {{getOrElseUpdate}} of [scala.collection.mutable.MapLike|http://www.scala-lang.org/api/current/index.html#scala.collection.mutable.MapLike] is not overridden and is therefore not thread safe:
{code}
  def getOrElseUpdate(key: A, op: => B): B =
    get(key) match {
      case Some(v) => v
      case None => val d = op; this(key) = d; d
    }
{code}

This issue can be recreated with the following code:
{code}
import scala.collection.concurrent.TrieMap

object TrieMapApp extends App {
  object ApplyMeOnce {
    var applied = false
    def apply() = synchronized {
      require(!applied)
      applied = true
    }
  }

  val map = TrieMap.empty[String, Unit]

  val runnable = new Runnable {
    def run() = {
      try {
        map.getOrElseUpdate("Result", ApplyMeOnce())
      } catch {
        case e: Exception => exception = Some(e)
      }
    }
  }

  var exception: Option[Exception] = None

  while (exception == None) {
    1 to 10 map { i => new Thread(runnable, i.toString) } foreach { thread => thread.start() }
    println(exception)
  }
  println(exception)
}
{code}

Please let me know if you need more information.

As a workaround you can write:
{code}
synchronized { map.getOrElseUpdate("Result", ApplyMeOnce()) }
{code}
