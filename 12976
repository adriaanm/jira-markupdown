When working through Scala By Example, I found an inconsistency in the interpreter vs. the compiler. If I have the following file ('IntSet.scala')

{code}
trait IntSet {
    def incl(x: Int): IntSet
    def contains(x: Int): Boolean
}

class EmptySet extends IntSet {
    def contains(x: Int): Boolean = false
    def incl(x: Int): IntSet = 
        new NonEmptySet(x, new EmptySet, new EmptySet)
}

class NonEmptySet(elem: Int, left: IntSet, right: IntSet) extends IntSet {
    def contains(x: Int): Boolean =
        if (x < elem) left contains x
        else if (x > elem) right contains x
        else true
    def incl(x: Int): IntSet = 
        if (x < elem) 
            new NonEmptySet(elem, left incl x, right)
        else if (x > elem) 
            new NonEmptySet(elem, left, right incl x)
        else this
}

object Exec {
    def main(args: Array[String]) {
        var x: IntSet = new EmptySet
        x = x incl 5
        x = x incl 4
        println(x contains 4)
        println(x contains 3)
    }
}
{code}

and run 'scala', then at the interpreter type ':load IntSet.scala' I get the following errors:

{code}
scala> :load IntSet.scala
Loading IntSet.scala...
defined trait IntSet
<console>:8: error: type mismatch;
 found   : EmptySet
 required: IntSet
               new NonEmptySet(x, new EmptySet, new EmptySet)
                                  ^
<console>:8: error: type mismatch;
 found   : EmptySet
 required: IntSet
               new NonEmptySet(x, new EmptySet, new EmptySet)
                                                ^
<console>:8: error: type mismatch;
 found   : NonEmptySet
 required: IntSet
               new NonEmptySet(x, new EmptySet, new EmptySet)
               ^
defined class NonEmptySet
<console>:7: error: type mismatch;
 found   : EmptySet
 required: IntSet
               var x: IntSet = new EmptySet
                               ^
{code}

However, if I compile and then run with 'scalac IntSet.scala' and 'scala Exec', I get  
{code}
...>scala Exec
true
false
{code}

As expected.

The two should have uniform semantics. An acceptably typed input to the compiler should be acceptably typed to the interpreter and REPL.
