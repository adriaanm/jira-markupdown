{code}
val t: Converted[Int] = { evaluated = true; 1 }
{code}

Here, the whole code block is typed with an expected type of `Converted[Int]`. Then, inside the block, when looking at the return value, the compiler sees `1` not complying to the expected type and then introduces the conversion inside the block. Afterwards, the whole block does comply to the expected type and there is no reason to apply a view to the whole block. I think that's the reason for the current behavior and it seems to be covered by the spec.

That's just the simplest example but you may introduce many more possible levels of nesting where the expected type flows to the very inside and the implicit conversion actually should be applied inside.

See http://www.scala-lang.org/node/8487 for an older discussion as well.
