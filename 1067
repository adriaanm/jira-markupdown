I'm sorry, but the answer doesn't satisfy me, and I can't avoid the impression that you have misunderstood the problem. The problem is _not_ that {{Null}} isn't getting some special treatment, but rather that a general typing rule doesn't apply to {{Null}} whereas it seems to apply to all other types (including {{Nothing}}). To reiterate:

If {{A >: L}} and {{B >: L}} then {{A with B >: L}}.

This rule should, as far as I can see, be safe for _all_ types, and with the current type system it already seems to be admissible for all the types I tested with... _except_ {{Null}}. Obviously, if {{A >: Null}} and {{B >: Null}}, then {{null}} also inhabits {{A with B}}, so your concern about empty types is already addressed by the general bounds checking mechanism. I don't see {{Null}} being any different from any other lower bound here.

As further proof that this is a compiler bug, consider that the problems in both my and Iulian's example can be worked around by simply parameterizing the lower bound so a literal {{Null}} doesn't appear in the code:

{code}
trait X[L] { x => type T >: L; new X[L] { type T = Any with x.T } }

trait T[L] { type U >: L; type V >: L }
trait T1[L] extends T[L] { type V = Any with U }
{code}

This doesn't yield any compiler errors with 2.7.2.RC1, and there are no problems instantiating {{L}} to {{Null}}.

So it very very much seems to me that in the compiler there is some special-cased handling for {{Null}} that rejects valid code.
