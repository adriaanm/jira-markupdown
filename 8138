I've just been building Slick with 2.11.

https://github.com/retronym/slick/compare/tmp;2.11-compat-2?expand=1

scala/bug#1786 actually seems to be a step backwards. Before, slick left off a lot of existential bounds, but because it did that across the boards we it actually got away with it.

Now, depending on compilation order, some bounds are inferred, and others aren't. The inferred bounds are infectious; type errors spring up in other places.
```scala
[error] /Users/jason/code/slick/slick-testkit/src/main/scala/com/typesafe/slick/testkit/tests/JdbcMapperTest.scala:194: class PairShape needs to be abstract, since method copy in class ProductNodeShape of type (shapes: Seq[scala.slick.lifted.Shape[_ <: scala.slick.lifted.ShapeLevel, _, _, _]])scala.slick.lifted.Shape[Level, _, _, _] is not defined
[error] (Note that Seq[scala.slick.lifted.Shape[_ <: scala.slick.lifted.ShapeLevel, _, _, _]] does not match Seq[JdbcMapperTest.this.tdb.profile.simple.Shape[_, _, _, _]]: their type parameters differ)
[error]     final class PairShape[Level <: ShapeLevel, M <: Pair[_,_], U <: Pair[_,_], P <: Pair[_,_]](val shapes: Seq[Shape[_, _, _, _]]) extends MappedScalaProductShape[Level, Pair[_,_], M, U, P] {
[error]
```

So I can see the attraction of deferring the bounds sharpening until subtype checks.
