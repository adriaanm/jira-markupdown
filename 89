No, this can't be fixed in the backend. the code coming from the pattern matcher is very wrong:

{code}
if ((null: java.lang.Object).==(test.this.test$$MyMatchers$$Something$$$$$$outer.StringMatch()))
        ()
      else
        failCont%0(){
          ()
        };
{code}

Notice the call to test.this.test$$MyMatchers$$Something... It should be this....$$outer.StringMatch. I've been fighting my way through the pattern matcher the whole afternoon, I narrowed it down to line 1241 in ParallelMatchers, where it throws away the call to outer and uses the package... If anyone has better knowledge of what's going on there, maybe he can use this pointer.
