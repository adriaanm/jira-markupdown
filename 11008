As you have shown, you can't answer this question by interrogating `member` or `overrideChain`'; they both respect the "concrete always overrides deferred" rule.

It seems you are asking for `RefChecksTransformer#checkAllOverrides` to be refactored to expose this logic.

Here's the copy/paste version:

{code}
abstract class A           { def f: Int = 1 }
abstract class B extends A { def f: Int     }
abstract class C extends B

object Test {
  val symtab = reflect.runtime.universe.asInstanceOf[reflect.internal.SymbolTable]
  import symtab._, reflect.internal.Flags._

  def ignoreDeferred(clazz: Symbol, member: Symbol) = (
    (member.isType && member.asType.isAbstractType && !member.isFBounded) || (
         member.isJavaDefined
      && javaErasedOverridingSym(clazz, member) != NoSymbol
    )
  )

  def javaErasedOverridingSym(clazz: Symbol, sym: Symbol): Symbol =
    clazz.tpe.nonPrivateMemberAdmitting(sym.name, BRIDGE).filter(other =>
      !other.isDeferred && other.isJavaDefined && !sym.enclClass.isSubClass(other.enclClass) && {
        def uncurryAndErase(tp: Type): Type = {
          erasure.erasure(sym)(uncurry.transformInfo(sym, tp))
        }
        val tp1: Type = uncurryAndErase(clazz.thisType.memberType(sym))
        val tp2: Type = uncurryAndErase(clazz.thisType.memberType(other))
        enteringPhase(findPhaseWithName("erasure"))(tp1 matches tp2)
      })

  def abstractDecls(clazz: Symbol): List[Symbol] = {
    val result = collection.mutable.Buffer[Symbol]()
    def loop(bc: Symbol): Unit = {
      for (decl <- bc.info.decls) {
        if (decl.isDeferred && !ignoreDeferred(clazz, decl)) {
          val impl = decl.matchingSymbol(clazz.thisType, admit = VBRIDGE)
          if (impl == NoSymbol || (decl.owner isSubClass impl.owner)) {
            result += decl
          }
        }
      }
      if (bc.superClass hasFlag ABSTRACT)
        loop(bc.superClass)
    }
    loop(clazz)
    result.toList
  }

  def main(args: Array[String]): Unit = {
    println(abstractDecls(symbolOf[C]))
  }
}
{code}

{noformat}
scalac-hash v2.11.5 sandbox/test.scala && scala-hash v2.11.5 -nobootcp -nc Test
warning: there were three feature warnings; re-run with -feature for details
one warning found
List(method f)
{noformat}
