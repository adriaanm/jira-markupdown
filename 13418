It would be nice if pattern matches on type worked inside for comprehensions:
```scala
scala> for (Some(x) <- List(None, Some(1))) yield x
res4: List[Int] = List(1)

scala> for (x : Some[_] <- List(None, Some(1))) yield x
<console>:5: error: type mismatch;
 found   : (Some[_]) => Some[Any]
 required: (Option[Int]) => ?
       for (x : Some[_] <- List(None, Some(1))) yield x
            ^
scala> Some(1) match { case x : Some[_] => x }
res7: Some[Any] = Some(1)
```

I'd like the middle one to be a pattern match on type, so instead of a type error it would give List(Some(1)).
