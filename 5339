Okay, that explains the behaviour.

There is some commented out code in the typechecker relevant to this problem. Looks like the Eta expansion used to prevented:

http://lampsvn.epfl.ch/trac/scala/browser/scala/trunk/src/compiler/scala/tools/nsc/typechecker/Typers.scala?annotate=blame&rev=24068#L298

As pf r12607, this check was commented out. The commit comment isn't illuminating -- scala/bug#1269 is a `worksforme` and a cursory search over the interwebs doesn't reveal the origin or intention of (Stephan?) Kolstov's patch.

For the benefit of future ticket readers, here's the problem without the REPL. If scalac followed the letter of the spec, `f(1)` would not be allowed.
```scala

E:\code\scratch\4176>cat 4176_1.scala
object test1 {
  def id[A](as: A*) = as
  val f = id[Int] _
}
E:\code\scratch\4176>cat 4176_2.scala
object test2 {
  def main(args: Array[String]) {
     val f = test1.f
     f(1)
     f(Nil: _*)
  }
}
E:\code\scratch\4176>scalac -d out 4176_1.scala

E:\code\scratch\4176>scalac -classpath out -d out 4176_2.scala

E:\code\scratch\4176>scala -classpath out test2

E:\code\scratch\4176>scalac -classpath out -d out -Xprint:typer 4176_2.scala
[[syntax trees at end of typer]]// Scala source: 4176_2.scala
package <empty> {
  final object test2 extends java.lang.Object with ScalaObject {
    def this(): object test2 = {
      test2.super.this();
      ()
    };
    def main(args: Array[String]): Unit = {
      val f: (Int*) => Int* = test1.f;
      f.apply(1);
      {
        f.apply((immutable.this.Nil: _*));
        ()
      }
    }
  }
}
```
