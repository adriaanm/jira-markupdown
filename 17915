A wrapper that demonstrates a far more capable version the code in sys.process
permitting glob expansion and multiple shell arguments, etc. 
{code}
import sys.process._

object Shell {
  var debug: Boolean = false

  def apply(command: String): Shell = {
if (debug) println("Shell: " + command)
    new Shell(parse(command))
  }
  def apply(pb: ProcessBuilder): Shell = new Shell(pb)

  def parse(command: String): Seq[String] = {
    var parts = List.empty[String]
    parts = "/bin/bash" :: parts
    parts = "-c" :: parts 
    parts = command :: parts
    parts.reverse
  }
}
import Shell._
class Shell(val pb: ProcessBuilder) {
if (debug) println("Shell" + pb)
  def #| (other: Shell) : Shell = {
    val pb: ProcessBuilder = this.pb.#|(other.pb)
    new Shell(pb)
  }
  def #|| (other: Shell) : Shell = Shell(this.pb.#||(other.pb))
  def #&& (other: Shell) : Shell = Shell(this.pb.#&&(other.pb))
  def ### (other: Shell) : Shell = Shell(this.pb.###(other.pb))

  def !!  : String = this.pb.!!
  def !!< : String = this.pb.!!<

  def ! : Int = {
if (debug) println("command="+pb)
    pb.!
  }
  def !< : Int = {
if (debug) println("command="+pb)
    pb.!<
  }
}

// do not import sys.process here 
  implicit def stringToShell(command: String): Shell = Shell(command)

    "ls -l *.scala" !

    "ls -l *.scala" #| "wc -l" !

    "echo aa:bb:cc " #| "sed -e 's/:/ /g'" #| "wc -w" !
{code}
All of the "scripts" work just fine. 

Yea, I am assuming "/bin/bash" and I don't have all of the
other ProcessBuilder methods. They could be added I guess. 

But this approach allows ALL bash scripts to be used not just a some subset
of trivial scripts.
