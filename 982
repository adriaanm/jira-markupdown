The problem seems to be still present in 2.7.3.

If I have a JAX-RS ressource like
```scala
package test.annotation

import _root_.javax.ws.rs._
import _root_.javax.ws.rs.core._
import _root_.javax.servlet.ServletContext

@Path("res1")
class Res1 {
 
  @Context var ctx :  ServletContext = _

  @GET
  @Produces(Array("text/html"))
  def get() = <html><body>ctx is { ctx }</body></html>.toString
}
```

it will always have a !ServletContext injected, it displays something like
"ctx is org.apache.catalina.core.!ApplicationContextFacade@299264e3".

If I instead split it like this:
```scala
package test.annotation

import _root_.javax.ws.rs._
import _root_.javax.ws.rs.core._
import _root_.javax.servlet.ServletContext

trait ResTrait {
 
  @Context var ctx :  ServletContext = _

}
```
```scala
package test.annotation

import _root_.javax.ws.rs._
import _root_.javax.ws.rs.core._

@Path("res2")
class Res2 extends ResTrait {
 
  @GET
  @Produces(Array("text/html"))
  def get() = <html><body>ctx is { ctx }</body></html>.toString
}
```

the !ServletContext is injected into res2 after a clean compile,
but if I just recompile Res2 and redeploy, the Context is not injected.
It will just display "ctx is".

I'll attach a complete compilable project. 
After adjusting the paths in ant.properties you should be able to compile
it and to drop the resulting war into your servlet container (if it has
jersey installed).
