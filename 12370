Yup, 2.12.0-M5 seems to produce a similar tree. From the git history, it looks like it's been this way at least since 2006-2007 (that's the farthest I looked).

Also, I tried adding a `SYNTHETIC` flag to the field in the transformer, which generates a tree like this one:
```scala
package <empty> {
  class Outer extends Object with DelayedInit {
    private[this] val code: scala.collection.mutable.ListBuffer = _;
    <stable> <accessor> private def code(): scala.collection.mutable.ListBuffer = Outer.this.code;
    override def delayedInit(body: Function0): Unit = {
      Outer.this.code().+=(body);
      ()
    };
    final <synthetic> def delayedEndpoint$Outer$1: Unit = {
      Outer.this.code = new scala.collection.mutable.ListBuffer();
      ()
    };
    def <init>(): Outer = {
      Outer.super.<init>();
      Outer.this.delayedInit(new Outer$delayedInit$body(Outer.this));
      ()
    }
  };
  final <synthetic> class Outer$delayedInit$body extends runtime.AbstractFunction0 {
    <synthetic> <paramaccessor> private[this] val $outer: Outer = _;
    final def apply(): Object = {
      Outer$delayedInit$body.this.$outer.delayedEndpoint$Outer$1();
      scala.runtime.BoxedUnit.UNIT
    };
    def <init>($outer: Outer): Outer$delayedInit$body = {
      if ($outer.eq(null))
        throw null
      else
        Outer$delayedInit$body.this.$outer = $outer;
      Outer$delayedInit$body.super.<init>();
      ()
    }
  }
}
```

However, I'm not sure having a `<synthetic>` inside a `<synthetic>` is valid/correct.
