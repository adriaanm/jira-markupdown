This code compiles if the order of the imports is reversed.

Since the order of the imports correctly doesn't affect visibility or accessibility of unprefixed `global`, then it shouldn't affect the implicitness either.
```scala
package object bound2 {
    implicit lazy val global: concurrent.ExecutionContextExecutor = scala.concurrent.ExecutionContext.global
}

package bound {
  // the order of these imports in the same scope should not matter
  import scala.concurrent.ExecutionContext.Implicits.global
  import bound2.B._

  object Test extends App {
    val f = concurrent.Future(42)  //(global) // explicit arg works
    Console println concurrent.Await.result(f, concurrent.duration.Duration.Inf)
  }
}
```
[Reported on SO](http://stackoverflow.com/q/27942143/1296806) with respect to a language import, where SIP-18 was also suspected of harboring a bug.
