Example:
```scala
object Main {
  class A()
  case class RichA() {
    def apply(fun: Int => String) {}
  }
  implicit def toRichA(a: A): RichA = null
  val a = new A()
  def a(x: Boolean, y: Boolean) = x ||  y
  a((p: Int) => "")
}
```
There are few things in this example:
1. Expected type of expression (p: Int) => "" should be clear (in case if 2.) => we can avoid using type annotation 'Int'.
2. This example should compile.
3. Or this example shouldn't compile, then it should have another error message. Current message is about overloaded method and it's obiously not clear, because one of these methods is applicable, and second method is not.
