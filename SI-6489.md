From https://groups.google.com/forum/?fromgroups=#!topic/scala-user/bxY0q0nCO4E

{quote}
On Wed, Aug 29, 2012 at 5:01 PM, Eugene Burmako <eugene....@epfl.ch> wrote: 
> What position would you assign to a tree constructed with parseExpr? 

An offset into the string you are parsing. I looked at the 
implementation and it seems you would have to reoffset stuff because 
of the wrapper. But I think that would be the most useful. The macro 
using `parse` would then have to offset all the positions by a certain 
amount. 

Aside from that maybe another parsing function would be useful which 
takes an original String literal tree and a string range inside of 
that literal and then uses this information to correctly assign 
positions in relation to the original source of the string. 
{quote}
Denys, I believe your the addition of positions to ToolBoxes will fix this bug.


In the macro context, `def parse` is implemented:  
scala/src/compiler/scala/reflect/macros/contexts/Parsers.scala

Johannes, can you please clarify what kind of positions do you expect? 

As far as I understood your last paragraph you'd like a tree generated by:

{code}
c.parse("foo bar")
{code}

to have positions within the current file where c.parse was called instead of fake temporary one generated just for parsing?
There are two things: when I originally filed the bug, trees generated by `parse` didn't have any positions set. So, any position is better than that. The most useful in this case would be a position that would assume the string given to parse is a complete unit and offsets are into that string. In your example "foo" would have offset 0 and "bar" would have offset 4 and a synthetic unit.

The other idea was, that you are usually not parsing static stuff but stuff coming into the macro as literal string trees. These literal strings will have position from their original file, obviously. However, you would usually don't parse the complete literal string but only a part of it. In this case I would like the parsed tree's positions to point to the right segment in the original file.

We would need a parse method with a signature similar to this:
{code}
def parse(literalString: Literal, offset: Int, length: Int): Tree
{code}

It would take the specified slice of the literal string and call the normal parse method on it but would then use the resulting positions only as an offset into the original literal string position.

As an example, consider a macro call `someDSLEval("stuff scala[3 + 12]")`. The macro would parse the literal string and figure out that there's a scala expression embedded in it that needs to be parsed. So it would call 

{code}
parse(literal, 12, 6) // 12 = offset of '3' in string, 6 = length of expression
{code}

The resulting tree for `3 + 12` should then have positions pointing to the '3' inside the original string in the file calling the macro, etc.

I guess the use-case for this is getting less important with string interpolation basically providing other means for embedding scala expressions in strings but still having something like this would enable custom string interpolation schemes.
