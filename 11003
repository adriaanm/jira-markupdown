I'm not sure what you expect to see in the example above, but "bob's" and "bob\'s" should create the same string, and that's what your transcript shows. In a double-quoted string a backslash behind a single quote is a no-op.

Part of the overall difficulty is that all the quoting forms are overloaded for quasiquoting and for the literals you might be quasiquoting. How do you express a triple-quoted string literal in quasiquotes? Some of these are errors right now but shouldn't be:

{code}
"""-quasiquote containing """-literal // this may not be expressible
"""-quasiquote containing "-literal   // this does the wrong thing (injecting backslashes)
"-quasiquote containing """-literal   // this is not presently expressible but should be
"-quasiquote containing "-literal     // this does the wrong thing (parse error)
{code}
The poor design of string interpolation most likely excludes any good solution. But in a single quoted quasiquote, backslash-quote should be escaped from the quasiquote and thus act like a normal double-quote within the quasiquote context. This should be a string literal "b" not a weird error.
{code}
scala> q"\"b\""
<console>:1: error: ';' expected but string literal found.
       q"\"b\""
             ^
{code}
If I switch to reify (is there a block-syntax quasiquoting mode?) then I get the right behavior for all the quoting forms.
{code}
scala> val Literal(Constant(x1)) = (reify { """bob's""" }).tree
x1: Any = bob's

scala> val Literal(Constant(x1)) = (reify { """bob\'s""" }).tree
x1: Any = bob\'s

scala> val Literal(Constant(x1)) = (reify { "bob's" }).tree
x1: Any = bob's

scala> val Literal(Constant(x1)) = (reify { "bob\'s" }).tree
x1: Any = bob's

scala> val Literal(Constant(x1)) = (reify { "bob\\'s" }).tree
x1: Any = bob\'s
{code}
