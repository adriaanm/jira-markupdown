Regarding the case that I've seen a lot in practice:

{code}
package object demo extends demo.A
{code}

Martin suggests that if we took a strict approach we would outlaw this with a cyclic reference error, as it is conceptually the same manner as:

{code}
scala> object demo extends demo.A {
     |   trait A
     | }
<console>:7: error: illegal cyclic reference involving object demo
       object demo extends demo.A {
                           ^
{code}

This would break quite a lot of code, as nested types in the package are the most appealing for the package object to inherit. So we would have to deprecate it, or just leave it in a "use-at-your-own-risk" zone. We can tailor the error message for package objects to suggest a clean build.

However, if there is enough will to make this work, there might be a way. In this patch, I detect if any parents of a package module loaded from a classfile is missing (ie, is a stub symbol). If so, we pretend that we didn't see the package.class at all. At the conclusion of the run, we can check that the a package module we discarded was indeed reconstructed from sources.

https://github.com/retronym/scala/compare/scala:2.10.0-wip...retronym:ticket/4695

I'm going to sit on this one for a while; comments are very welcome.
