Okay, I think I understand the overloading resolution. Predef.conforms returns a value the required type (String => String). Eta expansion of the the local implicit method s2s results in the same type, but this is not attempted because conforms matched already.

The change in Predef to return a (A <:< A) from conforms solves other problems, but there is no way to be backwards compatible without a special case in the compiler.

I played around with this some more and found a few more unexplained phenomona -- see the inline comments below.

{code}
object test1 {
  implicit def s2s(s: String): String = "s2s"
  assert(implicitly[String => String].apply("foo") == "foo")
  // Predef.conforms chosen here because it returns the required type (A => A),
  // so no need to try to eta transform the method s2s. Fair enough.
}
 
object test2 {
  locally {
    // s2s is a def inside a block. it seems to be automatically eta transformed to (String => String),
    // and is considered equally with conforms[A].
 
    implicit def s2s(s: String): String = "s2s"
    // assert(implicitly[String => String].apply("foo") == "foo")
 
    // UNCOMMENT LINE ABOVE FOR:
    // error: ambiguous implicit values:
    // both method s2s of type (s: String)java.lang.String
    // and method conforms in object Predef of type [A]<:<[A,A]
    // match expected type (String) => String
 
  }
}
 
object test3 {
  def s2s(s: String) = "s2s"
 
  locally {
    // here we ensure that (String => String) is implicit rather than a method. But why is this chosen now, rather than
    // getting the ambiguity error as in `test2`?
    implicit val _ = s2s _
    assert(implicitly[String => String].apply("foo") == "s2s")
  }
  locally {
    implicit def conforms(s: String) = "s2s" // shadowing Predef.conforms by name works. But pretty it ain't.
    assert(implicitly[String => String].apply("foo") == "s2s")
  }
}
{code}
