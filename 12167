{{methTypeArgs}} should accept an extra parameter with the position of the {{fn}} tree, rather than trying to reverse engineer the position by throwing darts, blindfolded, at {{context.tree}}.

{code}
      def argumentPosition(idx: Int): Position = context.tree match {
        case x: ValOrDefDef => x.rhs match {
          case Apply(fn, args) if idx < args.size => args(idx).pos
          case _                                  => context.tree.pos
        }
        case _ => context.tree.pos
      }
      if (settings.warnInferAny && context.reportErrors && canWarnAboutAny) {
        foreachWithIndex(targs) ((targ, idx) =>
          targ.typeSymbol match {
            case sym @ (AnyClass | AnyValClass) =>
              reporter.warning(argumentPosition(idx), s"a type was inferred to be `${sym.name}`; this may indicate a programming error.")
            case _ =>
          }
        )
      }
{code}

