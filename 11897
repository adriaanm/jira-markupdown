If you want `A`-s defintion of R to be first in the linearization order of the type of `this.type`, you need to define it as:

{code}
package nussli
 
trait Base {
  type R
}
 
trait A {self: B with A =>
  type R <: (Int, Int)
  def f(r: A.this.R) = r._1
}
 
trait B {
  type R <: Unit
}
{code}

Note that these are equivalent:

{code}
trait A {self: B => }
trait A {self: A with B => }
{code}

Here's the code that computes the self type, based on the self type annotation and the type of the class itself:
{code}
    def selfTypeCompleter(tree: Tree) = mkTypeCompleter(tree) { sym =>
      val selftpe = typer.typedType(tree).tpe
      sym setInfo {
        if (selftpe.typeSymbol isNonBottomSubClass sym.owner) selftpe
        else intersectionType(List(sym.owner.tpe, selftpe))
      }
    }
{code}

This is inline with the spec for self types: http://www.scala-lang.org/files/archive/spec/2.11/05-classes-and-objects.html#templates

It's also worth noting that while the inconsistency in the type members is allowed in the intersection type of a self type, it is not allowed in a base type sequence of a class.

{code}

class D extends B with A // error: type R in trait A with bounds <: (Int, Int) has incompatible type
class E extends A with B // error: type R in trait B with bounds <: Unit has incompatible type
{code}

As noted in http://www.scala-lang.org/files/archive/spec/2.11/05-classes-and-objects.html#overriding, an additional overriding member is required:
{code}
class F extends B with A {
  type R <: (Int, Int) with Unit // okay
}
class G extends A with B {
  type R <: (Int, Int) with Unit // okay
}
{code}


So I think this is "not a bug", albeit somewhat unintuitive.
