The actual fix for this one is a two liner:
{code}
diff --git a/src/compiler/scala/tools/nsc/transform/LambdaLift.scala b/src/compiler/scala/tools/nsc/transform/LambdaLift.scala
index 4691665..08a543a 100644
--- a/src/compiler/scala/tools/nsc/transform/LambdaLift.scala
+++ b/src/compiler/scala/tools/nsc/transform/LambdaLift.scala
@@ -403,7 +403,7 @@ abstract class LambdaLift extends InfoTransform {
           val tree1 = addFreeParams(tree, sym)
           if (sym.isLocal) liftDef(tree1) else tree1
         case ValDef(mods, name, tpt, rhs) =>
-          if (sym.isCapturedVariable) {
+          if (sym.isCapturedVariable || (sym.hasFlag(CAPTURED) && sym.isLazy)) {
             val tpt1 = TypeTree(sym.tpe) setPos tpt.pos
             val rhs1 =
               atPos(rhs.pos) {
@@ -434,7 +434,7 @@ abstract class LambdaLift extends InfoTransform {
                 atPos(tree.pos)(proxyRef(sym))
               else tree
             else tree;
-          if (sym.isCapturedVariable)
+          if (sym.isCapturedVariable || (sym.hasFlag(CAPTURED) && sym.isLazy))
             atPos(tree.pos) {
               val tp = tree.tpe
               val elemTree = typer typed Select(tree1 setType sym.tpe, nme.elem)
{code}
But I would rather avoid applying it, since it relies on what I think to be unnecessary transformation inside the pattern matcher.
So in pattern matcher this ast fragment:
{code}
        final def apply(x0$$1: Int): Int = x0$$1 match {
          case _ => {
            <synthetic> lazy private[this] var x$$2$$lzy: (Int, Int) = _;
            <synthetic> <stable> <accessor> lazy private[this] def x$$2(): (Int, Int) = {
              x$$2$$lzy = (new (Int, Int)(3, 9): (Int, Int) @unchecked) match {
                case (_1: Int,_2: Int)(Int, Int)((a @ _), (b @ _)) => new (Int, Int)(a, b)
              };
              x$$2$$lzy
            };
{code}
is transformed to
{code}
         <synthetic> val temp7: Int = x0$$1;
          {
            <synthetic> lazy private[this] val x$$2$$lzy: (Int, Int) = _;
            <synthetic> <stable> <accessor> lazy private[this] def x$$2(): (Int, Int) = {
              x$$2$$lzy = {
                <synthetic> val temp4: (Int, Int) = new (Int, Int)(3, 9);
                if (temp4.ne(null))
                  {
                    new (Int, Int)(temp4._1(), temp4._2())
                  }
                else
                  throw new MatchError(temp4)
              };
              x$$2$$lzy
            };
{code}
In short the synthetic lazy var becomes lazy val. I would fix it myself but after looking at the pattern matcher I realized that I could spend there hours thinking, thinking... and thinking what is going on there.

So re-assigning to you, Paul. If you feel that my patch is easier than actually fixing the issue in the pattern matcher, re-assign to me again.

