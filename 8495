There are two things: when I originally filed the bug, trees generated by `parse` didn't have any positions set. So, any position is better than that. The most useful in this case would be a position that would assume the string given to parse is a complete unit and offsets are into that string. In your example "foo" would have offset 0 and "bar" would have offset 4 and a synthetic unit.

The other idea was, that you are usually not parsing static stuff but stuff coming into the macro as literal string trees. These literal strings will have position from their original file, obviously. However, you would usually don't parse the complete literal string but only a part of it. In this case I would like the parsed tree's positions to point to the right segment in the original file.

We would need a parse method with a signature similar to this:
{code}
def parse(literalString: Literal, offset: Int, length: Int): Tree
{code}

It would take the specified slice of the literal string and call the normal parse method on it but would then use the resulting positions only as an offset into the original literal string position.

As an example, consider a macro call `someDSLEval("stuff scala[3 + 12]")`. The macro would parse the literal string and figure out that there's a scala expression embedded in it that needs to be parsed. So it would call 

{code}
parse(literal, 12, 6) // 12 = offset of '3' in string, 6 = length of expression
{code}

The resulting tree for `3 + 12` should then have positions pointing to the '3' inside the original string in the file calling the macro, etc.

I guess the use-case for this is getting less important with string interpolation basically providing other means for embedding scala expressions in strings but still having something like this would enable custom string interpolation schemes.
