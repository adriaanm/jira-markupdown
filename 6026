My current theory is that the following is happening. When reading the last closing tag sent, this method is called:
```scala
  def xEndTag(startName: String) {
    xToken('/')
    if (xName != startName)
      errorNoEnd(startName)

    xSpaceOpt
    xToken('>')
  }
```

Since that tag is properly sent, it runs up to `xToken('>')`, which is defined thus:
```scala
  def xToken(that: Char) {
    if (ch == that) nextch
    else xHandleError(that, "'%s' expected instead of '%s'".format(that, ch))
  }
```

Evidently, it calls `nextch`, which does the obvious thing:
```scala
  def nextch = {
    if (curInput.hasNext) {
      ch = curInput.next
      pos = curInput.pos
    } else {
```

The point here is that it needs to know if there is a next or not. Since this is a stream, it blocks until the stream is closed or something else is sent.

Unfortunately, the whole parser is based on having {{ch}} available (it is a {{var}}), so it doesn't look like there's an easy fix for it.
