Replying to [comment:6 dcsobral]:
> Replying to [comment:5 rytz]:
> > 
> > If you pass a single parameter then both methods are applicable, and the compiler tries to find out which one is more specific. It will find that none of the two is more specific than the other, both are applicable to parameters of types of the other (once via tuple conversion). see spec for `more specific`.
> 
> I assume that's a conversion into a Tuple1? Why would such a conversion be even considered, given that the type matches?


Sorry, let me try again.
```scala
object t {
  def f(x: AnyRef) = 1 // A
  def f(x: AnyRef, xs: AnyRef*) = 2 // B
}
```

if you call `f("foo")`, both A and B are applicable. Which one is more specific?

 * it is possible to call B with parameters of type `(AnyRef)`, so A is as specific as B.
 * it is possible to call A with parameters of type `(AnyRef, Seq[AnyRef])` thanks to tuple conversion, `Tuple2[AnyRef, Seq[AnyRef]]` conforms to `AnyRef`. So B is as specific as A.

Since both are as specific as the other, the reference to `f` is ambiguous.
