The appended error message is seen under -Ylog:typer, but under normal compilation scalac offers nothing.

Secondarily, it would be nice if this situation were recognized as the non-conflict which it is: the "conflicting" implicits are prefix-insensitive and the identical method implementation. This situation arises very easily when mixing implicits into package objects and trying to evolve codebases.

But at the very least how about we give people a hint what happened.
```scala
trait Impy { implicit def string2int(s: String): Int = s.length }
object o1 extends Impy
object o2 extends Impy

object Test {
  import o1._
  import o2._

  val x: Int = "abc"
}
// [log typer] Import is genuinely ambiguous:
//   types:  o2.type =:= o1.type  false  members: true
//   member type 1: (s: String)Int
//   member type 2: (s: String)Int
// [log typer] implicit adapt failed: reference to string2int is ambiguous;
// it is imported twice in the same scope by
// import o2._
// and import o1._
```
