Hmm, I don't get it, isn't it the same from Java? If you directly implement an interface ({{scala.Product}} here), and *also* indirectly implement it through something else (here {{scala.Product1\[T\] extends scala.Product}}), then it does appear in the resulting classfile.

As in:
```scala
==> A.java <==
import java.io.Serializable;

public class A<T> implements Product1<T>, Product, Serializable {}

==> Product.java <==
public interface Product {}

==> Product1.java <==
public interface Product1<T> extends Product {}
```
```bash
% javap -v A.class
[...]
#12 = Utf8               <T:Ljava/lang/Object;>Ljava/lang/Object;LProduct1<TT;>;LProduct;Ljava/io/Serializable;
```

Note that `Tuple1` directly implements `Product` because it is a case class:
```scala
case class Tuple1[+T](_1: T) extends Product1[T]
```
is syntactic sugar for this:
```scala
class Tuple1[+T] extends AnyRef with Product1[T] with Product with Serializable { <autogenerated members> }
```
