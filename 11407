Hmm, I don't get it, isn't it the same from Java? If you directly implement an interface ({{scala.Product}} here), and *also* indirectly implement it through something else (here {{scala.Product1\[T\] extends scala.Product}}), then it does appear in the resulting classfile.

As in:

{code}
==> A.java <==
import java.io.Serializable;

public class A<T> implements Product1<T>, Product, Serializable {}

==> Product.java <==
public interface Product {}

==> Product1.java <==
public interface Product1<T> extends Product {}
{code}
{code:bash}
% javap -v A.class
[...]
#12 = Utf8               <T:Ljava/lang/Object;>Ljava/lang/Object;LProduct1<TT;>;LProduct;Ljava/io/Serializable;
{code}

Note that {{Tuple1}} directly implements {{Product}} because it is a case class:
{code}
case class Tuple1[+T](_1: T) extends Product1[T]
{code}
is syntactic sugar for this:
{code}
class Tuple1[+T] extends AnyRef with Product1[T] with Product with Serializable { <autogenerated members> }
{code}
