It turns out that this is causing problems not only for dependency analysis.

The improved incremental compiler I'm working on relies on extracting used names in a given compilation unit. Once constant gets inlined we do not have access to the field that defined it therefore we can't extract its name.

I thought I could work-around it by inspecting symbol names of symbols in {{CompilationUnit.depends}} but we have only top-level classes recorded there, see:
https://github.com/scala/scala/blob/master/src/compiler/scala/tools/nsc/typechecker/Infer.scala#L263

Therefore I believe there's no other way than just fix the underlaying issue.

According to Adriaan we could perform constant inlining and folding based purely on types and leave trees intact. We still want constants to be folded in the bytecode so we could replace trees having constant types with actual constants in some later phase like erasure. This is an interesting idea that I would like to try out at some point.
