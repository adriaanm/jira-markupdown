I've attached an alternative decimal implementation that makes it so (1) a decimal always has a MathContext, and (2) the MathContext is part of the type.  Here's a sample interaction:
```scala
Welcome to Scala version 2.8.0.r0-b20090511215951 (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_07).
Type in expressions to have them evaluated.
Type :help for more information.

scala> val a = Decimal64(1)
a: Decimal64.Decimal = 1

scala> val b = Decimal64(3)
b: Decimal64.Decimal = 3

scala> a / b
res0: Decimal64.Decimal = 0.3333333333333333

scala> val c = Decimal32(3)
c: Decimal32.Decimal = 3

scala> a / c
<console>:7: error: type mismatch;
 found   : Decimal32.Decimal
 required: Decimal64.Decimal
       a / c
           ^

scala> 
```
As you can see it is well-behaved and won't let you randomly mix Decimals from different DecimalModule.
