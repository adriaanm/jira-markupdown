May I suggest the following implementation: We perform the usual stack unrolling up to a point and if we reach a certain stack depth (STACK_DEPTH_LIMIT), we reverse the list (whatever is left of it) and appeal to the tail recursive foldLeft for assistance -- the stack is then unrolled and we have our answer.
```scala
def foldRight[B](z: B)(f: (A, B) => B): B = {
    val STACK_DEPTH_LIMIT = 100

    def revArgs[A1, A2, C](f: (A1, A2) => C): ((A2, A1) => C) =
      (x: A2, y: A1) => f (y, x)

    def aux(iterCnt: Int, ls: Lst[A]): B = ls match {
      case Nil => z
      case x :: xs => {
        if (iterCnt < STACK_DEPTH_LIMIT) {
          f(x, aux(iterCnt + 1, xs))
        }
        else {
          val revRest = ls reverse
          val g = revArgs(f)

          revRest.foldLeft(z)(g)
        }
      }
    }

    aux(0, this)
  }
```
