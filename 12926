(From [http://www.nabble.com/private-vals-in-traits--t4780372.html this mailing list thread])

Consider:
{code}
 trait A { val foo: String = "A" }
 trait B {
   private val foo: String = "B"
   def f = println(foo)
 }
 object Test extends Application with B with A {
   println(foo) // prints "A", as expected
   f            // prints "B", as expected
 }
{code}
This looks, good, but if I switch the order of B and A in the
declaration of Test, it doesn't compile, claiming that there's no such
value as foo.

Adriaan pointed out that this works in the interpreter, and I replied:

Interesting. I see now that it works in the interpreter (I hadn't
tried). But it does not work with scalac:
{code}
[~]% cat test.scala
trait A { val foo: String = "A" }
trait B {
   private val foo: String = "B"
   def f = println(foo)
}
object Test extends A with B {
   println(foo)
   f
}
[~]% scalac test.scala
test.scala:7: error: not found: value foo
   println(foo)
           ^
one error found
[~]% scalac -version
Scala compiler version 2.6.0-final -- (c) 2002-2007 LAMP/EPFL
[~]% scala
Welcome to Scala version 2.6.0-final.
Type in expressions to have them evaluated.
Type :help for more information.

scala> :load test.scala
Loading test.scala...
defined trait A
defined trait B
defined module Test

scala> Test
A
B
res0: Test.type = Test$$@7b37df
{code}

I would expect this to work in the compiler as it works in the interpreter. If this is _not_ a compiler defect, I would also expect it to fail in the interpreter. (The above session is with 2.6.0, but the behavior is the same in 2.6.1-RC1.)
