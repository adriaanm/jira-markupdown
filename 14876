In issue 2819 I suggested the addition of a new type:

{code}
type =>?[-A, +B] = PartialFunction[A, B]
{code}

so that partial functions could be defined with a syntax similar to regular functions.

The change was made (thanks!), and I've been using it.  But I've noticed that it works a little differently from => because it's left-associative while => is right-associative.  So

{code}
Int => Int => Int
{code}

is a function that takes an Int and returns an Int => Int, while

{code}
Int =>? Int =>? Int
{code}

is a partial function that takes an Int =>? Int and returns an Int.

Obviously developers can easily make the second example work like the first by adding some parentheses, but this is counterintuitive for someone who has learned that =>? is like => but defines a partial function.

Some possible resolutions:

1. Ignore the issue entirely.

2. Make the operator "=>:" or "=>?:".  Undesirable because the "?" is descriptive of a partial function and "=>?:" is just plain ugly.

3. Have the compiler recognize =>? and treat it like =>.  My favorite option.  :-)  Probably somewhere in the compiler the parser recognizes "A => B" and transforms it into FunctionN[A, B]. This would be an extension of that logic.  It would also be a first step toward harmonizing the treatment of full and partial functions.
