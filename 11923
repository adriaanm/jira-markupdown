In my reading of the spec, this should be ambiguous. Shorter example:
```scala
object Test extends App {
  def f(s: String): String = "1"
  val f: (String) => String = s => "2"

  val t: String => String = f

  println(t("")) // 2
}
```

http://www.scala-lang.org/files/archive/spec/2.11/06-expressions.html#overloading-resolution

The reference to `f` is not an application or a type application (last paragraph of overloading resolution). Both definitions of `f` are compatible to the expected type, the method via eta-expansion (http://www.scala-lang.org/files/archive/spec/2.11/06-expressions.html#implicit-conversions), so the most specific version is chosen:

 - the method is as specific as the value because the value is applicable to arguments of the method's parameter types (case 1)
 - the value is as specific as the method (case 3)

If I'm wrong in reading the spec, it would be good to add an example to it explaining this case.
