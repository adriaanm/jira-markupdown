It did in a roundabout way; the companion/package objects of enclosing types of a class are actually part of the implicit scope.

But, we'll test both in the fix for this bug.
```scala
object Test {
  abstract class Box {
    val value: Int
  }

  implicit val a: Box = new Box {
    val value= 1
  }

  def main(args: Array[String]) {
    implicit val b: Box= new Box {
      val value= 2
    }

    new Object {
      new Test()
    }
    // compare with:
    // new Test()
  }
}
```
