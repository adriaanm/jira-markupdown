I think both PR-2379 and PR-3906 didn't fix the leak of PipeSource and PipeSink discussed in  scala/bug#7350. PipeSource.run() and PipeSink.run() are more complicated than they need to be. 

I suggest refactoring like this: 
{code}diff --git a/src/library/scala/sys/process/ProcessImpl.scala b/src/library/scala/sys/process/ProcessImpl.scala
index 2b7fcde..46d3df9 100644
--- a/src/library/scala/sys/process/ProcessImpl.scala
+++ b/src/library/scala/sys/process/ProcessImpl.scala
@@ -134,13 +134,15 @@ private[process] trait ProcessImpl {
       try {
         runInterruptible {
           val exit1 = first.exitValue()
-          currentSource put None
-          currentSink put None
           val exit2 = second.exitValue()
           // Since file redirection (e.g. #>) is implemented as a piped process,
           // we ignore its exit value so cmd #> file doesn't always return 0.
           if (b.hasExitValue) exit2 else exit1
         } {
+          currentSink put None
+          currentSource put None
+          sink.interrupt()
+          source.interrupt()
           first.destroy()
           second.destroy()
         }
@@ -175,14 +177,8 @@ private[process] trait ProcessImpl {
   ) extends PipeThread(false, () => label) {
 
     final override def run(): Unit = currentSource.get match {
-      case Some(source) =>
-        try runloop(source, pipe)
-        finally currentSource.unset()
-
-        run()
+      case Some(source) => runloop(source, pipe)
       case None =>
-        currentSource.unset()
-        BasicIO close pipe
     }
   }
   private[process] class PipeSink(
@@ -192,13 +188,8 @@ private[process] trait ProcessImpl {
   ) extends PipeThread(true, () => label) {
 
     final override def run(): Unit = currentSink.get match {
-      case Some(sink) =>
-        try runloop(pipe, sink)
-        finally currentSink.unset()
-
-        run()
+      case Some(sink) => runloop(pipe, sink)
       case None =>
-        currentSink.unset()
     }
   }
{code}
