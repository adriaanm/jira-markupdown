The wildcard import also imports `TermNameTag`, which is an implicit of type `ClassTag[TermName]`. The pattern matcher uses this to perform a type test on an otherwise abstract type.

Here's a look at this independentally of the reflection API.
```scala
trait T {
  type A
  implicit def ATag: scala.reflect.ClassTag[A]
}

class Test1 {
  def scrutinee: Any = ""
  def test(t: T) = scrutinee match {
    case _: t.A => // warning: abstract type pattern t.A is unchecked
  }

  def test2(t: T) = {
    import t.ATag
    scrutinee match {
      case _: t.A => // no warning, translated to `if (ATag.runtimeClass.isInstance(scrutinee)) ...`
    }    
  }
}
```
