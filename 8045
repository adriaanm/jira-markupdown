First, this seems to be a regression of 2.9, since 2.8's ++ had the currently implemented behavior.

Second, I have an idea, but it's fairly invasive, so I'd propose to discuss it on scala-internals if you're interested: in short, have some variant of a Cloneable[Coll] typeclass.

Most concrete members of the Java collections framework I've inspected up to now also implement the Cloneable interface - and cloning is shallow (that is, elements are not cloned), which is perfect.
Among others, ArrayList, LinkedList, EnumSet, HashSet, ArrayDeque, CopyOnWriteArrayList.

ConcurrentHashMap and ConcurrentLinkedQueue are notable exceptions and can be cloned only via their constructors, but ConcurrentSkipList* are Cloneable.

Ignoring API stability constraints, a first idea would be exposing the implicit conversion on `Collection\[T\] with Cloneable`. This conversion should have higher priority than the existing one, and could be prioritized otherwise; the old conversion could even be deprecated.
More flexibly, one could have a `Cloneable\[Coll\]` typeclass (maybe with a different name), with the new conversion taking an instance, with a default instance for subtypes of java.lang.Cloneable, and other default instances for List, Map and Set. Collection seems to call for `Cloneable\[-FromColl, +ToColl\]` and different non-default instances.

Third, I would say, it's even less clear whether implicit conversions are appropriate (I just verified that this problem affects also `WrapAsScala`, which up to now was considered to be safe to use.
In particolar, `a ++ b` could silently copy the whole collection a as a different kind of collection, after `import WrapAsScala._`.
At least, there should be IMHO a clear warning in the ScalaDocs. I think the problem is mostly about `++` being available on mutable collections, but I assume that unfortunately this couldn't be changed.
