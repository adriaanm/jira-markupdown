This code fails at runtime:
{code}
scala> class A(val p: Int*); case class B(p1: Int) extends A(p1); new B(1)
java.lang.ClassCastException: scala.collection.mutable.WrappedArray$ofInt cannot be cast to java.lang.Integer
{code}

The error only occurs in combination of a case class extending a class taking a vararg ctor that is marked as val.

Looking at the generated code the bug is obvious:
{code}
def p1(): Int = scala.Int.unbox(Main$$anon$1$B.super.p());
{code}
and
{code}
def <init>($outer: anonymous class anon$1, p1: Int): anonymous class anon$1$B = {
      Main$$anon$1$B.super.<init>($outer, scala.this.Predef.wrapIntArray(Array[Int]{p1}));
      scala.Product$class./*Product$class*/$init$(Main$$anon$1$B.this);
      ()
    }
  };

{code}
p1 is not correctly set in the ctor of B. Instead it treats p as the same value and tries to get the value from it. 
