Here's a good overview of safe initialization: https://shipilev.net/blog/2014/safe-public-construction/

", we emit a trailing barrier ... A final field was written. Notice we do not care about what field was actually written, we unconditionally emit the barrier before exiting the (initializer) method"

This is a HotSpot implementation detail that makes regularly constructed lists (ie, not with tail mutation) safe to share in that VM (the write the the final field `head` emits the barrier). But we shouldn't rely on such details, so the documentation that "safe publication is up to the client of List" is suitable advice.

Also:

" Fastdebug build is needed to gain access to -XX:+StressLCM -XX:+StressGCM instruction scheduling fuzzers in Hotspot."

These flags have since been made available in release builds of Java 9. They are useful to avoid relying on implementation details of the compliler + processor:

"x86 is Total Store Order hardware, meaning the stores are visible for all processors in some total order. That is, if compiler actually presented the program stores in the same order to hardware, we may be reasonably sure the initializing stores of the instance fields would be visible before seeing the reference to the object itself. Even if your hardware is total-store-ordered, you can not be sure the compiler would not reorder within the allowed memory model spec. If you turn off -XX:+StressGCM -XX:+StressLCM in this experiment, all cases would appear correct since the compiler did not reorder much."







