This is an unfortunate quality of the Iterator ++ implementation.  The problem is that ++ takes a by-name argument, so if you do this:

  it = other ++ it

then the argument "it" is not evaluated until it is reached during iteration.  That means that what is appended is the contents of "it" at that time -- which is the appended iterator, not the one at the time you called it.  In other words, you have created a cycle.  I actually have a guard for the "it = it ++ other" case, so it doesn't happen that way, but I'm not sure it's so easy to stop in the other direction.

You can work around this by making sure it is evaluated before the call, something like

  rightElems = { val tmp = rightElems ; bufferedRightElems.iterator ++ tmp }

In general, it is impossible for things to work right if all three of these are used simultaneously: vars, iterators (or any structure with changing internal state) and by-name arguments.
