I guess that in the presence of an expected type pt, implicit search is failing and overload resolution doesn't get a chance.

The language in 7.3 is that if a view is found, is converted to v(e).

That implies: if no view is found, la-di-da.

For overload resolution, this is a value context and it should select the foo that is compatible with Int => String, where compatible means conforming after applying implicits.

But is the result different?  The intuition here is that it should apply f to the result of foo, but I think this is still required:

implicit def f2(v: Int => Int): Int => String = { (x: Int) => f(x) }

If this were an application of foo(1) where a String is expected, it would supply the implicit f.

(In my previous comment, it infers Int. Disclaimer: my attention is divided by child care, and I'm just learning how all this works.)
