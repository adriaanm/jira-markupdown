I have just finished an "EmptyUniverse" implementing the various scala.reflect.generic._ bits.   There are a bunch of abstract extractor interfaces, which the compiler implements like so:
```scala
  case class AnnotationInfo(atp: Type, args: List[Tree], assocs: List[(Name, ClassfileAnnotArg)])
  object AnnotationInfo extends AnnotationInfoExtractor
```
Not sure I would have guessed to even try that as a means of using synthetic methods to implement an interface.  Are we suggesting by virtue of embedding it in the reflection interface that it's a  mechanism people can expect to keep working?

In any case, it does work if you mimic the compiler structure, having individual traits extending the generic traits, and then mixing them together in Universe.  However if you try it directly in the class, like this:
```scala
class MyUniverse extends Universe {
 ...
  case class AnnotationInfo(atp: Type, args: List[Tree], assocs: List[(Name, ClassfileAnnotArg)])
  object AnnotationInfo extends AnnotationInfoExtractor
}
```
Then you get the assertion failure seen previously in scala/bug#2130 and scala/bug#2779, that a duplicated symbol exists.
```scala
[scalacfork] Exception in thread "main" java.lang.AssertionError: assertion failed: List(object AnnotationInfo, object AnnotationInfo)
[scalacfork] 	at scala.Predef$$.assert(Predef.scala:95)
[scalacfork] 	at scala.tools.nsc.symtab.Symbols$$Symbol.suchThat(Symbols.scala:1037)
[scalacfork] 	at scala.tools.nsc.symtab.Symbols$$Symbol.linkedModuleOfClass0(Symbols.scala:1223)
```
It trips the assertion even if I explicitly list generic.AnnotationInfos in the MyUniverse parents, so it's not a result of being indirectly inherited.
