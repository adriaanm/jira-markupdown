I attached a minimal example reproducing the bug. Compiling it and checking the error messages _might_ be faster than reading my description, but I still include a walkthrough of the bug. Suppose we have the following definitions (the values are irrelevant as you might verify, only the argument types count):

{code}
implicit def function[D[_]](t: TypeWithHigherKindParam[D]) = 1
val param: TypeWithHigherKindParam[PartialApply1Of2[Tuple2, Int]#Apply] = null
{code}
where PartialApply1Of2#Apply is a type function (it comes from [Scalaz|https://github.com/scalaz/scalaz/blob/1303b09595d012858a8a738d5201ede31b7eff74/core/src/main/scala/scalaz/PartialApplys.scala], is included in the attachment). Let's apply function to param:

{code}
function[PartialApply1Of2[Tuple2, Int]#Apply](param): Int //Compiles
function(param) //Does not compile
{code}

So, type inference cannot figure out the needed parameter. However, the error message hints that unification has the right inputs and is simply failing:

{code}
various/BugReport.scala:14: error: no type parameters for method function: (t: BugReport.TypeWithHigherKindParam[D])Int exist so that it can be applied to arguments (BugReport.TypeWithHigherKindParam[[B](Int, B)])
 --- because ---
argument expression's type is not compatible with formal parameter type;
 found   : BugReport.TypeWithHigherKindParam[[B](Int, B)]
 required: BugReport.TypeWithHigherKindParam[?D]

    function(param) //Does not compile
{code}

?D was declared as D[_] and has thus kind * -> * (in Haskell notation), like [B](Int, B), so unification should easily succeed.

Moreover, when making function implicit, I'd expect the compiler to be able to use it (as in the example) - that's (a reduced version of) my original use case, actually. More complex tests can be found commented out in the attachment.

FYI, I retested this also on a (hopefully) more recent version, getting the same results (plus extra unrelated warnings).
It was yesterday's HEAD of scala-virtualized (git://github.com/TiarkRompf/scala-virtualized.git), branch virtualized-master, commit 158bc26c7bf9552c99eba00690b15f5d351abfb6 (which seems to have last resynced to scala on this commit: https://github.com/scala/scala/commit/b0d5648254d68b81bf539b2fca82fc3750c6a720).
The problem is with type argument inference, rather than with unification. AFAIK, scalac *never* infers a partially applied type constructor, even if it is handed to it on a plate, as in your example.

So probably a duplicate of SI-2712, although Adriaan will be the final arbiter of that.

{code}
trait TypeWithHKParam[D[_]]

def function[D[_]](t: TypeWithHKParam[D]) = 1

function(null: TypeWithHKParam[Option]) //okay 

//Does not compile
function(null: TypeWithHKParam[({type l[a] = (Int, a)})#l])
{code}

Very nicely reported bug, BTW.

Thanks for the prompt answer, it's impressive.
I still hope that this subcase can be handled more easily, since here, unlike in SI-2712, Scalac does not have to synthesize a type function, but it is handed to it on a plate and it must just be kind-checked and the kind compared with the desired one.
this is not easy to do (in general, no point in solving this for some ad-hoc cases), so classifying as an improvement
