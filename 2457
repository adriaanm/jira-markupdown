proposed fix: extrapolate in existentialAbstraction created singleton types whose prefix was not stable

extrapolate now generates a wider type instead:
{code}
       val extrapolate = new TypeMap {
         variance = 1
+        override def mapOver(tp: Type): Type = tp match {
+          case SingleType(pre, sym) =>
+            val pre1 = this(pre)
+            if (!pre1.isStable) pre1.memberType(sym)
+            else super.mapOver(tp)
+          case _ => super.mapOver(tp)
+        }
{code}

It's not entirely clear to me yet whether this is the right fix, though.
the type `object Test.Bar#baz`  (TypeRef(TypeRef(ThisType(object Test),class Bar,List()),  object baz,  List())) is ok, 
but the type `Test.Bar#baz.type` (SingleType(TypeRef(ThisType(object Test),class Bar,List()),  object baz)) is not
I would actually have expected the latter type to be more "conceptually correct" than the former (should we ensure in singleType that the latter is never created, but the former is returned instead? should the subtyping rules be changed to deal with the former kind of singleton type? should we change the representation of these types to use SingleType instead of a TypeRef with a TermSymbol?)

added assert to singleType and performing an `ant strap.done` to see if there were other singleton types being generated that violate this invariant

Martin: please re-assign to me if the proposed fix is ok
