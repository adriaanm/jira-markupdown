Hi Fanf,

the question is which `Class` object should be passed to the annotation. For top-level scala objects, the scala compiler generates two classfiles

{code}
  object o { def x = 1 }
{code}

you get
 * o.class, which has static methods forwarding to the methods of o$$, i.e.
{code}
  class o { static int x() { return o$$.MODULE$$.x(); } }
{code}
 * o$$.class, which contains the actual implementation of the object's methods. The static initializer creates an instance of o$$ and stores it in the MODULE$$ field
{code}
  class o$$ {
    o$$ MODULE$$ = new o$$;
    int x() { return 1; }
  }
{code}

I don't know what `org.apache.directory.server.core.integ.annotations.Factory` expects. If it wants static factory methods, we should pass the `o` class, not `o$$`.

However, calling `o.getClass` in scala returns
{code}
scala> o.getClass
res0: java.lang.Class[_] = class o$$
{code}

----

For nested objects, the additional classfile with static forwarders is *not* generated. Instead, a method is added to the containing class:

{code}
  class A { object p { def x = 1 } }
{code}

generates

 * A.class with
{code}
  class A {
    A$$p$$ p$$module = null;
    A$$p$$ p() {
      if (p$$module == null) { p$$module = new A$$p$$ };
      return A$$p$$;
    }
  }
{code}
 * A$$p$$.class with
{code}
  class A$$p$$ { int x() { return 1; } }
{code}


So in this case there doesn't exist any static methods which could be called.


Again, `getClass` returns the object `A$$p$$`:

{code}
scala> (new A).p.getClass
res0: java.lang.Class[_] = class A$$p$$
{code}


----

We cannot allow `o.getClass` to be a constant because it isn't. Maybe we could hack something because we know that objects are final.

I could allow `classOf[o.type]` and load the module class in this case (`o$$`), but I don't know if this helps in your case. I cannot load the class with the static forwarders (`o`) because this is only generated in the backend, and only for top-level objects.
