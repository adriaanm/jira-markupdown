But it's just static overloading behavior. Everybody loves static overloading behavior.

If the global is loosened to `ExecutionContext`, perhaps it could be renamed to ``I am a reasonable default thread pool`` or, after the next `tlc` merge, `implicit lazy val _: ExecutionContext = ???`.

I could go for a shorter name like `LowBallImps` if necessary, but to support quick demos:
```scala
scala> trait LowPriorityImplicits { implicit def `I am a reasonable thread pool`: ExecutionContext = concurrent.ExecutionContext.global }
defined trait LowPriorityImplicits

scala> object Test extends App with LowPriorityImplicits {
     |   implicit val x: ExecutionContext = ExecutionContext fromExecutor new java.util.concurrent.Executor {
     |     override def execute(r: Runnable) { Console println s"I don't like it, but I'll do it: $r"; r.run }
     |   }
     |   Await ready (Future(Console println 42), Inf)
     | }
defined object Test

scala> Test main null
I don't like it, but I'll do it: scala.concurrent.impl.Future$PromiseCompletingRunnable@3e34ace1
42

scala> object Test extends App with LowPriorityImplicits {
     | Await ready (Future(Console println 42), Inf)
     | }
defined object Test

scala> Test main null
42
```
