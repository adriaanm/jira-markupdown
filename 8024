A couple of details on the problem: It stems from the fact that certain ICODE instructions have no JVM counterparts: instructions such as LOAD_EXCEPTION, SCOPE_ENTER, SCOPE_EXIT and JUMP to the next basic block in the linearization will not be emitted by genJvm or genAsm. 

If we form an entire basic block of such instructions and have an exception handler on it, the generated bytecode will be incorrect, as the exception handler will have an empty scope: thus the Illegal exception table range message.

There are many ways one can compose an no-jvm-instruction basic block: in the bug description, the basic block generate by inline exception handlers was:
```scala
bbX:
    LOAD_EXCEPTION(class Throwable) // <= no JVM instruction necessary for LOAD_EXCEPTION
    STORE_LOCAL(variable exc1)      // <= eliminated as dead code
    LOAD_LOCAL(variable exc1)       // <= eliminated as dead code
    JUMP bb(X+1)                    // <= JUMP to the next basic block in the linearization was skipped
bb(X+1):
    ...
```
and bbX was protected by another exception handler - so for the JVM, that exception handler was protecting nothing.

In the second example, the ICODE instructions are:
```scala
bbX:
    CONSTANT(3)          // <= eliminated as dead code
    STORE_LOCAL(value x) // <= eliminated as dead code
    SCOPE_ENTER value x  // <= no JVM instruction necessary for SCOPE_ENTER
    SCOPE_EXIT value x   // <= no JVM instruction necessary for SCOPE_EXIT
    JUMP bb(X+1)         // <= JUMP to the next basic block in the linearization was skipped
bb(X+1):
    ...
```

So my take on this bug is that it should be fixed in genJvm/genAsm: keep track of the basic blocks that have no instruction emitted and if an exception handler interval only consists of empty blocks, remove the interval.
