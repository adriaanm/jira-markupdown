Found by findbugs 1.3.2 in code generated by 2.7.0-RC2.

The following code generates a call to equals(Object) passing
in a null argument, which should always return false, so there's
no point in having this call in the bytecode.

```scala
class Reflection {
  def foo(clazz : Class[_]) : Unit = {
    val superclass = clazz.getSuperclass()
    if (superclass != null) {
      foo(superclass)
    }
  }
}
```

Here's the bytecode showing the call to equals with a null argument

```scala
public void foo(java.lang.Class);
  Code:
   0:   aload_1
   1:   invokevirtual   SI-18; //Method java/lang/Class.getSuperclass:()Ljava/lang/Class;
   4:   astore_2
   5:   aload_2
   6:   dup
   7:   astore_3
   8:   ifnull  24
   11:  aload_3
   12:  aconst_null
   13:  invokevirtual   SI-22; //Method java/lang/Object.equals:(Ljava/lang/Object;)Z
   16:  ifne    24
   19:  aload_0
   20:  aload_2
   21:  invokevirtual   SI-26; //Method foo:(Ljava/lang/Class;)V
   24:  return
```

Changing the code to use

```scala
    if (!(superclass == null)) {
```

generates the same bytecode.

Using the 'eq' or 'ne' operator generates smaller bytecode that
doesn't have this issue.  Could comparisons using == or !=
against explicit be mapped to the equavalent of the eq or ne
bytecode?
Indeed, Java docs for `Object.equals` state that it should return `false` when the argument is `null`. It also states that it defines a symmetric relationship, and we don't use that when generating code because it's not true quite often. I am reluctant to use assumptions the compiler cannot check when generating code. Although it is very unlikely, someone might break it.

I agree with your last point, and the compiler actually does it for you when you write it the other way around: `null == superclass` is translated to `null eq superclass`. It doesn't do it in the first case because the `equals` method might be overridden, as discussed above.

I don't feel very strongly about this, but it feels more consistent and I don't think this is that bad in terms of performance.
If you read the documentation for Object, it says that equal should:
```scala
For any non-null reference value x, x.equals(null) should return false.
```
However, there is no way for the compiler to be sure that superclass is a non-null reference.  So I am not really sure what FindBugs thinks it is complaining about here.  
You're looking at 'x' but it has already been checked against null before the
equals call.

Here's the byte code:

Get the argument to the method and call getSuperclass() on it:

```scala
   0:   aload_1
   1:   invokevirtual   SI-18; //Method java/lang/Class.getSuperclass:()Ljava/lang/Class;
```

Store the supercalss in local variables 2 & 3 and leave it on the stack:

```scala
   4:   astore_2
   5:   aload_2
   6:   dup
   7:   astore_3
```

Now compare the result of getSuperclass() with null and leave the method if it is null:

```scala
   8:   ifnull  24
```

Now we know 'x' the superclass is not null.

Here's the odd part.  Load the superclass from local variable 3, put a null on the stack with
aconst_null and call x.equals(null), which always returns false.

```scala
   11:  aload_3
   12:  aconst_null
   13:  invokevirtual   SI-22; //Method java/lang/Object.equals:(Ljava/lang/Object;)Z
```


Replying to [comment:3 blair]:
> You're looking at 'x' but it has already been checked against null before the
> equals call.

Sure.

> Now we know 'x' the superclass is not null.
> 
> Here's the odd part.  Load the superclass from local variable 3, put a null on the stack with
> aconst_null and call x.equals(null), which always returns false.

How do you know that? Java doc says so, but the compiler cannot check. Anyone could write an evil equals method that returns `true` for `null`.
So the take away is if you are explicitly comparing to null and
know the class you are comparing to should return false for a
comparision with null, then you should replace the == or != with
an explicit eq or ne.

Updating the ticket to invalid.
So, is there a possibility to re-define Option#applyr1 with the following?
```scala
  def apply[A](x: A): Option[A] = if (x eq null) None else Some(x)
```

r1 https://lampsvn.epfl.ch/trac/scala/browser/scala/trunk/src/library/scala/Option.scala#L25
Replying to [comment:11 ymnk]:
> So, is there a possibility to re-define Option#applyr1 with the following?
> {code}
>   def apply[A](x: A): Option[A] = if (x eq null) None else Some(x)
> }}
> 
> r1 https://lampsvn.epfl.ch/trac/scala/browser/scala/trunk/src/library/scala/Option.scala#L25

Oops, I misunderstood about the comment 8.  
After a lot of wrangling about equality and primitives, scalac of 2.8 will not generate the code for Object.equals() with null argument.
Please ignore my last comment.
