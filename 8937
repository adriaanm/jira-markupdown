True, but given:
```scala
trait SuperC[A,B] {
  def getB(a: A): B
}

trait Foo {
  type A
  type B
  type C <: SuperC[A,B]
}

class Bar[F<:Foo with Singleton](a: F#A, c: F#C) {
  val b = c.getB(a)
}

class MyFoo extends Foo {
  type A = Int
  type B = Int
  type C = MyC
}
trait MyC extends SuperC[Int,Int]
class MySubC extends MyC{
  def getB(a: Int): Int = 3
}
```
I can:
```scala
object Main_ {
  val myFoo = new MyFoo
  val mySC = new MySubC
  new Bar(3, mySC)
}
/*
error: type mismatch;
 found   : Int(3)
 required: ?#A
         new Bar(3, mySC)
                 ^
*/
```
or
```scala
object Main_ {
  val myFoo = new MyFoo
  val mySC = new MySubC
  new Bar[MyFoo](3, mySC)
}
/*
error: type arguments [MyFoo] do not conform to class Bar's type parameter bounds [F <: Foo with Singleton]
         new Bar[MyFoo](3, mySC)
             ^
*/
```
or
```scala
object Main_ {
  val myFoo = new MyFoo
  val mySC = new MySubC
  val bar = new Bar[MyFoo with Singleton](3, mySC)
}
```
But then I have to drag Singleton around everywhere.  And if I pop up a level on my simplification stack:
```scala
  trait SuperC[A,B] {
    def getB(a: A): B
  }

  trait Foo[F<:Foo[F]] {
    type A
    type B
    type C <: SuperC[A,B]

  }

  class Bar[F<:Foo[F] with Singleton](a: F#A, c: F#C) {
    val b = c.getB(a)
  }

  class MyFoo extends Foo[MyFoo with Singleton] {
    type A = Int
    type B = Int
    type C = MyC
  }
  trait MyC extends SuperC[Int,Int]
  class MySubC extends MyC{
    def getB(a: Int): Int = 3
  }
  object Main_ {
    val myFoo = new MyFoo
    val mySC = new MySubC
    new Bar[MyFoo with Singleton](3, mySC)
  }
```
I'm accumulating Singleton at an alarming pace :-)

But at any rate, as much as I'd like to get help fixing my design, I don't mean to spam up this error-message-improving ticket.
