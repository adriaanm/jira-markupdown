Jason Zaugg, your example is almost right, but not quite.

It takes a small variant for DepFunction1 to express the type of:
```scala
def f(a: T1)(b: a.MemberT2): b.MemberT3
```
I'll parametrize over `T1` below, so `f` will be written as:
```scala
def f[T1 <: {type MemberT2 <: {type MemberT3}}](a: T1)(b: a.MemberT2): b.MemberT3 = ???
```
But I assume a concrete type with the right members would also work. I was just too bored to make things that simple :-).

The problem is that for the above case, Return cannot be defined over all types, only over subtypes of T1 with the right type member. So with your DepFunction1, I get this kind error:
```scala
scala> def g[T1 <: {type MemberT2 <: {type MemberT3}}]: DepFunction1[T1, ({type Ret[x <: T1] = DepFunction1[x#MemberT2, ({type Ret[y <: x#MemberT2] = y#MemberT3})#Ret]})#Ret] = ??? 
<console>:8: error: kinds of the type arguments (T1,[x <: T1]DepFunction1[x#MemberT2,[y <: x#MemberT2]y#MemberT3]) do not conform to the expected kinds of the type parameters (type A,type Return) in trait DepFunction1.
[x <: T1]DepFunction1[x#MemberT2,[y <: x#MemberT2]y#MemberT3]'s type parameters do not match type Return's expected parameters:
type x's bounds <: T1 are stricter than type _'s declared bounds >: Nothing <: Any
       def g[T1 <: {type MemberT2 <: {type MemberT3}}]: DepFunction1[T1, ({type Ret[x <: T1] = DepFunction1[x#MemberT2, ({type Ret[y <: x#MemberT2] = y#MemberT3})#Ret]})#Ret] = ??? 
                                                        ^
```
