the problem is the follwoing (after Jason's patch to {{sym.filter(_.isModule == module)}})

ICodeReader is loading the bytecode of `Implicits$ScalaObservable$.class`, there's the instruction `GETSTATIC p1/Implicits$RichFunction1$.MODULE$`.
The ICodeReader will try to create a LOAD_MODULE and find the module symbol for `RichFunction1` (the $ is dropped) using `forceMangledName`. This splits the name "p1/Implicits$RichFunction1" into the three parts, and does a lookup of the TermName "RichFunction1" in class "Implicits". This is done `enteringIcode` ([see here|https://github.com/scala/scala/blob/2.11.x/src/compiler/scala/tools/nsc/symtab/classfile/ICodeReader.scala#L46]), so the module is not found (classes / modules are members of packages after flatten). It would work before flatten (tested). The phase travel to `enteringIcode` was added in [this commit](https://github.com/scala/scala/commit/d95eb2a#diff-400a2e6482bc824c3840c10ecc43e7b0L390). CC @dragos

Once the `forceMangledName` lookup has failed, the ICodeReader will instead use `rootMirror.getModuleByName("p1/Implicits$RichFunction1")` ([see here|https://github.com/scala/scala/blob/2.11.x/src/compiler/scala/tools/nsc/symtab/classfile/ICodeReader.scala#L89]). This lookup succeeds because a classfile with that name exists, and the ClassfileParser created a class and a module symbol with the JAVA flag ([see here|https://github.com/scala/scala/blob/2.11.x/src/compiler/scala/tools/nsc/symtab/classfile/ClassfileParser.scala#L462]). Note that this is predicated with `if (!isScala)`, which is true - the classfile does not have a ScalaSignature. (The classfile has only the Scala marker attribute, so `!isScalaRaw` would be false. What is the reason we use `isScala` there instead?)

The assertion failure that Jason (and me) observed in the backend is then due to the fact that this JAVA marked module symbol is used: if you call {{javaBinaryName}} on such a symbol, the {{$}} is [not added to the name|https://github.com/scala/scala/blob/2.11.x/src/reflect/scala/reflect/internal/Symbols.scala#L1222]. So we end up having two class symbols (the ordinary, unpickled symbol for class {{RichFunction1}}, and the JAVA-marked module symbol with raw name {{Implicits$RichFunction1}}) that have the same internal name.

I'm not sure how much of that we can safely change before 2.11.6.
