Hi Andy,

thanks again for the quick reaction!

I think the test now covers all cases that could possibly go wrong :-)

Concerning the logic (and therefore the code) of the publish() method, after diving into some of the hairy parts (like the ReferenceQueue and GC internals), here are my thoughts:

- an invocation of the publish() method at timestamp t0 has the semantics "notify every listener that is known at t0, exactly once". Let's call the set of these listeners L(t0).
- if **during** that invocation, the state of the listeners changes (say, because of a listenTo() or deafTo() call), that is fine. However, that state change can only happen at timestamp tX (where tX > t0). And it will only affect states L(tY) | (tY > tX > t0) at the publisher.
- since the publish() method is only interested in state L(t0) (which is already "captured" by the call to **listeners.clone()** ), there is actually no need to re-verify the state at the publisher's end of the communication. In fact, it is impossible for the publisher to know (or check) if the listener is still interested in the message. All that the publisher can reasonably do is to know is that the listener **was** interested at the time that the message had been sent (t0) - and therefore, it should deliver it. If the listener has changed its mind in the mean time, that's ok -- but it's something that only the listener can know, not the publisher. Therefore, I think that the call to contains()/containsItem() in the publish() method is actually not needed.

To summarize it in one sentence: the publish() method must ensure that **every listener** that was registered at the time of **calling the method** gets invoked **exactly once**. Therefore, I think that:
```
  def publish(e: Event) { for (l <- listeners.clone()) if (l.isDefinedAt(e)) l(e) }
```

is actually the correct implementation.

Thoughts?

Thanks! :-)
Chris
