Well, maybe type aliases plus named classes will do it after all. It's a pretty heavy burden though.
```scala
package p {
  trait Indexed[A]
  trait Indexable[Repr] { type A }
  object Indexable {
    implicit def indexedIsIndexable[A0] : Indexable[Indexed[A0]] = new Indexable[Indexed[A0]] { type A = A0 }

    /** It works if we instead write that conversion as: */
    // class IndexedIsIndexable[A0] extends Indexable[Indexed[A0]] { type A = A0 }
    // implicit def indexedIsIndexable[A] : IndexedIsIndexable[A] = new IndexedIsIndexable[A]
  }

  object IndexedView {
    def apply[Coll](repr: Coll)(implicit tc: Indexable[Coll]): IndexedView[Coll, tc.A] = new IndexedView[Coll, tc.A](repr)(tc)
  }
  final class IndexedView[Coll, A](val repr: Coll)(implicit val tc: IndexableType[Coll, A]) {
    final def map[B](f: A => B): IndexedView[Coll, B] = ???
    final def force: Indexed[A] = ???
  }

  class Foo {
    def bufferAt(i: Int): String  = ???
    def indices: Indexed[Int]     = ???
    def contents: Indexed[String] = indices map bufferAt force
    // ./a.scala:23: error: type mismatch;
    //  found   : Int => String
    //  required: tc.A => ?
    //     def contents: Indexed[String] = indices map bufferAt force
    //                                                 ^
    // one error found
  }
}

package object p {
  implicit def liftIndexedView[Coll](repr: Coll)(implicit tc: Indexable[Coll]): IndexedView[Coll, tc.A] = IndexedView(repr)

  type IndexableType[Repr, A0] = Indexable[Repr] { type A = A0 }
}
```
