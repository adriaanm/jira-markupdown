Note the workaround is not a solution for all cases, because this bug infects function definition sites that I can't edit, e.g. the {{apply}} method of {{object Array}}.

I was attempting to code with reduced noise and reduced tsuris of *unboxed* disjunctions.

{code}
scala> val test = Array[DD[D[Int] with D[Option[Nothing]]]](None, 1, 2, None, 3)
error: type mismatch;
 found   : None.type (with underlying type object None)
 required: DD[D[Int] with D[Option[Nothing]]]
       val test = Array[DD[D[Int] with D[Option[Nothing]]]](None, 1, 2, None, 3)
                                                            ^

scala> val test = Array[DD[D[Option[Nothing]] with D[Int]]](None, 1, 2, None, 3)
error: type mismatch;
 found   : Int(1)
 required: DD[D[Option[Nothing]] with D[Int]]
       val test = Array[DD[D[Option[Nothing]] with D[Int]]](None, 1, 2, None, 3)
                                                                  ^
{code}

I can avoid the bug by verbosely forcing the choice of implicit, thus verifying that this bug is culpable.

{code}
type None = Option[Nothing]

val test = Array[DD[D[None] with D[Int] with D[String]]]( None, 1 : DD[D[Int]], "two" : DD[D[String]] )

scala> test(0).get match {
  case x:D[_] => x.get match {
    case x:None => 1
    case x:Int => 2
    case x:String => 3
    case _ => 4
  }
}
res0: Int = 1

scala> test(1).get match {
  case x:D[_] => x.get match {
    case x:None => 1
    case x:Int => 2
    case x:String => 3
    case _ => 4
  }
}
res1: Int = 2
{code}

And even if I could edit the {{apply}} method, the sequence {{T*}} subsumes to {{Any}} before the implicit for the workaround is applied. So only the bug fix can help.

{code}def apply[T](xs: T*)(implicit d: DD[D[T]] <:< DD[D[Int] with D[String]]) = xs

scala> apply(1)
res4: Int* = WrappedArray(1)

scala> apply("")
res5: java.lang.String* = WrappedArray()

scala> apply(1, "")
error: could not find implicit value for parameter d: <:<[DD[D[Any]],DD[D[Int] with D[String]]]
       apply(1, "")
            ^
{code}
