(s/string/blerg/g from the original example)

During erasure, the compiler lubs the two branches of the if, and ends up calling:


https://github.com/scala/scala/blob/1d67fe/src/reflect/scala/reflect/internal/Symbols.scala#L1439
```scala

// in Type#elimAnonymousClass($anon#10194)

clazz.classBound.asSeenFrom(pre, clazz.owner)


// in Symbol#classBound

this       // anonymous class $anon#10194

val tp = refinedType(info.parents, owner) // Object#1815
val thistp = tp.typeSymbol.thisType       // Object#1815
info.decls // Scope{
           //  def <init>#10195(arg$outer#16869: repro.CausesProblems#7101): $anon#10194;
           //  override def blerg#10196(): String#1899;
           //  val repro$CausesProblems$$anon$$$outer#11591(): repro.CausesProblems#7101;
           //  private[this] val $outer#11592: repro.CausesProblems#7101

// Egads!
addMember(Object#1815, Object#1815, blerg#10196)
addMember(Object#1815, Object#1815, repro$CausesProblems$$anon$$$outer#11591)
```

I tracked this down by adding this to `Scope#enter`:
```scala

      try {
        if (e.sym.name.containsName("blerg") && this == definitions.ObjectClass.info.decls) {
          println("phase = " + phase)
          println("Entering into: " + System.identityHashCode(this))
          println("System.identityHashCode(definitions.ObjectClass.info.decls): " + System.identityHashCode(definitions.ObjectClass.info.decls))
          println("Containing: " + this.map(_.nameString).mkString(","))
          println("From: " + Thread.currentThread().getStackTrace.take(10).map(_.getMethodName).mkString(" -> "))
          println("definitions.ObjectClass.info.decl(newTermName(\"blerg\")) = " + definitions.ObjectClass.info.decl(newTermName("blerg")))
        }
      } catch {
        case x: Throwable => // ignore
      }
```

I'm not sure about the right way to avoid this.
