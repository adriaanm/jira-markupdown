One more quirk that I discovered: a type refinement in a pattern match clause doesn't seem to work properly when the refined type is used in a, uh, "type refinement" in the different sense of explicitly providing type constraints. With 2.7.1.r15804-b20080816212059, the following fails:
```scala
object T3 {
  class A { type T }
  case class B[X]
  object C extends B[Int]
  def f[X](b : B[X]) : A { type T = X } = b match { 
    case C => new A { type T = Int }
  }
}

T3.scala:6: error: type mismatch;
 found   : T3.A{ ... }
 required: T3.A{type T = X}
    case C => new A { type T = Int }
```

However, this can be worked around by using a simple wrapper class around the refined type. With the following change it works:
```scala
  def f[X](b : B[X]) : A { type T = X } = {
    case class W[Y](a : A { type T = Y })
    val w : W[X] = b match { 
      case C => W[Int](new A { type T = Int })
    }
    w.a
  }
```
