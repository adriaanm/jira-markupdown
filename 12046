Great test case!

Lambdalift basically assumes a world without overloading, a restriction which is enforced for local methods:
```scala
def foo { def bar(a: Int) = 0; def bar(a: String) = 0 } //  error: method bar is defined twice
```

However, this is not enforced for constructors of local classes, which are handled by the same code in lambdalift (see {{addFreeParams}}).

One possible resolution of this bug would be to enforce such a restriction (although it would need to be phased with a deprecation warning)

An analagous condundrum exists in the Java compiler when it needs to add constructors to a class to allow inner classes to invoke a private enclosing constructor. Java adds dummy parameter to the method to avoid ambiguity with existing constructors. See https://github.com/scala/scala/pull/2750 for some more details. This approach might also work here, but I don't think the cost/benefit stacks up.


