While working on scala/bug#5130 I spotted this method:
```scala
  // Optimization to avoid creating unnecessary new typerefs.
  def copyTypeRef(tp: Type, pre: Type, sym: Symbol, args: List[Type]): Type = tp match {
    case TypeRef(pre0, sym0, _) if (pre0 eq sym0) && sym0.name == sym.name =>
      if (sym.isAliasType && sameLength(sym.info.typeParams, args) && !sym.lockOK)
        throw new TypeError("illegal cyclic reference involving " + sym)

      TypeRef(pre, sym, args)
    case _ =>
      typeRef(pre, sym, args)
  }
```

1.- The first case will never be followed: both Type and Symbol are classes and they don't extend each other, so a Type and a Symbol can ever be "eq" to each other... Â¿am I right?

2.- Where is the optimization it promises in the heading comment?
