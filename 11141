Thanks @satyagraha,

I managed to minimize it a bit further, I can reproduce your problem locally.

{code}
package org.anomaly
object AnomalyApp3 extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  val source1 = Promise[Int]()
  val source2 = Promise[Int]()
  source2.completeWith(source1.future).future.onComplete {
    case completion => print(s"source2 completed with: ${completion}")
  }
  source2.tryFailure(new TimeoutException)
  source1.success(123)
}
{code}
