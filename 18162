The best way to explain what is going on is to present the following REPL transcript:
```scala
Welcome to Scala version 2.10.0 (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_43).
Type in expressions to have them evaluated.
Type :help for more information.

scala> :paste
// Entering paste mode (ctrl-D to finish)

object Outer {
  class Inner { type Xyz }
 
  type TypeInner = Inner { type Xyz = Int }
}
object Bar { 
  def bar: Outer.TypeInner = null
}

// Exiting paste mode, now interpreting.

defined module Outer
defined module Bar

scala> :power
** Power User mode enabled - BEEP WHIR GYVE **
** :phase has been set to 'typer'.          **
** scala.tools.nsc._ has been imported      **
** global._, definitions._ also imported    **
** Try  :help, :vals, power.<tab>           **

scala> typeOf[Bar.type].member("bar": TermName).info.resultType
res0: $r.intp.global.Type = Outer.TypeInner

scala> res0.normalize
res1: $r.intp.global.Type = Outer.Inner{type Xyz = Int}

scala> res1.member("Xyz": TypeName).flags
res2: Long = 0

scala> res0.dealias
res3: $r.intp.global.Type = Outer.Inner{type Xyz = Int}

scala> res3.member("Xyz": TypeName).flags
res4: Long = 2
```

There are couple of observations:
1. Both `dealias` and `normalize` return types with newly allocted symbols for refinements. This can be verified by running with -uniqid. Do they have to do that in this case?
2. In this particular case dealias and normalize probably should return exactly the same types but they don't. The flags differ for symbols referred by those types. The `dealias` is right here.

This inconsistency causes spurious recompilations in sbt for projects with code structure as presented above.
