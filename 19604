scala.concurrent.duration.Duration.Inf is a specific instance - i.e. 
{code:scala}
val Inf: Infinite = new Infinite {
    override def toString = "Duration.Inf"
    def compare(other: Duration) = other match {
      case x if x eq Undefined => -1 // Undefined != Undefined
      case x if x eq this      => 0  // `case Inf` will include null checks in the byte code
      case _                   => 1
    }
    def unary_- : Duration = MinusInf
    def toUnit(unit: TimeUnit): Double = Double.PositiveInfinity
  }
{code}
This all works brilliantly unless you send it from one VM to another (say via a remote Akka call). If you do, it creates a *new* "Duration.Inf" instance, so now it is no longer a singleton in the receiving VM.

If you then pass this new Duration.Inf into Await.result or something you receive a MatchError in scala.concurrent.impl.Promise.tryAwait(...)  here:
{code:scala}
    /** Try waiting for this promise to be completed.
     */
    protected final def tryAwait(atMost: Duration): Boolean = if (!isCompleted) {
      import Duration.Undefined
      import scala.concurrent.Future.InternalCallbackExecutor
      atMost match {
        case e if e eq Undefined => throw new IllegalArgumentException("cannot wait for Undefined period")
        case Duration.Inf        =>
          val l = new CompletionLatch[T]()
          onComplete(l)(InternalCallbackExecutor)
          l.acquireSharedInterruptibly(1)
        case Duration.MinusInf   => // Drop out
        case f: FiniteDuration   =>
          if (f > Duration.Zero) {
            val l = new CompletionLatch[T]()
            onComplete(l)(InternalCallbackExecutor)
            l.tryAcquireSharedNanos(1, f.toNanos)
          }
      }

      isCompleted
    } else true // Already completed
{code}

i.e. It attempts to match the Duration.Inf instances and fails because they are different - and you end up with a confusing error saying "MatchError: Duration.Inf" even though there is clearly a match case for it.
