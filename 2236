I can override askShutdown() and askReset() as following code to force the runner thread poll a awake action:
```scala
  /**
   * In interactive.Global, the `newRunnerThread` always waits for `scheduler.waitForMoreWork()`
   * before `pollForWork()`, which may cause raised `except`s never have chance to be polled, if
   * there is no more `WorkItem` in `todo` queue, so I have to post another Action to awake it.
   * @Ticket SI-2289
   */
  override def askShutdown() = {
    scheduler.raise(new ShutdownReq)
    scheduler postWorkItem {() => println("A action to awake scheduler to process shutdown except")}
  }

  override def askReset() = {
    scheduler.raise(new FreshRunReq)
    scheduler postWorkItem {() => println("A action to awake scheduler to process reset except")}
  }
```

But, for "shudown", the loop seems not working, I think the proper approach to stop a thread should be something like:
```scala
  /** Create a new presentation compiler runner.
   */
  def newRunnerThread: Thread = new Thread("Scala Presentation Compiler") {
    override def run() {
      try {
        while (true) {
          scheduler.waitForMoreWork()
          pollForWork()
          while (outOfDate) {
            try {
              backgroundCompile()
              outOfDate = false
            } catch {
              case ex: FreshRunReq =>
            }
          }
        }
      } catch {
        case ex: InterruptedException =>
          Thread.currentThread.interrupt // interrupt again to avoid posible out-loop issue
        case ex: ShutdownReq =>
          Thread.currentThread.interrupt
        case ex => 
          outOfDate = false
          compileRunner = newRunnerThread
          ex match { 
            case _ : ValidateError => // This will have been reported elsewhere
            case _ => ex.printStackTrace(); inform("Fatal Error: "+ex)
          }
      }
    }
    start()
  }
```
