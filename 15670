[This is a general enhancement]

if you declare a variable inside try block, it is not available in catch or finally sections, e.g.
{code}
try {
 val x = new Integer(0)
} catch {
 println (x) //syntax error
} finally {
 println(x) //syntax error
}
{code}
This design (present in Java, for example) creates a lot of boilerplate code. 
Typically, the catch and finally clauses are doing cleanup work, and therefore they NEED access to anything defined in try. 
So common pattern is to move the relevant declarations OUT of the try/catch/finally block, e.g. in Java:


{code}
MyClass x = null;
try {
 x = new MyClass();
} finally {
 if (x!=null) GarbageCollector.cleanup(x);
}
{code}
This is not very elegant:
[[BR]]
1) x is not really used outside of the block, so it clutters the namespace. In Scala, try can return a value if it is needed outside of try/catch/finally
[[BR]]
2) x is forced to be a var, but it my not have to be
[[BR]]
3) x needs a dummy initial value, which is quite useless, and often is null

I am proposing to move x inside try, but let catch and finally have it in scope
{code}
try {
 val x = new MyClass
} finally {
 if (x!=null) GarbageCollector.cleanup(x);
}
{code}
The only problem here is that x may not have been assigned a value (here due to exception in MyClass constructor). But can it simply be null in this case? Note that this code is equivalent to previous example, but simply does not expose x outside of the try/catch/finally block, plus lets it be a val
Note that the compiler would have to track which variables were not initialized, and provide a null default value

Null references are not actually encouraged in Scala, so we could implement this with Option instead
{code}
try {
 val x: Option[MyClass] = Some(new MyClass)
} finally {
 if (x!=None) GarbageCollector.cleanup(x.get)
 //or even GarbageCollector.cleanup(x), where GarbageCollector knows how to handle Option
}
{code}
This will require special handling of Option in the compiler, providing the value None for all variables where assignment has not happened

----

I have no idea how feasible it would be to fill in unassigned  variables with defaults, but definitely moving variables defined in try into scope for catch/finally and letting the programmer handle the complexities is already useful: 

{code}
try {
 val x: Option[MyClass] = None
 x = Some(new MyClass)//can throw
} finally {
 if (x!=None) GarbageCollector.cleanup(x.get)
}
{code}

I believe implementing this will result in cleaner(=less buggy) code
