Yes, of course, you're right. Hashing is so much fun I forget that numbers
aren't just bit patterns, but have actual semantics.

So a case class probably needs a hash code based on something like
`foldProductHashCodesLeft` rather than `foldProductRawBitsLeft` (unless you
would rather postpone thinking about this until VMs are good enough to make
an implementation based on `foldProductElementsLeft` perform reasonably, if
that ever happens).

On a related note, though, there may be room for improvement in the hash code
for `Long` in `ScalaRunTime`. That is computed (as of
scala-2.9.0.r23230-b20101012020216) as:

{code}
  @inline def hash(lv: Long): Int = {
    val iv = lv.toInt
    if (iv == lv) iv else lv.hashCode
  }
{code}

The following formulation gives the same answer as the current function for
the `Int` range (as required), but runs faster on my machine:

{code}
  @inline def hash(lv: Long): Int = {
    val low = lv.toInt
    val lowSign = low >>> 31
    val high = (lv >>> 32).toInt
    low ^ (high + lowSign)
  }
{code}

In my experience, a conditional branch takes several times as long as a shift or
add, which I believe is typical of modern processors.

(Whether such a simple hash function for `Long` (or `Int`, for that matter) is
advisable at all depends on whether you're using the value as a counter or as a
collection of (possibly poorly distributed) bit fields, but that's a whole other
topic.)

There is also an issue for the hash code for `Double`, but as it appears to be an
actual bug, I have opened Ticket SI-3957 for it.
