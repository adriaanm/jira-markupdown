There seems to be a conversion Fragment=>Fragments in FragmentBuilder that breaks the tie.

{code}
val fragged: Fragments = null.asInstanceOf[Fragment] // compiles
{code}

Minimized, the situation is:
{code}
class Foo {
  def f(x: Fragment): Unit = { }
  def f(x: Fragments): Unit = { }
}
object Test extends App {
  implicit def a(x: DecoratedResult[DataTable]): Fragment = null
  implicit def b(x: DecoratedResult[DataTable]): Fragments = null
  implicit def c(x: Fragment): Fragments = null
  (new Foo).f(null.asInstanceOf[DecoratedResult[DataTable]])
}
{code}
So a and b make both fs applicable, but c makes the first more specific because the second f applies to (c(_:Fragment)).

I don't know anything about the interesting codebase (though I hope to), so I really could have used more tool support in browsing this issue.  This was too much for me:
-Xlog-implicits -Xlog-implicit-conversions -Ydebug -Yinfer-debug
I just used grep. Also, I kept losing the implicit annotation in Eclipse. The greatest would be to right-click the annotation and see the answer, namely, what implicits are in scope and the overload resolution scorecard between candidates.

