I think the type checker is indeed right in rejecting this (at least Ingo's simplified example needs to be rejected). I have renamed the various aliases to make clearer what goes on.
{code}
class GraphFun { 
  class Node(val out : Edge)
  class Edge
}

class CfgFun {
  val gfun = new GraphFun

  class Cfg {
    type Node1 = gfun.Node
    type Edge1 = gfun.Edge
  }
}

object DFST {
  def apply(cfg : CfgFun#Cfg) {
    type Node2 = cfg.Node1
    type Edge2 = cfg.Edge1

    def visit(n: Node2, e: Edge2): Unit = visit(n, n.out)
    ()
  }
}
{code}
Now, in n.out, the expression n is first typed DFST.this.Node2. When we 
compute the type of n.out we have to dereference that alias. Dereferencing works transitively, first we get the alias cfg.Node1 and then we get the base definition
_3.Cfg.Node. The _3 is an existential which stands for the unknown prefix in the type CfgFun#Cfg. Given this, it's natural that n.out has then type _3.Cfg.Edge, and this type is incompatible with DFST.this.Edge.

You can trace these things for yourself by compiling with -Xprint-types -Ytyper-debug. It will give you a complete account of the typing made.


