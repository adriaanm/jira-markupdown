The override ensures that the name is correct. Abstract members can add information, and are not redundant.
```scala
trait A { type T } ; trait B extends A { type T <: Y } ; trait C extends B { override type U <: Z }

// same with value members. Nice to have override in D.

trait C { def c: Int } ; trait D extends C { val c: Int }

trait C { def c: X } ; trait D extends C { def c: Y }
```
