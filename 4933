I give up.

After figuring out the problem and the obvious fix, I've spent more than a day looking for a way that does not cause cyclesr1 during quick.lib.

The obvious fixr2 is to simply change the two occurrences of `processClassType(processInner(???.tpe))` in `sigToType`
to `processClassType(processInner(transformedTpe(???)))`, with:
```scala
// SI-3943
// cls.tpe.prefix is the thisType of the enclosing class of cls's definition
// later, we'll widen the this-type to the corresponding typeref (with type arguments that blindly refer
//   to the enclosing class's type parameters)
// since we're computing sym's signature, cls.tpe needs to be re-interpreted in the context of sym.enclClass.thisType
// otherwise, cls.tpe.widen may refer to type parameters of its enclosing class, which are not in scope where sym is defined
lazy val site = if(sym eq null) null else sym.enclClass.thisType
def transformedTpe(cls: Symbol) = if((site eq null) || cls.isStatic) cls.tpe else site.memberType(cls)
```

I've tried various approaches with LazyTypes, but the fact that these prefixes may occur in the super class type, method parameter types&result type,... makes it seem like an unlikely solution.

The only alternative I could think of was something like cooking raw types, but I can only hope there's a better way...


r1 assertion failed: illegal class file dependency between 'object ListItr' and 'class ListItr'
```scala
69.     assert(!busy.isDefined, {
          val (s1, s2) = (busy.get, root)
          if (s1 eq s2) "unsatisfiable cyclic dependency in '%s'".format(s1)
          else "illegal class file dependency between '%s' and '%s'".format(s1, s2)
        })
```

r2 https://github.com/adriaanm/scala/commit/95bcc3f39705e87e2f877a84118cb8cb2b11c076
