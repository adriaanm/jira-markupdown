The unwillingness to compile is correct. I reformulated the example a little to show a soundness failure; I'm not sure it's similar enough to convince everyone. The key is that the type system must not lose sight of the fact that these Arrays have an element type which is unknown and unknowable - if anyone ever thinks he has a value of the right type, then unsoundness has occurred (because that value would be assignable to both Array[Int] and Array[String]).

Allowing "Type" to be equated to type parameter "A" and then to go on its merry way unsoundly materializes that unknowable type.
```scala
class ExistentialTypeInference[A](val a: Array[A]) {
  type Type = A
  def put(x: Type) = a(0) = x
  // Even 2.9 knows better than to let this through:
  // def put(x: A) = a(0) = x
}

object ExistentialTypeInference {
  def main(args: Array[String]) {
    val arraySeq = Seq[Array[_]](Array(1, 2), Array("2", "3"))
    val t1       = new ExistentialTypeInference(arraySeq.head)
    val t2       = new ExistentialTypeInference(arraySeq.last)

    t1 put t2.a(0)
  }
}
/***
java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer
	at scala.runtime.BoxesRunTime.unboxToInt(Unknown Source)
	at scala.runtime.ScalaRunTime$.array_update(ScalaRunTime.scala:69)
	at ExistentialTypeInference.put(b.scala:3)
	at ExistentialTypeInference$.main(b.scala:12)
	at ExistentialTypeInference.main(b.scala)
***/
```
And in 2.10, we fail as we must.
```scala
% rcscalac b.scala 
b.scala:12: error: type mismatch;
 found   : _$1
 required: t1.Type
    (which expands to)  _$1
    t1 put t2.a(0)
               ^
one error found
```
