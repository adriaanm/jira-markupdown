Suppose we have the following two type classes, an instance of the first for an either-like trait, and a way of building instances of the first from some specific instances of the second:

{code}
trait Foo[F[_]]
trait Bar[F[_], A]

trait Or[A, B]

implicit def orFoo[A] = new Foo[({type L[X] = Or[A, X]})#L] {}
implicit def barFoo[F[_]: Foo] = new Foo[({type L[X] = Bar[F, X]})#L] {}
{code}

Now we can define a couple of type aliases:

{code}
type StringOr[X] = Or[String, X]
type BarStringOr[X] = Bar[StringOr, X]
{code}

And get an instance of our first type class:

{code}
scala> implicitly[Foo[BarStringOr]]
res1: Foo[BarStringOr] = $anon$1@4b5a1133
{code}

But when we try the same thing with a type lambda, we get an error:

{code}
scala> implicitly[Foo[({type L[X] = Bar[StringOr, X]})#L]]
<console>:14: error: could not find implicit value for parameter e: Foo[[X]Bar[[X]Or[String,X],X]]
              implicitly[Foo[({type L[X] = Bar[StringOr, X]})#L]]
                        ^
{code}

I asked [a question on Stack Overflow|http://stackoverflow.com/q/13996601/334519] about this last week, but haven't gotten any answers, and I haven't been able to find any previous issues that address the problem (a comment on my question points to [this open improvement|https://issues.scala-lang.org/browse/SI-2712], but I don't see how this could be a type constructor inference issue).
