Suppose we have the following two type classes, an instance of the first for an either-like trait, and a way of building instances of the first from some specific instances of the second:
```scala
trait Foo[F[_]]
trait Bar[F[_], A]

trait Or[A, B]

implicit def orFoo[A] = new Foo[({type L[X] = Or[A, X]})#L] {}
implicit def barFoo[F[_]: Foo] = new Foo[({type L[X] = Bar[F, X]})#L] {}
```

Now we can define a couple of type aliases:
```scala
type StringOr[X] = Or[String, X]
type BarStringOr[X] = Bar[StringOr, X]
```

And get an instance of our first type class:
```scala
scala> implicitly[Foo[BarStringOr]]
res1: Foo[BarStringOr] = $anon$1@4b5a1133
```

But when we try the same thing with a type lambda, we get an error:
```scala
scala> implicitly[Foo[({type L[X] = Bar[StringOr, X]})#L]]
<console>:14: error: could not find implicit value for parameter e: Foo[[X]Bar[[X]Or[String,X],X]]
              implicitly[Foo[({type L[X] = Bar[StringOr, X]})#L]]
                        ^
```

I asked [a question on Stack Overflow](http://stackoverflow.com/q/13996601/334519) about this last week, but haven't gotten any answers, and I haven't been able to find any previous issues that address the problem (a comment on my question points to [this open improvement](https://issues.scala-lang.org/browse/SI-2712), but I don't see how this could be a type constructor inference issue).
