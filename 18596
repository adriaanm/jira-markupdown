Quoting Iulian:
{quote}
I noticed a pretty serious problem regarding importers. As we stand now, the compiler is single-threaded, and the presentation compiler enforces this by checking no symbols are initialized outside the compiler thread.

An importer operates in between two compiler instances, and can force symbols on both sides. Therefore, in the presentation compiler there is no one correct thread on which to execute the call to `importSymbol`. There could be various hacks (like forcing a symbol and its owner chain on one thread, and then calling importSymbol on another thread), but they are error-prone and maybe don't even solve the issue.

We end up working around these limitations too much, and I think this needs to be fixed in the reflection library. Right now, we're forcing the owner chain of from.Symbol on "PC thread From" before calling importSymbol in "PC thread To". But that's not enough, and now we're going to also initialize companion classes/modules before calling importSymbol. There must be a better way...
{quote}

Just for your own curiosity, this is how our code using symbol importer look like https://github.com/scala-ide/scala-search/pull/73/files

Which shows in code exactly what Iulian described. It feels too brittle to be right.
