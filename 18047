Ignoring the fact that I have to give the type argument explicitly and annotate the type in great detail, it's safely a bug that it works once and then blows up from that point forward. (How do we even have bugs like that, what is hanging onto such state?)
{code}
package j;

import java.util.*;

public class J {
  public static <E> List<E> copyOf(Iterable<? extends E> elements) { return null; }
  public static <E> List<E> copyOf(Collection<? extends E> elements) { return null; }
  public static <E> List<E> copyOf(Iterator<? extends E> elements) { return null; }
  public static <E> List<E> copyOf(E[] elements) { return null; }
}
{code}

{noformat}
/***

scala> j.J.copyOf[String](new java.util.ArrayList[String]: java.util.Collection[_ <: String])
res0: java.util.List[String] = null

scala> j.J.copyOf[String](new java.util.ArrayList[String]: java.util.Collection[_ <: String])
<console>:34: error: type mismatch;
 found   : java.util.ArrayList[?0] where type ?0
 required: java.util.Collection[_ <: String]
              j.J.copyOf[String](new java.util.ArrayList[String]: java.util.Collection[_ <: String])
                                 ^
***/
{noformat}
