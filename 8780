```
The actual arguments that are eligible to be passed to an implicit parameter of type T fall into two categories. First, eligible are all identifiers x that can be accessed at the point of the method call without a prefix and that denote an implicit definition (§7.1) or an implicit parameter. An eligible identifier may thus be a local name, or a member of an enclosing template, or it may be have been made accessible without a prefix through an import clause (§4.7). If there are no eligible identifiers under this rule, then, second, eligible are also all implicit members of some object that belongs to the implicit scope of the implicit parameter’s type, T .
```

The spec seems very wrong: it tells me that the presence of **any** implicit in scope, e.g. any of those I get from `import Predef._`, should inhibit the companion scope search.

The implementation looks like:
```scala
def inferImplicit(tree: Tree, pt: Type, reportAmbiguous: Boolean, isView: Boolean, context: Context, saveAmbiguousDivergent: Boolean, pos: Position): SearchResult = {
...
var result = searchImplicit(context.implicitss, true)

if (result == SearchFailure) {
  val previousErrs = context.flushAndReturnBuffer()

  result = materializeImplicit(pt)

  // `materializeImplicit` does some preprocessing for `pt`
  // is it only meant for manifests/tags or we need to do the same for `implicitsOfExpectedType`?
  if (result == SearchFailure) result = searchImplicit(implicitsOfExpectedType, false)

  if (result == SearchFailure) {
    context.updateBuffer(previousErrs)
  }
}
}
```

I'm going to seek a clerical interpretation on this one from Martin. At a minimum, the definition of "eligible" must be updated to "and conforms to the T". Then, we have to clarify what should happen when there is ambiguity. I'll track this under scala/bug#6667.
