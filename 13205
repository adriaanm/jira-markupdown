Define the following method:

{code}
scala> def idMap[C[_],T](m: { def map[U](f: T => U): C[U] }): C[T] = 
     |   m.map(t => t)
idMap: [C[_],T](AnyRef{def map[U]((T) => U): C[U]})C[T]
{code}

Try to use it:
{code}
scala> idMap(Some(8))
<console>:6: error: inferred the kinds of the type arguments (Option[B],Int) do not conform to the expected kinds of the type parameters (type C,type T).
Option[B]'s type parameters do not match type C's expected parameters: class Option has one type parameter, but type C has one
       idMap(Some(8))
       ^
{code}

I expected Scala to correctly infer the call to `idMap`. In any case, the message `"... class Option has one type parameter, but type C has one ..."` doesn't help much.

If you help the type inferencer, it works correctly:

{code}
scala> idMap[Option,Int](Some(8))
res8: Option[Int] = Some(8)
{code}
