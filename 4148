I guess you're right, it's probably best if start stays fully idempotent, and does not restart a crashed Actor.

However (please correct me if I'm wrong here, I'm no Erlang expert) I think restart capability is still important in the Scala case. In Erlang, of course, you would "throw away" a crashed process and a supervisor would start a new one, registered under the same name (did I get this right?). But there is no registering of (non-remote) actors in Scala, so how would other actors find the replacement for the crashed one?

Restarting under the same process-id would not fit Erlang well, since Erlang is more "pure", no reassignment of variables, etc. But with Scala, I think, restarting would make a lot of sense, since the Actor reference would stay valid, and we don't need a registering mechanism. Not centrally registering actors has a lot of advantages, it makes unused Actors available for GC for example, and the VM will determine for us if an Actor is still in use (i.e. referenced) or not.

So using the Actor's reference as the primary "key" to locate and access it should fit Scala very well. As far as Jonas (Akka's) Actors are concerned, they are certainly restartable (they even provide pre-/post-restart callbacks), from what I've seen. I guess the new ActorID's in Akka stay valid after a restart, too, but I haven't verified this.

Or did I get this wrong, is there already a way to locate a replacement actor in Scala? In that case, we can close this. If not, I'd plead for adding a simple `Actor.restart()`, maybe throwing an exception if the Actor is not in terminated state to make things safe.

I'll turn this from a regression into an urgent feature request, since my app currently hangs after an actor crashes. :-)
