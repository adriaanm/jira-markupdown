The following code causes bogus type error, when anonymous classes are used as parameters:
{code}
class B
object C extends B

class F[T <: B](cons: => T)
class F2[T <: B](cons: => T) extends F(cons)

object D extends F2(C) // works
object E extends F2(new B {})
{code}
{code}
test.scala:8: error: illegal inheritance;
 self-type ESI-8849.type does not conform to F2SI-8845[BSI-11]'s selftype F2SI-8845[BSI-11]
object E extends F2((new B {}))
                 ^
test.scala:8: error: type mismatch;
 found   : BSI-11
 required: BSI-11
object E extends F2((new B {}))
                     ^
two errors found
{code}

Possible workaround at the moment is to provide an explicit type ascription:
{code}
object E extends F2(new B {}:B)
{code}
