See the error message below? I use filter but it's not defined: I see, it *seems* I'm a bad kid. But... where is the call to filter? Is the compiler really complaining on the call to withFilter (retorical question, answer: yes)?

{code}
[error] /Users/pgiarrusso/Documents/Research/Sorgenti/linqonsteroids/src/main/scala/ivm/optimization/SubquerySharing.scala:372: value filter is not a member of ivm.expressiontree.Lifting.TypeMappingApp[Traversable,TupleTAnd,AnyRef,T]
[error]             Some(ConstByIdentity(t.asInstanceOf[TypeMapping[Traversable, TupleTAnd, AnyRef]], cTag, tTag).get[T](clazz) /*map(_._1) */withFilter Fun.makefun(cond, fx).f)
[error]                                                                                                                                       ^
{code}

I did not believe my eyes (I was also tired, so that was a good idea), but after a couple of minutes I realized I should trust them more than my computer.

Grepping withFilter on the compiler reveals the following wonder in Typers:
{code}
            val tree1 = // temporarily use `filter` and an alternative for `withFilter`
              if (name == nme.withFilter)
                silent(_ => typedSelect(tree, qual1, name)) match {
                  case SilentResultValue(result) =>
                    result
                  case _ =>
                    silent(_ => typed1(Select(qual1, nme.filter) setPos tree.pos, mode, pt)) match {
[...]
{code}

I know this was intended. It's even documented somewhere, IIRC about the desugaring of for comprehensions (where it makes total sense). But whenever I call withFilter? Also, this was introduced IIRC in 2.8.
Could we please, at the very least, deprecate this aliasing in 2.10, so that it can be removed in 2.11? Or improve the error message?
