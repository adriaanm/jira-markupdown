Actually, I think this is a bug (or maybe an invalid assumption) in LambdaLift.

The following source:
```scala
abstract class WA extends DelayedInit {
  override def delayedInit(x: => Unit): Unit = x
}

class C {
  def b(s: String) = null

  {
    val symbol = "ABC"
    new WA {
      b(symbol)
      def foo = symbol
    }
  }
}
```

prints after lambdalift as
```scala
package <empty> {
  abstract class WA extends Object with DelayedInit {
    def <init>(): WA = {
      WA.super.<init>();
      ()
    };
    override def delayedInit(x: Function0): Unit = x.apply$mcV$sp()
  };
  class C extends Object {
    def <init>(): C = {
      C.super.<init>();
      ()
    };
    def b(s: String): Null = null;
    {
      val symbol: String = "ABC";
      {
        new <$anon: WA>(C.this, symbol)
      }
    };
    final class $anon$1 extends WA {
      def <init>($outer: C, symbol$1: String): <$anon: WA> = {
        $anon$1.super.<init>();
        ()
      };
      $anon$1.this.$outer.b(symbol$1);
      def foo(): String = $anon$1.this.symbol$1;
      <synthetic> <paramaccessor> <artifact> private[this] val $outer: C = _;
      <synthetic> <stable> <artifact> def $outer(): C = $anon$1.this.$outer;
      <synthetic> <paramaccessor> private[this] val symbol$1: String = _
    }
  }
}
```

Note that the two references to `symbol$1` are not translated in the same way: one is a direct `Ident` to the constructor parameter, the other a `Select` of the field. I think both should be translated to field accesses.
