These are just bugs. There's no reason for "override def foo()" not to widen the access to public just because it's an anonymous class. If you wanted it to remain protected, you would have written "override protected def foo()".
```scala

scala> abstract class FooClass { protected def bar: Int }
defined class FooClass

scala> val x = new FooClass { def bar = 1 }
x: FooClass = $anon$1@7da72267

scala> x.bar
<console>:10: error: method bar in class FooClass cannot be accessed in FooClass
 Access to protected method bar not permitted because
 enclosing object $iw is not a subclass of 
 class FooClass where target is defined
              x.bar
                ^

scala> val x = new FooClass { val bar = 1 }
x: FooClass{val bar: Int} = $anon$1@393ddf54

scala> x.bar
res0: Int = 1
```

But...
```scala
scala> abstract class FooClass { protected val bar: Int }
defined class FooClass

scala> val x = new FooClass { val bar = 1 }
x: FooClass = $anon$1@72f9a516

scala> x.bar
<console>:10: error: value bar in class FooClass cannot be accessed in FooClass
 Access to protected value bar not permitted because
 enclosing object $iw is not a subclass of 
 class FooClass where target is defined
              x.bar
                ^
```

scala insists I bring SOMETHING new to the table if I want to widen the access: def becomes val, more specific return type... but with no "public" keyword, it is impossible to just say it. But there's no reason we should make you say it anyway, because the absence of access modifiers means public! Why would it infer a more restrictive type than the one we declared?

Here's the kind of desperation one ends up with.
```scala
scala> abstract class FooClass { protected val bar: Int }
defined class FooClass

scala> val x = new FooClass { override val bar = 1.asInstanceOf[Int with Nothing] }
x: FooClass{val bar: Int with Nothing} = $anon$1@6e963c02

scala> x.bar
res0: Int with Nothing = 1

scala> x.bar: Int
res1: Int = 1
```
