I may well be short on good ideas in this case.  We have the same problem with mutable.TreeSet, and mutable and immutable BitSet:

{code}
scala> Set(1) == i.TreeSet(1L)
res0: Boolean = false

scala> Set(1L) == i.BitSet(1)
res1: Boolean = false

scala> Set(1L) == m.BitSet(1)
res2: Boolean = false

scala> Set(1L) == m.TreeSet(1)
res3: Boolean = false

scala> m.TreeSet(1) == Set(1L)
res4: Boolean = true
{code}

The "solutions" I can think of so far are all of the ugly hacky variety.  For instance, in practice BitSet and TreeSet iterate in order.  So if you have two non-BT sets, the old method works (as no other sets, AFAIK, contain a math.Ordering or directly assume Int); if one is a BT set, then you call subsetOf in the other direction; and if both are they are ordered so you can compare in O(n) by iterating along both (and might want to special-case further).  But although this would work, it is hardly an attractive solution.
