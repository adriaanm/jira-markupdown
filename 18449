I'm putting the finishing touches on my 1000 page homage to futility.
```scala
// Fails
class Foo {
  def f(x: Any) = x match { case x: (T forSome { type T }) => x }
  // a.scala:2: error: not found: type T
  //   def f(x: Any) = x match { case x: (T forSome { type T }) => x }
  //                                      ^
}

// Everything in this class compiles
class Foo2 {
  type T <: String

  def f(x: Any) = x match { case x: (T forSome { type T }) => x }
  // Compiles! Uses the T from the surrounding scope.
  def g(x: Any) = x match { case x: T => x }
  // Also compiles - but bizarrely, f gets the classtag treatment while g does not!?
  // def f(x: Any): Foo2.this.T = x match {
  //   case (x @ ClassTag.apply[Foo2.this.T[]](classOf[java.lang.String]).unapply(<unapply-selector>) <unapply> ((_: Foo2.this.T[]))) => x
  // };
  // def g(x: Any): Foo2.this.T = x match {
  //   case (x @ (_: Foo2.this.T)) => x
  // }

  // And for good measure, this compiles too.
  type Q = T forSome { type T }

  def h(x: Any) = x match { case x: Q => x }
}
```
