Yes, this behaviour or inference runs pretty deeply through the way that applications are type checked, and it is relied upon in APIs like `foldLeft`, which allow the constraints accumulated by considering the first argument list to allow you to omit types in the second argument list.

{code}
def foo[A, B](a: A)(f: A => B)
foo(1)(x => -x) // no need to write `x: Int => -x` here
{code}
