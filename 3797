I discovered this ticket during the time when I try to fix scala/bug#2634.
I have spend a couple of hours try to find why my solution which mentioned in scala/bug#3265 didn't work. It confused my very much. I still don't know the reason, but I find something interested. 
In the following code, we can only get a StackOverflowError if using 
{code}
val fib: Stream[Int] = 1 #:: 1 #:: (fib, fib.tail).zippedx2.map(_ + _)
{code}.
We can get fib(2) and a StackOverflowError if using 
```scala
val fib: Stream[Int] = 1 #:: 1 #:: (fib, fib.tail).zippedx.map(_ + _)
```
While I expected to get fib(3) without any exception. I must have something missed. Is there any one to tell me why. I believe it is the key to fix scala/bug#3273
```scala
import scala.collection.{TraversableLike, IterableLike}
import scala.collection.generic.CanBuildFrom

class LazyItrSt[A](stream: Stream[A]) {

  class LazyCell[T](st: => Stream[T]){ lazy val v = st }
  
  def iterator: Iterator[A] = new Iterator[A] {
    var these = new LazyCell(stream)
    def hasNext: Boolean = !these.v.isEmpty
    def next: A = 
      if (hasNext) {
        val result = these.v.head; 
		these =new LazyCell(these.v.tail); 
		result
      } else Iterator.empty.next
    override def toList: List[A] = stream.toList
  }
}

class Zippedx[+Repr1, +El1, +Repr2, +El2](coll1: TraversableLike[El1, Repr1], coll2: IterableLike[El2, Repr2]) { 
    def map[B, To](f: (El1, El2) => B)(implicit cbf: CanBuildFrom[Repr1, B, To]): To = {
      val elems2 = (new LazyItrSt(coll2.asInstanceOf[Stream[El2]])).iterator

      for(el1 <- coll1 if elems2.hasNext) yield f(el1, elems2.next)
    }
}

class Zippedx2[+Repr1, +El1, +Repr2, +El2](coll1: TraversableLike[El1, Repr1], coll2: IterableLike[El2, Repr2]) { 
    def map[B, To](f: (El1, El2) => B)(implicit cbf: CanBuildFrom[Repr1, B, To]): To = {
      val elems2 = coll2.iterator

      for(el1 <- coll1 if elems2.hasNext) yield f(el1, elems2.next)
    }
}

object Debug extends Application {
    implicit def t2t[T1,T2](t: (T1,T2)) = new {
        def zippedx[Repr1, El1, Repr2, El2](implicit w1: T1 => TraversableLike[El1, Repr1],
                                                  w2: T2 => IterableLike[El2, Repr2]): Zippedx[Repr1, El1, Repr2, El2]
            = new Zippedx[Repr1, El1, Repr2, El2](t._1, t._2)
    }
	
	implicit def t2t2[T1,T2](t: (T1,T2)) = new {
        def zippedx2[Repr1, El1, Repr2, El2](implicit w1: T1 => TraversableLike[El1, Repr1],
                                                  w2: T2 => IterableLike[El2, Repr2]): Zippedx2[Repr1, El1, Repr2, El2]
            = new Zippedx2[Repr1, El1, Repr2, El2](t._1, t._2)
    }
	val fib: Stream[Int] = 1 #:: 1 #:: (fib, fib.tail).zippedx2.map(_ + _)
        //val fib: Stream[Int] = 1 #:: 1 #:: (fib, fib.tail).zippedx.map(_ + _)
	println(fib(2))
	println(fib(3))
}
```
