This sort of thing is dangerous, but you can do something like this.  (I can't settle for not returning the same collection type.)
```scala
import scala.collection.{ mutable, immutable, generic }
import generic._

class RichTrav[T, CC[X] <: Traversable[X]](coll: CC[T]) {
  def narrow[U <: AnyRef](implicit cm: ClassManifest[U], bf: CanBuildFrom[CC[T], U, CC[U]]): CC[U] = {
    val clazz = cm.erasure
    val buf = bf(coll)
    coll foreach { x =>
      if (clazz.isAssignableFrom(x.asInstanceOf[AnyRef].getClass))
        buf += x.asInstanceOf[U]
    }
    buf.result
  }
}

class A
class B extends A
class C extends B
  
object Test {
  implicit def mkRich[T, CC[X] <: Traversable[X]](coll: CC[T]) = new RichTrav[T, CC](coll)
  
  def main(args: Array[String]): Unit = {
    val xs: List[Any] = List(new A, new B, new C, List(1), 5, List(new A))
    println(xs.narrow[B])
    println(xs.toIndexedSeq.narrow[B])
    println(xs.toBuffer.narrow[B])
  }
}
```
But now you don't get unchecked warnings, not that people seem to pay much attention to them.
```scala
scala> xs.narrow[List[Int]].flatten.sum
java.lang.ClassCastException: A cannot be cast to java.lang.Integer
	at scala.runtime.BoxesRunTime.unboxToInt(Unknown Source)
	at scala.math.Numeric$$IntIsIntegral$$.plus(Numeric.scala:45)
	at scala.collection.TraversableOnce$$$$anonfun$$sum$$1.apply(TraversableOnce.scala:322)
	at scala.collection.LinearSeqOptimized$$class.foldLeft(LinearSeqOptimized.scala:113)
	at scala.collection.immutable.List.foldLeft(List.scala:45)
	at scala.collection.TraversableOnce$$class.sum(TraversableOnce.scala:322)
```
