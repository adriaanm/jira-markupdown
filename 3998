Also, if Futures.future is used multiple times, the extra messages pile up,
(shown here in the main thread):

{code}
import scala.actors._, scala.actors.Actor._

for (i <- 1 to 10) {
  val ft = Futures.future { 42 }
  println("result: " + ft())
}

for (i <- 1 to 10) {
  receive { case msg => println("unexpected: " + msg) }
}
{code}

results in

{code}
unexpected: !(scala.actors.Channel@6719fc9e,42)
unexpected: !(scala.actors.Channel@5b181df3,42)
unexpected: !(scala.actors.Channel@c566b3e,42)
...
{code}


Maybe this is why the runtime of repeated Futures.future explodes:


{code}
import scala.actors._, scala.actors.Actor._

def repeatedFuture(n: Int): Unit = {
  val a = actor {
    react { case n: Int =>
      val t1 = java.lang.System.nanoTime()
      for (i <- 1 to n) { (Futures.future { 42 })() }
      val t2 = java.lang.System.nanoTime()
      reply((t2-t1)*1E-9)
    }
  }
  println("Time: " + (a !? n) + " s")
}

{
repeatedFuture(2000)
repeatedFuture(6000)
repeatedFuture(10000)
repeatedFuture(14000)
repeatedFuture(18000)
}
{code}

results in

{code}
Time: 1.0669668300000001 s
Time: 3.4539345200000002 s
Time: 12.58622826 s
Time: 29.762735377000002 s
Time: 49.841004080000005 s
{code}
