With the new collection library, Iterable's signature has changed and flatMap requires an additional implicit argument.This makes it somewhat harder to come up with a common type Monadic that fits Iterables, Options, etc. A workaround is to just define implicits for the individual classes:
{code}
  implicit def reflective[A](xs:List[A]) = new { // 2.8 collections have a more complicated flatMap mechanism
    def reflect[B](implicit bf: BuilderFactory[B, List[B], List[A]]): A @cps[List[B], List[B]] = {
      shift { k:(A => List[B]) =>
        xs.flatMap(k)
      }
    }
  }

{code}
