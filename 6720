The bug is in `Implicits#depoly`. It uses `ApproximateDependentMap` to type to wildcard away dependent type prefixes based on parameter values. But it goes too far, and ends up converting the result type of `toFor` from:
```scala
=> m1.__For
```

to:
```scala
"=> ?#__For"
```

It only affects the {{use1}}, because of {{m}}'s coincidental position in an enclosing parameter list.

This mapped type no longer conforms to the expected type, ` AnyRef{ def map: Int} `.

How can we be more discriminating here? We only want to find types that are dependent on a method parameter in the method that provides the candiate implicit.

...

Oh, just found this:
```scala

    // more precise conceptually, but causes cyclic errors:    (paramss exists (_ contains sym))
    override def isImmediatelyDependent = (sym ne NoSymbol) && (sym.owner.isMethod && sym.isValueParameter)
```
