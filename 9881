{quote}
AFAIK the only reason for the restriction is the requirement that everything be reconstructable at runtime via pattern matching. It is kind of tragic to so severely limit the power of value classes to support typeless-language style programming. If you need to pattern match your way back out of nested value classes, you are Doing It Wrong.
{quote}

Or in other words, nested value class would need to have outer pointer to preserve semantics of path-dependent types at runtime but then value class would erase to two fields and not one which is not supported at the moment.

If we are complaining about value class restrictions, how about:

{code}
class Foo[T](val x: T) extends AnyVal

class Test[T] {
	def test: Foo[T] => Foo[T] = foo => foo
}
{code}

If you try to compile it you get:
{code}
Test.scala:4: error: bridge generated for member method apply: (foo: Foo[T])Foo[T] in anonymous class $anonfun
which overrides method apply: (v1: T1)R in trait Function1
clashes with definition of the member itself;
both have erased type (v1: Object)Object
	def test: Foo[T] => Foo[T] = foo => foo
                                         ^
one error found
{code}

Which is super confusing error that no regular Scala user can possibly comprehend. However, what Scala compiler hacker can read from it is that if you have a generic value class that erases to object then there's no way you can create a lambda that takes or returns such a class. One could ask why do we even allow generic value classes if a core feature of Scala (lambdas) doesn't work with them and gives a super cryptic error message.
