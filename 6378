First (the more important comes below), it doesn't work for 1000 elements, neither:

scala> def numbers(isPar: Boolean) = if (isPar) (1 to 1000).par else 1 to 1000
numbers: (isPar: Boolean)scala.collection.GenSeq[Int] with Serializable{def companion: scala.collection.generic.GenericCompanion[scala.collection.GenSeq{def seq: scala.collection.immutable.Seq[Any]}]; def par: scala.collection.parallel.immutable.ParSeq[Int]; def seq: scala.collection.immutable.Seq[Int]; def distinct: scala.collection.GenSeq[Int]{def seq: scala.collection.immutable.Seq[Int]; def distinct: scala.collection.GenSeq[Int]{def seq: scala.collection.immutable.Seq[Int]; protected def parCombiner: scala.collection.parallel.Combiner[Int,scala.collection.parallel.immutable.ParSeq[Int]]}; def intersect[U >: Int](that: scala.collection.GenSeq[U]): scala.collection.GenSeq[Int]{def seq: scala.collection.immutable.Seq[Int]; protected def parCombiner: scala.collection.parallel.Combiner[I...
scala> numbers(true) map { _ => Thread.currentThread.getName }
res8: scala.collection.GenSeq[java.lang.String] = ParVector(Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, Thread-17, ...

Second: How can the collections know whether the load is high or not? Even for a small number like 8 or even 3 it could make sense to perform operations in parallel. Example using a collection of functions making web service requests:

object Weather {

  def main(args: Array[String]) {
    val locations = Seq(
        ...
        "Berlin-Germany",
        "San Francisco-USA")
    val isParallel = args.headOption map {_ == "par"} getOrElse false
    val time0 = System.currentTimeMillis
    val currentTemperatures =
      if (isParallel) (locations.par map currentTemperature).flatten.seq
      else (locations map currentTemperature).flatten
    val time1 = System.currentTimeMillis
    val averageTemperature = currentTemperatures.sum / currentTemperatures.size
    println("Calculated average temperature of about %s Â°C in %s ms.".format(averageTemperature, time1 - time0))
  }

  def currentTemperature(location: String): Option[Int] = {
    def extractTemperature(weatherResponse: Elem) =
      (weatherResponse \\ "current_conditions" \ "temp_c").headOption flatMap { temp =>
        catching(classOf[NumberFormatException]) opt { (temp \ "@data").text.toInt }
      }
    val weatherRequest = :/("www.google.com") / "ig" / "api" <<? Map("weather" -> location, "hl" -> "en")
    Http(weatherRequest <> extractTemperature)
  }
}
