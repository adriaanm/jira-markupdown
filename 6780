I've traced the problem to this fragment in method typeRef in scala.reflect.internal.Types:

{code}     
      val pre1 = pre match {
       case x: SuperType if sym1.isEffectivelyFinal || sym1.isDeferred =>
         x.thistpe
       case _: CompoundType if sym1.isClass =>
         // sharpen prefix so that it is maximal and still contains the class.
         pre.parents.reverse dropWhile (_.member(sym1.name) != sym1) match {
           case Nil         => pre
           case parent :: _ => parent
         }
       case _ => pre
     }
{code}

I don't see why we want to loose type information of `CompoundType`s in this manner. Maybe it is useful to make inferred types wider? I can't see how, except in the presence of a this.type -- which is exactly where it can break things... but of course my sight here is really limited.
