A few notes from discussion with Martin:

 - the introduction of withFilter really seems to limit the usefuless of refutability checking
 - we don't really want to go down the path of typechecking both variations pending analysis of the patterns.
 - perhaps, though, we could re-spec things to say the withFilter is always included, but, the compiler
   will pass a specially tagged closure (e.g. it would have a marker trait `Constant` as a a parent),
   so that the withFilter implementation could avoid calling it.

{code}
class Option[+A] { self =>
  class WithFilter(p: A => Boolean) {
    private val isConstant = p.isInstanceOf[ConstantFunction]
    def map[B](f: A => B): Option[B] = if (isConstant) self map f else self filter p map f
    ...
  }
}
{code}

  - Treatment of `null` causes headaches: we ignore the possibility of null in the refutability checking (otherwise any pattern involving a type test would be refutable). Perhaps pattern generated should be changed:

{code}
  for ((x, y) <- null: Option[(Int, Int)]) yield x

  scala> val n = Some(null): Option[(Int, Int)]
  n: Option[(Int, Int)] = Some(null)

  scala> for (Tuple2(x, y) <- n) yield x
  scala.MatchError: null
	at $anonfun$1.apply(<console>:9)
	at $anonfun$1.apply(<console>:9)
	at scala.Option.map(Option.scala:145)

  scala> n withFilter { case (x, y) => true; case _ => false } map { case (x, y) => x }
  res4: Option[Int] = None


  // if refutability checking worked as originally intended, and the `withFilter` was elided.
  // will throw a NPE
  scala> n map { case (x, y) => x }
  scala.MatchError: null

  // Tentative proposal: the predicate should admit null.
  scala> n withFilter { case (x, y) => true; case null =>; case _ => false } map { case (x, y) => x }
{code}
