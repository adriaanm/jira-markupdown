```scala
    private def correspondingTypeArgument(lhs: Type, rhs: Type): Type = {
      val TypeRef(_, lhsSym, lhsArgs) = lhs
      val TypeRef(_, rhsSym, rhsArgs) = rhs
      require(lhsSym.owner == rhsSym, s"$lhsSym is not a type parameter of $rhsSym")

      // Find the type parameter position; we'll use the corresponding argument.
      // Why are we checking by name rather than by equality? Because for
      // reasons which aren't yet fully clear, we can arrive here holding a type
      // parameter whose owner is rhsSym, and which shares the name of an actual
      // type parameter of rhsSym, but which is not among the type parameters of
      // rhsSym. One can see examples of it at SI-4365.
      val argIndex = rhsSym.typeParams indexWhere (lhsSym.name == _.name)
      // don't be too zealous with the exceptions, see #2641
      if (argIndex < 0 && rhs.parents.exists(typeIsErroneous))
```
```
// no type args as scala.swing.ListView was compiled against JDK6
Test.lv.peer.type baseType JList = JList 

lhs = type E(in JList)
lhsArgs = {scala.collection.immutable.Nil$@2623}"Nil$" size = 0
lhsSym = {scala.reflect.internal.Symbols$AbstractTypeSymbol@2622}"type E"
rhs = JList

// But, in this compilation run ListView has sprouted type parameters.
rhsSym.typeParams = [type E]

// So we think we'll find E among lhsArgs at:
argIndex = 0

// but we IIOBE instead :(
```
