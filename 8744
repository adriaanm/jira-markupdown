this bug affects me using scala version 2.11.1
testing the following in the REPL 
```scala
import scala.reflect.runtime.universe._
import scala.tools.reflect.ToolBox

val input = """package foo.bar
class Test {
}"""
val toolbox = runtimeMirror(getClass.getClassLoader).mkToolBox()
toolbox.parse(input)
```
results in 
```scala
scala.tools.reflect.ToolBoxError: reflective compilation has failed:

'{' expected but ';' found.
  at scala.tools.reflect.ToolBoxFactory$ToolBoxImpl$ToolBoxGlobal.throwIfErrors(ToolBoxFactory.scala:315)
  at scala.tools.reflect.ToolBoxFactory$ToolBoxImpl$ToolBoxGlobal.parse(ToolBoxFactory.scala:290)
  at scala.tools.reflect.ToolBoxFactory$ToolBoxImpl$$anonfun$parse$1.apply(ToolBoxFactory.scala:416)
  at scala.tools.reflect.ToolBoxFactory$ToolBoxImpl$$anonfun$parse$1.apply(ToolBoxFactory.scala:413)
  at scala.tools.reflect.ToolBoxFactory$ToolBoxImpl$withCompilerApi$.liftedTree2$1(ToolBoxFactory.scala:354)
  at scala.tools.reflect.ToolBoxFactory$ToolBoxImpl$withCompilerApi$.apply(ToolBoxFactory.scala:354)
  at scala.tools.reflect.ToolBoxFactory$ToolBoxImpl.parse(ToolBoxFactory.scala:413)
  ... 46 elided
```
my current workaround is surrounding package declarations with curly-brackets. 
```scala
val input = """
package foo.bar{
  class Test {
  }
}"""
```

this results in a valid tree. However calling 
{code}toolbox.typecheck{code}
on the resulting tree fails throwing: 
```scala
java.lang.AssertionError: assertion failed: value <local <expression-owner>>
  at scala.reflect.internal.Symbols$Symbol.newPackage(Symbols.scala:309)
  at scala.tools.nsc.typechecker.Namers$Namer.createPackageSymbol(Namers.scala:380)
  at scala.tools.nsc.typechecker.Namers$Namer.createPackageSymbol(Namers.scala:373)
...
```
