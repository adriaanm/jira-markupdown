Now that Martin has stated at Scala 2.8 will drop JDK 1.4 compatibility, a
wrapper for java.util.concurrent.ConcurrentHashMap can be added into Scala.

The original comment didn't state the reason to add this wrapper, but the
ConcurrentHashMap implements a few methods that is not provided by the
java.util.Map interface, so wrapping a ConcurrentHashMap with the
MapWrapper looses the additional method I use:

http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ConcurrentMap.html

Here's a fuller implementation:

{code}
class ConcurrentHashMap[K,E]
  (override val underlying : java.util.concurrent.ConcurrentHashMap[K,E])
  extends scala.collection.jcl.MapWrapper[K,E]
{
  def this() = this(new java.util.concurrent.ConcurrentHashMap[K,E])

  /**
   * java.util.concurrent.ConcurrentHashMap's do not support a clone
   * operation.
   */
  override def clone() : Nothing = throw new CloneNotSupportedException

  /**
   * Atomically insert an elemenet into the map associated with a key
   * only if the key is not already in the map.
   *
   * @param key the key to insert the value with
   * @param element the element to add to the map
   * @return Some() with the key's value if the key has a value in the
   *         map; None otherwise
   */
  def putIfAbsent(key : K, element : E) : Option[E] =
  {
    val result = underlying.putIfAbsent(key, element)
    if (result == null) {
      None
    }
    else {
      Some(result)
    }
  }
}
{code}
