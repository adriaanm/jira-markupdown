This might not be a bug after all, if not a documentation bug. See below.

As Eugene said, macros are not at fault because type inference in this code does the same thing, in all calls to {{map}} - they are inferred as {{map\[Int, Any]}}:
{code}
def id(x: Any): Any = x
id(List.apply(1).map((x: Int) => x))
val foo:Any = List.apply(1).map((x: Int) => x)
println(List.apply(1).map((x: Int) => x))
{code}
However, all that code works!

What strikes me as odd is another thing. Given that {{test}} returns {{Any}}:
{code}
def test(s:String) = macro testImpl
def testImpl(c:Context)(s:c.Expr[String]):c.Expr[Any] = ...
{code}
why should one expect this code:
{code}
val list:List[Int] = test("")
{code}
to work? Why isn't it an error that it compiles, after adding the call to typecheck? Apparently, the macro output can *statically* refine the declared type - but how should this work, are there guarantees on that? I'm not sure anymore that this is a bug - unless you can point me to an explanation for users of how things are supposed to work, we might have a documentation bug here.
