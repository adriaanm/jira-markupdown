This might not be a bug after all, if not a documentation bug. See below.

As Eugene said, macros are not at fault because type inference in this code does the same thing, in all calls to `map` - they are inferred as `map\[Int, Any]`:
```scala
def id(x: Any): Any = x
id(List.apply(1).map((x: Int) => x))
val foo:Any = List.apply(1).map((x: Int) => x)
println(List.apply(1).map((x: Int) => x))
```
However, all that code works!

What strikes me as odd is another thing. Given that `test` returns `Any`:
```scala
def test(s:String) = macro testImpl
def testImpl(c:Context)(s:c.Expr[String]):c.Expr[Any] = ...
```
why should one expect this code:
```scala
val list:List[Int] = test("")
```
to work? Why isn't it an error that it compiles, after adding the call to typecheck? Apparently, the macro output can **statically** refine the declared type - but how should this work, are there guarantees on that? I'm not sure anymore that this is a bug - unless you can point me to an explanation for users of how things are supposed to work, we might have a documentation bug here.
