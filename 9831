I just took a look at this test case. It looks like a deadlock, where the locks in play are the intrinsic locks on the corresponding Class objects that occur during class initialization [1].

A Scala module `Foo` has a corresponding module class `Foo$`, which contains a static field `MODULE$`, which is initialized to `new Foo$` in the static initializer of the class.
```
% cat sandbox/test.scala
object O {
  println(Thread.currentThread.getStackTrace.toList.take(5).mkString("\n"))
}

object Test {
  def main(args: Array[String]) {
    O
  }
}
% qbin/scalac sandbox/test.scala && qbin/scala Test
java.lang.Thread.getStackTrace(Thread.java:1503)
O$.<init>(test.scala:2)
O$.<clinit>(test.scala)
Test$.main(test.scala:7)
Test.main(test.scala) 
```

Generates:
```
scala> :javap -v -p O$
Compiled from "test.scala"
public final class O$ extends java.lang.Object
  SourceFile: "test.scala"
  Scala: length = 0x
...
{
public static final O$ MODULE$;

public static {};
  Code:
   Stack=1, Locals=0, Args_size=0
   0:	new	#2; //class O$
   3:	invokespecial	#12; //Method "<init>":()V
   6:	return

private O$();
  Code:
   Stack=3, Locals=1, Args_size=1
```

If objects form a cycle, those class initialization locks can deadlock:
```
object O1 {
  val x = O2.x
  def y = 0
}
object O2 {
  val x = O1.y
}

object Test extends App {
  Await.result(Future.sequence(List(future(O1.y), future(O2.x)), Duration.Inf)
}
```

Here's a stack overflow post about this topic [2].

Similar problems are possible with lazy vals; we have a bit more of an idea how to reduce those, which we've outlined in the Lazy Val SIP [3], which is planned for 2.12. But I don't know of any proposals to change the encoding of modules.

A workaround is to eagerly force objects during single threaded application startup to break the cycle. Or avoid cycles between objects.

I should mention that this is not specific to package objects; as far as the generated bytecode is concerned, they are no different from other Scala objects.

So I have to close this one as not-a-bug. I wish we could do more.

[1] http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html
[2] http://stackoverflow.com/questions/15176199/scala-parallel-collection-in-object-initializer-causes-a-program-to-hang
[3] http://docs.scala-lang.org/sips/pending/improved-lazy-val-initialization.html
