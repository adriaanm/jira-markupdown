It would seem the original example is now fixed in the nightly build, giving the error:
{code}
test.scala:11: error: overriding type T in trait A with bounds >: Int <: Int;
 type T in trait B with bounds >: String <: String has incompatible type
  lazy val x : A with B = x
{code}
However, it would seem the fix was shallow as the following program is still allowed:
{code}
 trait Bound { type T }

 trait X {
   type A <: Bound
   val x : A
   var n : x.T
 }

 trait Y extends X {
   trait YA extends Bound { type T >: Int <: Int }
   type A <: YA
   var n : x.T = 3
 }

 trait Z extends X {
   trait ZA extends Bound { type T >: String <: String }
   type A <: ZA
   n = "foo"
 }

 new Y with Z {
   type A = YA with ZA
   lazy val x : A = x
 }

{code}

It might be better to address the root of this deep problem, because it is easy to continue coming up with examples that ad-hoc checks will miss.
