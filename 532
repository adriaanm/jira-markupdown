Actually, when passing "x" as argument, the above code must block: when reacting to the message that is sent by the inner actor, `sender` (correctly) refers to the inner actor.

To make the program work, you have to save the original sender (from the outermost `!?`) in a local variable (call it `s`):

{code}
    actor {
      react {
        case "" => sender ! None
        case _ =>
          val s = sender // ADDED
          actor {
            react {
              case _ => sender ! None
            }
          } ! ""
          react { case _ => s ! None } // CHANGED
      }
    } !? what
{code}

Then, the program sends the reply to the right actor and returns as expected.

However, the fact that the original program did *not* hang when replacing the outer `react` with `receive` exposed a bug: inside the last `react`, `sender` incorrectly referred to the sender of the outer `receive`.

This bug is fixed in revision r14487.

Thanks for reporting this anomalous behavior.
