The append method is implemented as follows:

{code}
def append(l: SLL): Unit =
{
    if (cdr == null)
      cdr = l
    else
      append(cdr)
}
{code}

Because the function is virtual though, the compiler somehow issues a virtual function call to append (invokevirtual) and does perform a tail call.  If one declares the function private and looks at the bytecode, the tail recursion optimization has been performed (we have a goto instead of a function call).  Of course a private append is not very useful.

Is the compiler correct to be conservative?  Perhaps some scala guru can enlighten us.

One "fix" is simply to define an internal function inside of append that does the work and have the append function call it.  Something like:

{code}
def append2(l: SLL): Unit =
{
  def aux(m: SLL): Unit = if (m.cdr == null) m.cdr = l else aux(m.cdr)
    
  aux(this)
}
{code}

This generates the following code:
{code}
private final void aux$$1(math.SLL, math.SLL);
  Code:
   0:   aload_1
   1:   invokevirtual   SI-28; //Method cdr:()Lmath/SLL;
   4:   dup
   5:   astore  4
   7:   ifnull  19
   10:  aload   4
   12:  aconst_null
   13:  invokevirtual   SI-32; //Method java/lang/Object.equals:(Ljava/lang/Objec
;)Z
   16:  ifeq    25
   19:  aload_1
   20:  aload_2
   21:  invokevirtual   SI-36; //Method cdr_$$eq:(Lmath/SLL;)V
   24:  return
   25:  aload_1
   26:  invokevirtual   SI-28; //Method cdr:()Lmath/SLL;
   29:  astore_1
   30:  goto    0

public void append2(math.SLL);
  Code:
   0:   aload_0
   1:   aload_0
   2:   aload_1
   3:   invokespecial   SI-40; //Method aux$$1:(Lmath/SLL;Lmath/SLL;)V
   6:   return
{code}

which will no longer exhaust the stuck.

But this little transformation has to be done for every library function that "thinks" is tail recursive.  From the same class "get" is another one.
