As expressed in [SO 33650809](http://stackoverflow.com/questions/33650809/optionlong-constructor-throws-a-nullpointerexception), the creation of `Option` from a null-carrying `java.lang` value can cause a `NullPointerException` to be thrown.

This is because the way `Option` factory is defined:
```scala
def apply[A](x: A): Option[A] = if (x == null) None else Some(x)
```

What happens is that the `x` (being e.g. `java.lang.Long` - and carrying a null) is first implicitly converted to `scala.Long`, before being compared to null. `scala.Long` is an `AnyVal` and cannot thus carry a null. Thus the exception.

I would see two ways to fix this unexpected behaviour, as explained in my proto pull request.

The approach I would like to see in future Scala versions is a guarantee that an `Option` will never carry a `java.lang` value, but the corresponding Scala `AnyVal`. I.e. one could not create an `Option[java.lang.Long]`, at all. This makes sense since the use of `Option` is often used at Java/Scala borders, to filter out `null`s. If the value is not null, we can just as well represent it as a Scala `AnyVal`. This change would only make the guarantee of `Option` stronger.

Also, the way an IDE can obscure the difference between `scala.Long` and `java.lang.Long` from the user (showing both as simply `Long`), this would help managing conversions in general. Creating an `Option` from a `java.lang.Long` would create an `Option[scala.Long]`, which is what APIs likely would be expecting. Without this change, one gets weird error messages such as "expecting `Option[Long]` but had `Option[Long]`".

The other way to solve the NullPointerException problem would be to use two type parameters to `Option`, allowing the test against `null` to precede the implicit conversion. This, however, would break code that explicitly provides one (target) template argument for `Option`. It would also allow `Option[java.lang.Long]` to be created, leading to the above compilation issues.
