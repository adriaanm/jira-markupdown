A variation I tried (that also failed)

{code}

object Test {
  trait SubtypeOf[+T] {
    type Type <: T
  }

  class Owned[+P <: Owner with Singleton](val next: Option[P#R])

  class Owner {
    type This <: Owner with Singleton
    val R = SubtypeOf[Owned[This]]
    type R = R.Type

    def next(o: Owned[this.type]): Owned[This] = o.next.get
  }

  object Owner extends Owner {
    type This = this.type
  }

  def SubtypeOf[T]: SubtypeOf[T] = new SubtypeOf[T] { type Type = T }

  def compiles(o: Owned[Owner.type]): Owned[Owner.type] = o.next.get

  def fails(o: Owned[Owner.type]): Owned[Owner.type] = o.next.get.next.get

  def fix(o: Owned[Owner.type]): Owned[Owner.type] = (o.next.get: Owned[Owner.type]).next.get
}

{code}
