here's the failure when using mixing:
```scala
  ~/newbug> cat p/J.java 
package p;
public class J {
	int foo;
	public int foo() { return foo ; }
}
  ~/newbug> cat S.scala 
object S extends Application { println((new p.J).foo) }
  ~/newbug> ~/scala/dists/latest/bin/scalac p/J.java S.scala
  ~/newbug> javac p/J.java
  ~/newbug> ~/scala/dists/latest/bin/scala S             
java.lang.IllegalAccessError: tried to access field p.J.foo from class S$$
	at S$$.<init>(S.scala:1)
	at S$$.<clinit>(S.scala)
	at S.main(S.scala)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at scala.tools.nsc.ObjectRunner$$$$anonfun$$run$$1.apply(ObjectRunner.scala:75)
	at scala.tools.nsc.ObjectRunner$$.withContextClassLoader(ObjectRunner.scala:49)
	at scala.tools.nsc.ObjectRunner$$.run(ObjectRunner.scala:74)
	at scala.tools.nsc.MainGenericRunner$$.main(MainGenericRunner.scala:164)
	at scala.tools.nsc.MainGenericRunner.main(MainGenericRunner.scala)
```

and here's it succeeding if scalac sees the class instead of the source:
```scala
  ~/newbug> rm *.class p/*.class
  ~/newbug> javac p/J.java                                  
  ~/newbug> ~/scala/dists/latest/bin/scalac S.scala 
  ~/newbug> ~/scala/dists/latest/bin/scala S       
0
```

I'm running r15827.

The obvious workaround, of changing "foo" to "foo()" in S.scala, works.
