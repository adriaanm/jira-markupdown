There is no object SomeScala, but in Java that import means you can refer to the inner class unqualified.

Given this Scala:
{code:title=scalapkg/Main.scala}
package scalapkg

import javapkg.JavaClass

object Main extends App {
  val someScala = new SomeScala("abc")
  new JavaClass().useInner(new someScala.InnerClass)
}

class SomeScala(str: String) {
  class InnerClass {
    def printStr() = println(str)
  }
}
{code}

This compiles and runs when passed as source to scala:
{code:title=javapkg/JavaClass.java}
package javapkg;

import scalapkg.SomeScala;

public class JavaClass {
    public void useInner(Object probablyInner) {
    	SomeScala.InnerClass inner = (SomeScala.InnerClass) probablyInner;
    	inner.printStr(); 
    }
}
{code}

This would be compiled by java to the exact same .class file as the one above, but it does not compile when passed to scala as source:
{code:title=javapkg/JavaClass.java}
package javapkg;

import scalapkg.SomeScala.*;

public class JavaClass {
    public void useInner(Object probablyInner) {
    	InnerClass inner = InnerClass probablyInner;
    	inner.printStr(); 
    }
}
{code}

When you put "SomeScala.InnerClass" in the signature for "JavaClass.useInner", instead of Object, then the scala compiler complains (although the Java compiler allows it, and it runs and does what you expect). So maybe this is just a case of scala only rejecting method signatures that it doesn't like, rather than checking the body of the method.

How are you supposed to use a scala inner class from java?
