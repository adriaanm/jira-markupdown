It would be useful if Scala were to treat the return from getClass() as
a java.lang.Class[T] forSome { val T : C } where C is something like the
erasure of the static type of the expression on which getClass is called.
This would match Java 6:

http://java.sun.com/javase/6/docs/api/java/lang/Object.html#getClass()

It would let me do something like the following where I want to introspect
on a class but shouldn't need a class instance.  I also want to limit the
types of classes I want to introspect on, so I use Class[_ <: Foo].  But
this prevents me from passing in a Foo class by using Foo.getClass()
without a cast.

{code}
trait IdlBase

class IdlConcrete

object Test extends Application {
  // In general, this method should not need an instance to reflect on it, so
  // take a Class[]
  def reflect(clazz : Class[_ <: IdlBase]) = {
    // Get a list of all its methods and build a hash keyed by method name
    // for statistics recording.
  }

  // But I also really have an IdlConcrete generated by Spring here...
  val idl = new IdlConcrete
  reflect(idl.getClass)
}
{code}

{code}
test.scala:14: error: type mismatch;
 found   : java.lang.Class[?0] where type ?0
 required: Class[_$$1] forSome { type _$$1 <: IdlBase }
  reflect(idl.getClass)
              ^
one error found
{code}

There was a request for this and Martin responded:

http://scala-programming-language.1934581.n4.nabble.com/Java-generics-vs-Scala-types-td1937960.html
