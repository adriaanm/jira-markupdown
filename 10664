I just force pushed a few tiny cleanups.

{noformat}
diff --git a/src/reflect/scala/reflect/internal/Types.scala b/src/reflect/scala/reflect/internal/Types.scala
index be13082..53cf515 100644
--- a/src/reflect/scala/reflect/internal/Types.scala
+++ b/src/reflect/scala/reflect/internal/Types.scala
@@ -2571,7 +2571,10 @@ trait Types
       // (aka \Gamma, which tracks types for variables and constraints/kinds for types)
       // as a nice bonus, delaying this until we need it avoids cyclic errors
       val tpars = underlying.typeSymbol.initialize.typeParams
-      val rawToExistentialCreatedMe = (quantified corresponds underlying.typeArgs){ (q, a) => q.tpe =:= a }
+
+      // Is this existential of the form: T[Q1, ..., QN] forSome { type Q1 >: L1 <: U1, ..., QN >: LN <: UN}
+      val isExactApplication = (quantified corresponds underlying.typeArgs){ (q, a) => q.tpe =:= a }
+
       def newSkolem(basis: Symbol) = (owner orElse basis.owner).newExistentialSkolem(basis, origin)
       def newSharpenedSkolem(quant: Symbol, tparam: Symbol): Symbol = {
         def emptyBounds(sym: Symbol) = sym.info.bounds.isEmptyBounds
@@ -2590,7 +2593,7 @@ trait Types
             quant
         newSkolem(basis)
       }
-      if (rawToExistentialCreatedMe) deriveType2(quantified, tpars, newSharpenedSkolem)(underlying)
+      if (isExactApplication) deriveType2(quantified, tpars, newSharpenedSkolem)(underlying)
       else deriveType(quantified, newSkolem)(underlying)
     }

diff --git a/src/reflect/scala/reflect/internal/tpe/TypeMaps.scala b/src/reflect/scala/reflect/internal/tpe/TypeMaps.scala
index 351a0f3..07c9242 100644
--- a/src/reflect/scala/reflect/internal/tpe/TypeMaps.scala
+++ b/src/reflect/scala/reflect/internal/tpe/TypeMaps.scala
@@ -667,8 +667,6 @@ private[internal] trait TypeMaps {

   /** A base class to compute all substitutions */
   abstract class SubstMap[T](from: List[Symbol], to: List[T]) extends TypeMap {
-    if (!sameLength(from, to))
-      println("!!!")
     assert(sameLength(from, to), "Unsound substitution from "+ from +" to "+ to)
{noformat}
