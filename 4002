I have a feeling this is being dismissed as invariance bug (on the programmer side) with Arrays, which is not the case. Please review the following simplified example.

I completely agree that uncheckedVariance undermines the type safety and that the programmer takes responsibility if the program crashes. However as implemented now, uncheckedVariance adds ADDITIONAL BYTECODE that breaks the code that would otherwise work.

Here is a simplified example that typechecks and works. Adding @uncheckedVariance causes it to crash. Surely an annotation is not intented to break working code.
```scala
package broken {
  object Main {
    def main(args: Array[String]) {
      val test: Interface[Byte] = new Concrete(new Array[Byte](10))
      val array = test.array
    }
  }

  trait Interface[D] {
    def backing :Interface[D]
    import scala.annotation.unchecked._
    def array: Array[D] = backing.array
    //def array: Array[D @uncheckedVariance] = backing.array
  }

  class Concrete (override val array: Array[Byte]) extends Interface[Byte] {
    def backing = this
  }
}
```

What happens is: array is casted into Array[Object] due to trait definition, then it is casted back into an appropriate type. Normally this works fine. @uncheckedVariance adds bytecode that tries to verify if array can be cast as Array[Object] which apperently is not ok with the jvm.
Arrays get special treatment, however they donot behave the same as regular Object under these circumstances:
```scala
Type[T] is cast into Type[_] and back into Type[T]
Array[T] is cast into Array[Object] and back into Array[T]
```
@uncheckedVariance adds "checkcast" directive to the bytecode. This works with Type[_], but crashes with Array[Object]. Which means @uncheckedVariance does not work with Arrays as intented.
