This is a bit of a scala puzzler. The following code compiles and prints "no match" when executed.

{code}
val condition = false
val string = "0123"
val test = if (condition) string else string.drop(1)
test match {
    case "123" => println("match")
    case _ => println("no match")
}
{code}

Here is what happens: string.drop(1) returns a RichString, so the type of val test is inferred to be java.lang.Object. Then the match is performed for an Object, so the first test the program does while matching is the type test, since RichString is clearly not a String, the match fails.

This behaviour is non-intuitive and unexpected. For example, the following code will not compile:
{code}
val string = "0123"
val test = string.drop(1)
test match {
    //type mismatch; found: String("123"), required: RichString
    case "123" => println("match")
    case _ => println("no match")
}
{code}

The problem can be fixed by forcing an implicit conversion from RichString back to String:
{code}
val condition = false
val string = "0123"
val test: String = if (condition) string else string.drop(1)
test match {
    case "123" => println("match")
    case _ => println("no match")
}
{code}
This code compiles and works as expected.

This problem would cause a lot of frustration for people coming from dynamic languages or somebody trying to use scala for scripting.

A clean solution could be to generate a compiler error when there is an upcast to Object when assigning to if. This way, it's clear that object type is different depending on if condition. Then the programmer would be able to specify a commong supertype, or force an implicit conversion to a desired type. For the rare cases when the desired type is Object, specifying the type as Object would make the error go away.

I am submitting this as a defect since it is a rather obscure way of shooting yourself in a foot and is not in the spirit of scala which tries to make the developer's life easier.
