The name lookup for {{x}} searches the base classes {{C}} and {{B}}.

In regular compilation (joint or separate); the member {{A::x}} is found, but is inaccessible, which leads into:

{code}
      def searchPrefix = {
        cx = cx.enclClass
        val found0 = lookupInPrefix(name)
        val found1 = found0 filter accessibleInPrefix
        if (found0.exists && !found1.exists && inaccessible == null)
          inaccessible = LookupInaccessible(found0, analyzer.lastAccessCheckDetails)

        found1
      }
{code}

In the resident compilation context (e.g. REPL with classes defined line-by-line), the name mangling of {{A::x}} is visible:

{code}
(baseClasses(1), baseClasses(1).info.decls.toList(1), baseClasses(1).info.decls.toList(1).name)
result = {scala.Tuple3@7304}"(trait A#45776,value x#45779,$line4$$read$$iw$$iw$A$$x)"
{code}

The lookup walks further up the base class sequence, finds {{B::x}} and happily compiles.

We're all to well aware of the proliferation of this sort of subtle bug in resident compilers; that's why we aren't supporting FSC anymore. But what do to with the beloved REPL. Could we rig it up to reload symbols from classfiles after they have compiled, rather than hanging onto the renmants of the later phases of the original run?

Back to the question of whether the error is valid or not under regular conditions. I hope not.

{quote}
The private modifier can be used with any definition or declaration in a template. Such members can be accessed only from within the directly enclosing template and its companion module or companion class (ยง5.4). They are not inherited by subclasses and they may not override definitions in parent classes.
{quote}

So the following is a bug, no? B should not have inherited `a`.

{code}
scala> class A {
     |   private val a: Int = 0
     |   class B extends A {
     |     def foo(a: A) = a.a // okay
     |     println(this.a)     // wait, what?
     |   }
     | }
defined class A
{code}

