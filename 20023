There's something really off about the type inference when I use quasiquotes

Take this example (from Programming Scala book, 2nd Edition):


{code:java}

// src/main/scala/progscala2/metaprogramming/invariant2.scala
package metaprogramming

import scala.language.experimental.macros
import scala.reflect.api.Trees

import scala.reflect.macros.blackbox.Context

/**
  * A Macro written using the current macro syntax along with quasiquotes.
  * Requires a predicate for an invariant to be true before each expression
  * is evaluated.
  */
object invariant2 {

  def execute[T](predicate: => Boolean)(block: => T): T = macro executeMacro

  def executeMacro(context: Context)(predicate: context.Tree)(block: context.Tree) = {
    import context.universe._
    val predicateAsString = showCode(predicate)

    type SyntaxTree = context.Tree
    type TreeNode = Trees#Tree // a syntax tree node that is in and of itself a tree

    val q"..$stmts" = block
    val statements = stmts
    val statementsWithInvariants: Seq[SyntaxTree] = statements.flatMap { statement =>
      // showCode requires "context.universe.Tree"
      val exceptionMessage = s"FAILURE! $predicateAsString == false, for statement: " + showCode(statement)
      val throwStatement = q"throw new metaprogramming.invariant.InvariantFailure($exceptionMessage)"
      val predicateStatement = q"if (false == $predicate) $throwStatement"
      List(q"{ val tmp = $statement; $predicateStatement; tmp };")
    }
    val throwStatement = q"throw new metaprogramming.invariant.InvariantFailure($predicateAsString)"
    val predicateStatement = q"if (false == $predicate) $throwStatement"
    q"$predicateStatement; ..$statementsWithInvariants"
  }

  case class InvariantFailure(msg: String) extends RuntimeException(msg)
}

{code}

^ Everything works. Now look at what happens when I ask for the types:

type of "statements": 
Pattern: statements: scala.Seq[Trees#Tree]

type of "statement":
statement: Trees#Tree

Okay. Now I put these type annotations on "statement" and "statements" and compile


{code:java}

// src/main/scala/progscala2/metaprogramming/invariant2.scala
package metaprogramming

import scala.language.experimental.macros
import scala.reflect.api.Trees

import scala.reflect.macros.blackbox.Context

/**
  * A Macro written using the current macro syntax along with quasiquotes.
  * Requires a predicate for an invariant to be true before each expression
  * is evaluated.
  */
object invariant2 {

  def execute[T](predicate: => Boolean)(block: => T): T = macro executeMacro

  def executeMacro(context: Context)(predicate: context.Tree)(block: context.Tree) = {
    import context.universe._
    val predicateAsString = showCode(predicate)

    type SyntaxTree = context.Tree
    type TreeNode = Trees#Tree // a syntax tree node that is in and of itself a tree

    val q"..$stmts" = block
    val statements: scala.Seq[Trees#Tree] = stmts
    val statementsWithInvariants: Seq[SyntaxTree] = statements.flatMap { (statement: Trees#Tree) =>
      // showCode requires "context.universe.Tree"
      val exceptionMessage = s"FAILURE! $predicateAsString == false, for statement: " + showCode(statement)
      val throwStatement = q"throw new metaprogramming.invariant.InvariantFailure($exceptionMessage)"
      val predicateStatement = q"if (false == $predicate) $throwStatement"
      List(q"{ val tmp = $statement; $predicateStatement; tmp };")
    }
    val throwStatement = q"throw new metaprogramming.invariant.InvariantFailure($predicateAsString)"
    val predicateStatement = q"if (false == $predicate) $throwStatement"
    q"$predicateStatement; ..$statementsWithInvariants"
  }

  case class InvariantFailure(msg: String) extends RuntimeException(msg)
}

{code}

Compile/Run:

{quote}> test:run
[info] Compiling 1 Scala source to /home/johnreed/sbtProjects/scala-trace-debug/target/scala-2.11/test-classes...
[error] /home/johnreed/sbtProjects/scala-trace-debug/src/test/scala/mataprogramming/invariant2.scala:29: type mismatch;
[error]  found   : scala.reflect.api.Trees#Tree
[error]  required: context.universe.Tree
[error]       val exceptionMessage = s"FAILURE! $predicateAsString == false, for statement: " + showCode(statement)
[error]                                                                                                  ^
[error] one error found
[error] (test:compile) Compilation failed
[error] Total time: 0 s, completed Mar 20, 2016 5:40:33 PM
{quote}

This is very peculiar. The type inference told me that "statement" IS of type Trees#Tree

What if I annotate it with "context.universe.Tree" instead


{code:java}

// src/main/scala/progscala2/metaprogramming/invariant2.scala
package metaprogramming

import scala.language.experimental.macros
import scala.reflect.api.Trees

import scala.reflect.macros.whitebox.Context

/**
  * A Macro written using the current macro syntax along with quasiquotes.
  * Requires a predicate for an invariant to be true before each expression
  * is evaluated.
  */
object invariant2 {

  def execute[T](predicate: => Boolean)(block: => T): T = macro executeMacro

  def executeMacro(context: Context)(predicate: context.Tree)(block: context.Tree) = {
    import context.universe._
    val predicateAsString = showCode(predicate)

    type SyntaxTree = context.Tree
    type TreeNode = Trees#Tree // a syntax tree node that is in and of itself a tree

    val q"..$stmts" = block
    val statements: scala.Seq[context.universe.Tree] = stmts
    val statementsWithInvariants: Seq[SyntaxTree] = statements.flatMap { (statement: context.universe.Tree) =>
      // showCode requires "context.universe.Tree"
      val exceptionMessage = s"FAILURE! $predicateAsString == false, for statement: " + showCode(statement)
      val throwStatement = q"throw new metaprogramming.invariant.InvariantFailure($exceptionMessage)"
      val predicateStatement = q"if (false == $predicate) $throwStatement"
      List(q"{ val tmp = $statement; $predicateStatement; tmp };")
    }
    val throwStatement = q"throw new metaprogramming.invariant.InvariantFailure($predicateAsString)"
    val predicateStatement = q"if (false == $predicate) $throwStatement"
    q"$predicateStatement; ..$statementsWithInvariants"
  }

  case class InvariantFailure(msg: String) extends RuntimeException(msg)
}
{code}


The IDE says "expression of type Tree#Tree does not conform to type context.universe.Tree", but it compiles. What is going on with the wacky type inference here?
