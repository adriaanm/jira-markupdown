The error message isn't very helpful: in case anyone is misled, the signature is syntactically valid.  Position 56 is the . after the type parameters.  Here is some java code which creates a similar signature.

{code}
public class J<CC> {
  public class Inner { }
}

class K<CC> {
  // (LJ<TCC;>.Inner;)V;
  public void f(J<CC>.Inner param) { }
}
{code}

The example with javac fails because

  GenTraversableFactory$ReusableCBF$ // this exists
  GenTraversableFactory$ReusableCBF  // this doesn't.

And indeed the accessor is pointing at the one which doesn't exist:

  private volatile scala.collection.generic.GenTraversableFactory$ReusableCBF$ ReusableCBF$module;
  public final scala.collection.generic.GenTraversableFactory$ReusableCBF ReusableCBF();

Changing it to a lazy val fixes it not because the signature changes but because GenTraversableFactory$ReusableCBF is generated.
