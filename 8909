The complete list of methods that should prevent inlining as actually pretty large.

First of all, we need to find all the places where `getCallerClassLoader` is used.

That gives us a bunch of methods in `j.l.Class`, and a few in `j.l.ClassLoader`, `j.l.Package`, `j.l.Thread`, `j.sql.DriverManager`, `javax.script.ScriptEngineManager`.

But then there are all the calls to `j.l.SecurityManager` which indirectly call `j.security.AccessController.getStackAccessControlContext`. Suffice to safe that is a very long list. And even if we were to catalog it and avoid inlining methods that directly call them, it isn't enough -- we still might eliminated a frame that was granted some permission needed later down the call chain.

Of course, this level of paranoia would also cause us to worry about changing the behaviour of `Thread.getCurrentThread.getStackTrace`, but that is probably a bridge too far. (Although, most logging libraries use this to find the caller's class name: http://logback.qos.ch/xref/ch/qos/logback/classic/spi/CallerData.html).

I think that it is worthwhile to add protection for the known callers to `getCallerClassLoader`, and I'll submit a PR to that effect. I think I'll forbid calls to **any** method in those classes, rather than picking out the methods one-by-one.

But as to security, I think we'll have to document it as a caveat of compiling with `-optimize`. I'm sure that 99% of users will be unaffected by it.
