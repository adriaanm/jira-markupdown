Here's another one, notable for having no closures, no by-name arguments, nothing beyond an abstract method being implemented. It's not possible for Option to be a value class without a solution to this.
{code}
final class Option[+A](val value: A) extends AnyVal

abstract class Foo[A]                { def f(): Option[A] }
         class Bar[A] extends Foo[A] { def f(): Option[A] = ??? }
{code}
{noformat}
./a.scala:7: error: bridge generated for member method f: ()Option[A] in class Bar
which overrides method f: ()Option[A] in class Foo
clashes with definition of the member itself;
both have erased type ()Object
         class Bar[A] extends Foo[A] { def f(): Option[A] = ??? }
                                           ^
one error found
{noformat}
