
Some context on the check in question: duplicates are detected to avoid the situation where, given a bytecode-level classname, the super classes tracked for it don't match those of "the other" symbol that also maps to the same internal name. Knowing a class' superclasses is needed to compute Java 6 StackMapTables.

Coming back to debugging, what we don't know is the relative ordering of:

  (1) clearing and initial population of javaNameCache, reverseJavaName, ie 

{noformat}
    javaNameCache.clear()
    javaNameCache   ++= List( ...

    reverseJavaName.clear()
    reverseJavaName ++= List( ...
{noformat}

  (2) clearing of the above performed on Run end by perRunCaches

  (3) adding symbols to the maps above, this is expected to happen for a single Run bracketed between (1) and (2).

From what I can see, two scenarios under which the assertion fails are:

  (a) symbols from two (consecutive, in general different) Runs get in the same bracket (1) -- (2)

  (b) within a single Run, two different class symbols map to the same bytecode-level internal name.

  (c) both of the above? (not so likely)

Depending on which scenario is at play, is the party to blame.

