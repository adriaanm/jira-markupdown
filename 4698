your patch (slightly cleaned up*) is not working for generic arrays:

{code}
scala> def f[T:ClassManifest](x: T) = Array(x)
f: [T](x: T)(implicit evidence$$1: ClassManifest[T])Array[T]

scala> f(1)
java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [I
	at .<init>(<console>:7)
	at .<clinit>(<console>)
	at RequestResult$$.<init>(<console>:9)
	at RequestResult$$.<clinit>(<console>)
	at RequestResult$$scala_repl_result(<console>)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at scala.tools.nsc.Interpreter$$Request$$$$anonfun$$loadAndRun$$1$$$$anonfun$$apply$$17.apply(Interpreter.scala:987)
	at scala.tools.nsc.Interpreter$$Request$$$$anonfun$$loadAndRun$$1$$$$anonfun$$apply$$17.apply(Interpreter.scala:987)
	at scala.util.control.Exception$$Catch.apply...
{code}


(*)
{code}
              if (fun2.symbol.owner == ArrayModule.moduleClass && fun2.symbol.name == nme.apply) res match {
                case Apply(_, args) =>
                  val tpe = res.tpe.resultType.typeArgs(0)
                  typed { atPos(tree.pos)(ArrayValue(TypeTree(tpe), args)) }
                case _ => res
              } else if (fun2.symbol == Array_apply) {
{code}
