(I'm consolidating related tickets: see also SI-1452, SI-1456, SI-1457, SI-1458, SI-6955, SI-6956)

Terms:

  - "intlike type" is any of Int, Short, Byte, or Char.
  - "intlike" means an intlike literal or intlike identifier.
  - "intlike literal" means any literal constant with an intlike type.
  - "intlike identifier" means an identifier which can be statically determined to have the following properties:
    - immutable (i.e. a val)
    - not overridable (i.e. final or enclosed in a final container)
    - assigned a value which can be statically reduced to an intlike literal.  This means arithmetic operations only, on intlikes.

scala should generate tableswitch/lookupswitch bytecode whenever the following conditions hold:

 - a) the scrutinee is any expression with an intlike result type.
 - a1) or, if b) and c) hold, then if the scrutinee is AnyVal or Any, a switch can still be generated by inserting if/then/else logic before the switch.
 - b) all non-default cases are intlike.
 - c) if there is a default case, it either has no type annotation, or a type annotation which matches all intlike values.

At present, an identifier in a match statement will suppress the creation of a switch statement 100% of the time if it makes it to the pattern matcher stage.  When scala's constant folder replaces the identifier with the constant before reaching that point, the switch can be created; but this takes place only in a fraction of the cases where it's desirable.
