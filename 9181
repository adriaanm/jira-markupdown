One difference between Java and Scala that we have to consider is that we allow private access outside of the current compilation unit. So we have a few different scenarios wrt separate compilation. e.g. changing a member from public to private[pack] is currently binary compatible for call sites in that `pack`. (Admittedly, it is also BC for call sites outside of the package, so we have no runtime enforcement of access.)
```
% qbin/scalac sandbox/{A,B}.scala
% qbin/scalac sandbox/A-pack-private.scala
% qbin/scala p.Test
% qbin/scala

scala> :javap -public p.C
Compiled from "A-pack-private.scala"
public class p.C extends java.lang.Object{
    public int foo();
    public p.C();
}
```

If we compiled `foo` as private and provided an accessor, this would no longer be the case.

In addition, we would need to generate stable names for the accessors (rather than java's `acesssNNN`). But this could be done easily enough in the same manner as the current mangling.

So perhaps we need to consider the scheme used for package-qualified access separately from other cases.

Another tricky aspect of Java's approach to access is constructors. It creates 'access constructors' with an extra dummy parameter. The type of the parameter was used to uniquely distinguish the constructors, and was chosen to be the type of the inner class that needed to access the constructor.
