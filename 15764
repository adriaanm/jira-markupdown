One of those issues I've been sitting on forever and talking to adriaan makes me realize that maybe everyone else doesn't cry for half an hour every morning about it and that the mere act of opening a ticket might make a difference.

And so! I believe this code should work:
```scala
object Test {
  object Bob
  class Foo { def bippy = 42 }
  
  implicit def mkFoo(x: Bob.type): Foo = new Foo
  
  def main(args: Array[String]): Unit = {
    println(Bob.bippy)
  }
}
// actual outcome:
// a.scala:8: error: value bippy is not a member of object Test.Bob
//     println(Bob.bippy)
//                 ^
// one error found
```
And were it to work, I would also hope for this to work, as it does for the analogous case for normal classes:
```scala
object Test {
  class Base 
  object Bob extends Base
  class Foo { def bippy = 42 }
  class Oof { def bippy = -21 }
  
  // I am more specific than you
  implicit def f1(x: Bob.type): Foo = new Foo
  implicit def f2(x: Base): Oof = new Oof
  
  def main(args: Array[String]): Unit = {
    // this would of course print an unambiguous 42
    println(Bob.bippy)
  }
}
```
I am familiar with scala/bug#1208 and the fact that singleton types will not sing and dance with wild abandon.  I'm hoping this situation doesn't fall under the general umbrella both because it would be super useful, and because it would mean implicit search doesn't use normal function application rules, as visible here:
```scala
object Test {
  object Bob
  class Foo { def bippy = 42 }
  val Dingus: Bob.type = Bob

  implicit def f1(x: Bob.type): Foo = new Foo    
  
  def main(args: Array[String]): Unit = {
    // none of these expressions would work implicitly...
    // ...but in all cases the receiver can be passed to f1 explicitly.
    f1(Bob).bippy
    f1(Bob: Bob.type).bippy
    f1(Dingus).bippy
    f1(Dingus: Bob.type).bippy
  }
}
```
