I created the following from 
pp 10 and 11 of
http://kinded-scala.googlecode.com/svn/trunk/papers/sparsec/sparsec.pdf

(These are actually in separate source files,
!SimpleResults.scala and !SimpleParsers.scala)
```scala

trait SimpleResults {
  type Input

  trait Result[+T] {
    def next: Input
    def map[U](f: T => U): Result[U]
    def flatMapWithNext[U](f: T => Input => Result[U]): Result[U]
    def append[U >: T](alt: => Result[U]): Result[U]
  }

  case class Success[+T](result: T, next: Input) extends Result[T] {
    def map[U](f: T => U)
      = Success(f(result), next)
    def flatMapWithNext[U](f: T => Input => Result[U])
      = f(result)(next)
    def append[U >: T](alt: => Result[U])
      = this
  }

  case class Failure(msg: String, next: Input) extends Result[Nothing] {
    def map[U](f: Nothing => U)
      = this
    def flatMapWithNext[U](f: Nothing => Input => Result[U])
      = this
    def append[U](alt: => Result[U])
      = alt
  }

}


trait SimpleParsers extends SimpleResults {
  abstract class Parser[+T] extends (Input => Result[T]) {
    def apply(in: Input): Result[T]

    def flatMap[U](f: T => Parser[U]): Parser[U]
        = new Parser[U]{def apply(in: Input)
                          = Parser.this(in) flatMapWithNext(f)}

    def map[U](f: T => U): Parser[U]
      = new Parser[U]{def apply(in: Input)
                        = Parser.this(in) map(f)}

    def | [U >: T](p: => Parser[U]): Parser[U]
      = new Parser[U]{def apply(in: Input)
                        = Parser.this(in) append p(in)}

    def ~ [U](p: => Parser[U]): Parser[Pair[T, U]]
      = for(a <- this; b <-  p) yield (a,b)
  }
}
```

When I edit !SimpleParsers.scala in the Scala editor in Eclipse
and save, it adds 'final' keywords 
```scala
trait SimpleParsers extends SimpleResults {
  abstract class Parser[+T] extends (Input => Result[T]) {
    def apply(in: Input): Result[T]

    def flatMap[U](f: T => Parser[U]): Parser[U]
        = new Parser[U]{def apply(final in: Input)
                          = Parser.this(in) flatMapWithNext(f)}

    def map[U](f: T => U): Parser[U]
      = new Parser[U]{def apply(final in: Input)
                        = Parser.this(in) map(f)}

    def | [U >: T](p: => Parser[U]): Parser[U]
      = new Parser[U]{def apply(in: Input)
                        = Parser.this(in) append p(in)}

    def ~ [U](p: => Parser[U]): Parser[Pair[T, U]]
      = for(a <- this; b <-  p) yield (final a,b)
  }
}
```
which cause warnings/errors:
```scala
Description	Resource	Path	Location	Type
':' expected but '}' found.	SimplerParsers.scala	scala-mdx/Source/scala/com/sas/acl/parsers	Unknown	Scala Problem
':' expected but '}' found.	SimplerParsers.scala	scala-mdx/Source/scala/com/sas/acl/parsers	Unknown	Scala Problem
')' expected but '}' found.	SimplerParsers.scala	scala-mdx/Source/scala/com/sas/acl/parsers	Unknown	Scala Problem
identifier expected but 'final' found.	SimplerParsers.scala	scala-mdx/Source/scala/com/sas/acl/parsers	Unknown	Scala Problem
identifier expected but 'final' found.	SimplerParsers.scala	scala-mdx/Source/scala/com/sas/acl/parsers	Unknown	Scala Problem
illegal start of simple expression	SimplerParsers.scala	scala-mdx/Source/scala/com/sas/acl/parsers	Unknown	Scala Problem
```

Side note: I checked my Java cleanup preferences and my active configuration does not enable the 'Use 'final' modifier where possible.
