actually i changed my mind, the fix / current behavior is correct. it doesn't make sense to have the class members in scope when typing (auxiliary or primary) constructor defaults (or types).

{code}
class C { type T; def this(x: T) { this() } }                 // gives `not found: type T`
class C(x: Int) { def this(a: Int, b: Int = x) { this(b) } }  // gives `not found: value x`
class C { val x = 0; def this(a: Int = x) { this() } }        // also  `not found: value x`
{code}

spec 5.3.1: The signature and the self constructor invocation of a constructor definition are type-checked and evaluated in the scope which is in effect at the point of the enclosing class definition, augmented by any type parameters of the enclosing class and by any early definitions of the enclosing template. The rest of the constructor expression is type-checked and evaluated as a function body in the current class.
