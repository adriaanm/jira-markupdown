Good reason or not, there's some very strange behaviour here,
```scala
Welcome to Scala version 2.7.3.final (Java HotSpot(TM) Server VM, Java 1.6.0_10).
Type in expressions to have them evaluated.
Type :help for more information.

scala> class C { type T } 
defined class C

scala> object O extends C
defined module O

scala> var v1 : O.T = _
v1: O.T = null

scala> val v2 : Any = v1
v2: Any = null

scala> val v3 : AnyVal = v1
<console>:7: error: type mismatch;
 found   : O.T
 required: AnyVal
       val v3 : AnyVal = v
                         ^

scala> val v4 : AnyRef = v1
<console>:7: error: type mismatch;
 found   : O.T
 required: AnyRef
Note that implicit conversions are not applicable because they are ambiguous:
 both method any2stringadd in object Predef of type (Any)scala.runtime.StringAdd
 and method any2ArrowAssoc in object Predef of type [A](A)ArrowAssoc[A]
 are possible conversion functions from O.T to AnyRef
       val v4 : AnyRef = v
                         ^
```

So T is <: of Any, but not of AnyVal or AnyRef, even though null inhabits T?
