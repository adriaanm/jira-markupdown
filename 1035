`takeWhile` consumes one more element than necessary (the first one that makes the predicate false). This can be shown even without `zipWithIndex`:
```scala
scala> val xs = List(1, 2, 3, 4)  
xs: List[Int] = List(1, 2, 3, 4)

scala> val iter = xs.elements
iter: Iterator[Int] = non-empty iterator

scala> iter.takeWhile(_ < 2).toList       
res10: List[Int] = List(1)

scala> iter.toList
res11: List[Int] = List(3, 4)
```

The combination of the two removes 2 elements, for some reason. At first glance, this needs a bit of library redesign, since `takeWhile` can't be implemented in unbuffered iterators (unless we specify the current behavior as being what we want).
