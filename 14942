The following code, when compiled with -optimise flag and then execute causes VM to crash with java.lang.VerifyError.
Various combinations of variables that are causing the bug were tested. In some cases the code works, but produces a wrong result.

Tested with scala 2.8 branch, including latest nightly build (scala-2.8.0.r20633). Not tested on 2.7.

There are 5 test cases below - 2 that cause a crash, 2 with wrong result and 1 working example. Note that all the cases work without -optimise compiler option.
{code}
/*
 * This program will write an image of Madelbrot fractal in the
 * work directory (file name = mandelbrot.png).
 *
 * The bug only appears with -optimise compiler option.
 *
 * Recompile to execute methods:
 * wors() - proper image
 * visualErrors1() - image with visual computational errors
 * visualErrors2() - image with visual computational errors
 * crash1() - vm crash
 * crash2() - vm crash
 *
 * The only difference between test cases is the presence of x2 and y2 and
 * replacing x*x with x2 and y*y with y2 in different places.
 * Note that all the cases work without -optimise compiler option.
 */
object ErrorTest {
    def main(args: Array[String]) {
//        TestCases.works()
//        TestCases.visualErrors1()
//        TestCases.visualErrors2()
        TestCases.crash1()
//        TestCases.crash2()
    }
}

object TestCases {
    def works() {
      Launcher.launch(new RenderFunction {
        val iterations = 100

         final def apply(pixel: Vec2) :Int =
        {
            val zoom = 200
            val c = new Vec2((pixel.x - width/2)/zoom, (pixel.y - height/2)/zoom)

            var x = 0d
            var y = 0d

            var i = 0; while (x*x + y*y <= 4 && i < iterations) {
                val xt = x*x - y*y + c.x

                y = 2*x*y + c.y
                x = xt

                i += 1
            }

            i*255/iterations
        }})
    }

    def visualErrors1() {
      Launcher.launch(new RenderFunction {
        val iterations = 100

         final def apply(pixel: Vec2) :Int =
        {
            val zoom = 200
            val c = new Vec2((pixel.x - width/2)/zoom, (pixel.y - height/2)/zoom)

            var x = 0d
            var y = 0d

            var x2 = 0d
            var y2 = 0d

            var i = 0; while (x*x + y*y <= 4 && i < iterations) {
                val xt = x2 - y2 + c.x

                y = 2*x*y + c.y
                x = xt

                x2 = x*x
                y2 = y*y

                i += 1
            }

            i*255/iterations
        }})
    }

    def visualErrors2() {
      Launcher.launch(new RenderFunction {
        val iterations = 100

         final def apply(pixel: Vec2) :Int =
        {
            val zoom = 200
            val c = new Vec2((pixel.x - width/2)/zoom, (pixel.y - height/2)/zoom)

            var x = 0d
            var y = 0d

            var x2 = 0d
            var y2 = 0d

            var i = 0; while (x2 + y2 <= 4 && i < iterations) {
                val xt = x2 - y2 + c.x

                y = 2*x*y + c.y
                x = xt

                x2 = x*x
                y2 = y*y

                i += 1
            }

            i*255/iterations
        }})
    }

    def crash1() {
      Launcher.launch(new RenderFunction {
        val iterations = 100

         final def apply(pixel: Vec2) :Int =
        {
            val zoom = 200
            val c = new Vec2((pixel.x - width/2)/zoom, (pixel.y - height/2)/zoom)

            var x = 0d
            var y = 0d

            var x2 = 0d
            var y2 = 0d

            var i = 0; while (x*x + y*y <= 4 && i < iterations) {
                val xt = x*x - y*y + c.x

                y = 2*x*y + c.y
                x = xt

                x2 = x*x
                y2 = y*y

                i += 1
            }

            i*255/iterations
        }})
    }

    def crash2() {
      Launcher.launch(new RenderFunction {
        val iterations = 100

         final def apply(pixel: Vec2) :Int =
        {
            val zoom = 200
            val c = new Vec2((pixel.x - width/2)/zoom, (pixel.y - height/2)/zoom)

            var x = 0d
            var y = 0d

            var x2 = 0d
            var y2 = 0d

            var i = 0; while (x2 + y2 <= 4 && i < iterations) {
                val xt = x*x - y*y + c.x

                y = 2*x*y + c.y
                x = xt

                x2 = x*x
                y2 = y*y

                i += 1
            }

            i*255/iterations
        }})
    }
}

class Vec2(var x: Double, var y: Double)

abstract class RenderFunction {
    final val width = 800
    final val height = 600
    def apply(pixel: Vec2) :Int
}

object Launcher {
    def launch(f: RenderFunction) {
        val buffer = new Array[Int](f.width*f.height)
        for (y <- 0 until f.height; x <- 0 until f.width) {
            buffer(x + y*f.width) = f(new Vec2(x, y))
        }

        import java.awt.image.BufferedImage
        import javax.imageio.ImageIO

        val img = new BufferedImage(f.width, f.height, BufferedImage.TYPE_INT_RGB)
        img.setRGB(0, 0, f.width, f.height, buffer, 0, f.width)
        ImageIO.write(img, "PNG", new java.io.File("mandelbrot.png"))
    }
}
{code}
