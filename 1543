DRMacIver points out that isInstanceOf draws the opposite conclusion.  I think either that is wrong, or the type matching behavior is wrong.  Here is a demonstration.
{code}
class Settings {
  val settings: List[Setting] = List(Setting1("bob"))
  
  abstract class Setting(descr: String) {
    def name: String
  }
  
  case class Setting1(name: String) extends Setting("foo") {
    override def equals(other: Any) = other match {
      case x: Setting1 => true
      case _           => false
    }
  }
  
  case class Setting2(name: String) extends Setting("bar") {
    override def equals(other: Any) = other match {
      case x: Setting2 => true
      case _           => false
    }
  }
  
  override def equals(other: Any) = other match {
    case s: Settings  => List.forall2(settings, s.settings)(_ == _)
    case x            => false
  }
}

object go
{
  def main(args: Array[String]): Unit = {
    val set1 = new Settings
    val set2 = new Settings
    
    println("set1 == set2? " + (set1 == set2))
    println("isInstanceOf == " + set1.settings.head.isInstanceOf[set2.Setting1])
  }
}
{code}

{code}
$$ scala27 go
set1 == set2? false
isInstanceOf == true
{code}
