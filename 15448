An email I sent just now.  Summary: 1) if Iterator has partition, it should have span.  2) BufferedIterator is an opportunity to make Iterator a lot less inconvenient on operations like takeWhile and dropWhile which split the Iterator.

{code}
It's not as short as I expected because Iterator is missing "span", an
oversight I should correct, especially since it has partition.  So I'm     
not enormously proud of this, but:
  
def clustered[T, U](it: Iterator[T], f: T => U): Iterator[(U, Iterator[T])] =   
{
  val buf = it.buffered
  new Iterator[(U, Iterator[T])] {
    def hasNext = buf.hasNext
    def next: (U, Iterator[T]) = {
      val hd = buf.next
      val key = f(hd)
      val xs = collection.mutable.ListBuffer[T](hd)

      while (buf.hasNext && f(buf.head) == key)
        xs += buf.next

      key -> xs.iterator
    }                                                                           
  }                                                                             
}                                                                               

Looking at this, it occurs to me that BufferedIterator should be first
class with stronger guarantees.  Right now when you call something like
takeWhile on an Iterator, only the returned iterator is guaranteed: the
iterator you called takeWhile on is undefined.  With a known one element
buffer we could strengthen the contract and say the original iterator is
positioned at the right spot.  Then I wouldn't need the listbuffer at
all, I could call takeWhile and be done.
{code}
