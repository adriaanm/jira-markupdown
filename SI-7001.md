Systematic NullPointerException inside scala compiler once I've added a new parameter (chartFactory) to a method call. If I remove the parameter from the call, it compiles and runs fine:

  detailedCPUSection += newTabChartSection(
    sectionTitle = s"CPU Usage for ${host}",
    seriesTitle = "CPU",
    seriesList = cpumetrics.map(s => s.rename(s.name, s.name)),
    norm4chart = Some(_.statSample(period)),
    unitdesc = "%", showRange = true, showTrend = true,
    chartFactory = StackedChart // HERE
  )

(StackedChart is an object).

full message attached to this issue report.


[info] Loading project definition from /home/work/experiments/Analysis/project
[info] Set current project to Analysis (in build file:/home/work/experiments/Analysis/)
[info] Compiling 5 Scala sources to /home/work/experiments/Analysis/target/scala-2.10/classes...
[error] 
[error]      while compiling: /home/work/experiments/Analysis/src/main/scala/com/orange/analysis/Reporting.scala
[error]         during phase: typer
[error]      library version: version 2.10.0
[error]     compiler version: version 2.10.0
...
[error] 
[error]   last tree to typer: Ident(StackedChart)
[error]               symbol: value <error> in class <error> (flags: <synthetic> <is_error>)
[error]    symbol definition: val <error>: <error>
[error]                  tpe: <error>
[error]        symbol owners: value <error> -> class <error> -> package <root>
[error]       context owners: value $anonfun -> value $anonfun -> method metricsReport -> object Reporting -> package 
analysis
[error] 
[error] == Enclosing template or block ==
...
[error] 
[error] == Expanded type of tree ==
[error] 
[error] <error>
[error] 
[error] uncaught exception during compilation: java.lang.NullPointerException
java.lang.NullPointerException
	at scala.tools.nsc.typechecker.Typers$Typer.adapt(Typers.scala:1131)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5467)
	at scala.tools.nsc.typechecker.Typers$Typer.typedArg(Typers.scala:2880)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$60.apply(Typers.scala:3021)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$60.apply(Typers.scala:3013)
	at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:244)
	at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:244)
	at scala.collection.immutable.List.foreach(List.scala:309)
	at scala.collection.TraversableLike$class.map(TraversableLike.scala:244)
	at scala.collection.AbstractTraversable.map(Traversable.scala:105)
	at scala.tools.nsc.typechecker.Typers$Typer.handleOverloaded$1(Typers.scala:3013)
	at scala.tools.nsc.typechecker.Typers$Typer.doTypedApply(Typers.scala:3033)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$86.apply(Typers.scala:4423)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$86.apply(Typers.scala:4423)
	at scala.tools.nsc.typechecker.Typers$Typer.silent(Typers.scala:721)
	at scala.tools.nsc.typechecker.Typers$Typer.tryTypedApply$1(Typers.scala:4423)
...


I just got the same error! Can't compile my project anymore! :(
*uncaught exception during compilation: java.lang.NullPointerException*

Any guess what syntactic construction can cause it, so I could perhaps work it around somehow?

{noformat}
[INFO] Compiling 40 source files to C:\work\webchannel\search-indexer\trunk\indexer-core\target\classes at 1358937648388
[ERROR] error: 
[INFO]      while compiling: C:\work\webchannel\search-indexer\trunk\indexer-core\src\main\scala\com\idc\webchannel\search\indexer\core\converter\FromResearchDocumentConverter.scala
[INFO]         during phase: typer
[INFO]      library version: version 2.10.0
[INFO]     compiler version: version 2.10.0
[INFO]   reconstructed args: -classpath C:\work\webchannel\search-indexer\trunk\indexer-core\target\classes;C:\Users\awajda\.m2\repository\com\oracle\ojdbc6\11.2.0.2.0\ojdbc6-11.2.0.2.0.jar;C:\Users\awajda\.m2\repository\org\apache\solr\solr-solrj\3.5.0\solr-solrj-3.5.0.jar;C:\Users\awajda\.m2\repository\commons-httpclient\commons-httpclient\3.1\commons-httpclient-3.1.jar;C:\Users\awajda\.m2\repository\commons-logging\commons-logging\1.1.1\commons-logging-1.1.1.jar;C:\Users\awajda\.m2\repository\commons-io\commons-io\2.1\commons-io-2.1.jar;C:\Users\awajda\.m2\repository\org\slf4j\jcl-over-slf4j\1.6.1\jcl-over-slf4j-1.6.1.jar;C:\Users\awajda\.m2\repository\org\slf4j\slf4j-api\1.6.1\slf4j-api-1.6.1.jar;C:\Users\awajda\.m2\repository\com\idc\publishing\metacop-consumer\1.2.2.6\metacop-consumer-1.2.2.6.jar;C:\Users\awajda\.m2\repository\com\idc\publishing\metacop-consumer-message\1.2.2.6\metacop-consumer-message-1.2.2.6.jar;C:\Users\awajda\.m2\repository\org\springframework\spring-jms\3.0.7.RELEASE\spring-jms-3.0.7.RELEASE.jar;C:\Users\awajda\.m2\repository\org\springframework\spring-aspects\3.0.7.RELEASE\spring-aspects-3.0.7.RELEASE.jar;C:\Users\awajda\.m2\repository\org\springframework\spring-context-support\3.0.7.RELEASE\spring-context-support-3.0.7.RELEASE.jar;C:\Users\awajda\.m2\repository\org\springframework\spring-aop\3.0.7.RELEASE\spring-aop-3.0.7.RELEASE.jar;C:\Users\awajda\.m2\repository\org\aspectj\aspectjrt\1.6.11\aspectjrt-1.6.11.jar;C:\Users\awajda\.m2\repository\org\aspectj\aspectjweaver\1.6.11\aspectjweaver-1.6.11.jar;C:\Users\awajda\.m2\repository\org\springframework\amqp\spring-amqp\1.0.0.RELEASE\spring-amqp-1.0.0.RELEASE.jar;C:\Users\awajda\.m2\repository\org\springframework\amqp\spring-rabbit\1.0.0.RELEASE\spring-rabbit-1.0.0.RELEASE.jar;C:\Users\awajda\.m2\repository\com\rabbitmq\amqp-client\2.5.0\amqp-client-2.5.0.jar;C:\Users\awajda\.m2\repository\org\springframework\integration\spring-integration-amqp\2.1.0.RELEASE\spring-integration-amqp-2.1.0.RELEASE.jar;C:\Users\awajda\.m2\repository\org\springframework\integration\spring-integration-core\2.1.0.RELEASE\spring-integration-core-2.1.0.RELEASE.jar;C:\Users\awajda\.m2\repository\org\hibernate\hibernate-entitymanager\3.6.10.Final\hibernate-entitymanager-3.6.10.Final.jar;C:\Users\awajda\.m2\repository\cglib\cglib\2.2\cglib-2.2.jar;C:\Users\awajda\.m2\repository\org\hibernate\hibernate-validator\4.2.0.Final\hibernate-validator-4.2.0.Final.jar;C:\Users\awajda\.m2\repository\javax\validation\validation-api\1.0.0.GA\validation-api-1.0.0.GA.jar;C:\Users\awajda\.m2\repository\commons-configuration\commons-configuration\1.6\commons-configuration-1.6.jar;C:\Users\awajda\.m2\repository\commons-digester\commons-digester\1.8\commons-digester-1.8.jar;C:\Users\awajda\.m2\repository\org\apache\commons\commons-email\1.2\commons-email-1.2.jar;C:\Users\awajda\.m2\repository\javax\mail\mail\1.4.1\mail-1.4.1.jar;C:\Users\awajda\.m2\repository\javax\activation\activation\1.1\activation-1.1.jar;C:\Users\awajda\.m2\repository\log4j\log4j\1.2.16\log4j-1.2.16.jar;C:\Users\awajda\.m2\repository\com\idc\worldwide\commons\commons-util\0.0.65\commons-util-0.0.65.jar;C:\Users\awajda\.m2\repository\org\springframework\spring-core\3.0.7.RELEASE\spring-core-3.0.7.RELEASE.jar;C:\Users\awajda\.m2\repository\commons-lang\commons-lang\2.6\commons-lang-2.6.jar;C:\Users\awajda\.m2\repository\commons-beanutils\commons-beanutils\1.8.3\commons-beanutils-1.8.3.jar;C:\Users\awajda\.m2\repository\xalan\xalan\2.7.1\xalan-2.7.1.jar;C:\Users\awajda\.m2\repository\xalan\serializer\2.7.1\serializer-2.7.1.jar;C:\Users\awajda\.m2\repository\commons-dbcp\commons-dbcp\1.4\commons-dbcp-1.4.jar;C:\Users\awajda\.m2\repository\commons-pool\commons-pool\1.5.4\commons-pool-1.5.4.jar;C:\Users\awajda\.m2\repository\org\hibernate\hibernate-core\3.5.6-Final\hibernate-core-3.5.6-Final.jar;C:\Users\awajda\.m2\repository\antlr\antlr\2.7.6\antlr-2.7.6.jar;C:\Users\awajda\.m2\repository\commons-collections\commons-collections\3.2.1\commons-collections-3.2.1.jar;C:\Users\awajda\.m2\repository\dom4j\dom4j\1.6.1\dom4j-1.6.1.jar;C:\Users\awajda\.m2\repository\xml-apis\xml-apis\1.3.04\xml-apis-1.3.04.jar;C:\Users\awajda\.m2\repository\javax\transaction\jta\1.1\jta-1.1.jar;C:\Users\awajda\.m2\repository\org\hibernate\hibernate-annotations\3.5.6-Final\hibernate-annotations-3.5.6-Final.jar;C:\Users\awajda\.m2\repository\org\hibernate\hibernate-commons-annotations\3.2.0.Final\hibernate-commons-annotations-3.2.0.Final.jar;C:\Users\awajda\.m2\repository\org\hibernate\javax\persistence\hibernate-jpa-2.0-api\1.0.1.Final\hibernate-jpa-2.0-api-1.0.1.Final.jar;C:\Users\awajda\.m2\repository\org\springframework\spring-beans\3.0.7.RELEASE\spring-beans-3.0.7.RELEASE.jar;C:\Users\awajda\.m2\repository\org\springframework\spring-context\3.0.7.RELEASE\spring-context-3.0.7.RELEASE.jar;C:\Users\awajda\.m2\repository\org\springframework\spring-expression\3.0.7.RELEASE\spring-expression-3.0.7.RELEASE.jar;C:\Users\awajda\.m2\repository\org\springframework\spring-asm\3.0.7.RELEASE\spring-asm-3.0.7.RELEASE.jar;C:\Users\awajda\.m2\repository\org\springframework\spring-orm\3.0.7.RELEASE\spring-orm-3.0.7.RELEASE.jar;C:\Users\awajda\.m2\repository\org\springframework\spring-jdbc\3.0.7.RELEASE\spring-jdbc-3.0.7.RELEASE.jar;C:\Users\awajda\.m2\repository\org\springframework\spring-tx\3.0.7.RELEASE\spring-tx-3.0.7.RELEASE.jar;C:\Users\awajda\.m2\repository\aopalliance\aopalliance\1.0\aopalliance-1.0.jar;C:\Users\awajda\.m2\repository\javassist\javassist\3.12.1.GA\javassist-3.12.1.GA.jar;C:\Users\awajda\.m2\repository\org\apache\tika\tika-core\1.1\tika-core-1.1.jar;C:\Users\awajda\.m2\repository\org\apache\tika\tika-parsers\1.1\tika-parsers-1.1.jar;C:\Users\awajda\.m2\repository\org\gagravarr\vorbis-java-tika\0.1\vorbis-java-tika-0.1.jar;C:\Users\awajda\.m2\repository\edu\ucar\netcdf\4.2-min\netcdf-4.2-min.jar;C:\Users\awajda\.m2\repository\org\apache\james\apache-mime4j-core\0.7\apache-mime4j-core-0.7.jar;C:\Users\awajda\.m2\repository\org\apache\james\apache-mime4j-dom\0.7\apache-mime4j-dom-0.7.jar;C:\Users\awajda\.m2\repository\org\apache\commons\commons-compress\1.3\commons-compress-1.3.jar;C:\Users\awajda\.m2\repository\commons-codec\commons-codec\1.5\commons-codec-1.5.jar;C:\Users\awajda\.m2\repository\org\apache\pdfbox\pdfbox\1.6.0\pdfbox-1.6.0.jar;C:\Users\awajda\.m2\repository\org\apache\pdfbox\fontbox\1.6.0\fontbox-1.6.0.jar;C:\Users\awajda\.m2\repository\org\apache\pdfbox\jempbox\1.6.0\jempbox-1.6.0.jar;C:\Users\awajda\.m2\repository\org\bouncycastle\bcmail-jdk15\1.45\bcmail-jdk15-1.45.jar;C:\Users\awajda\.m2\repository\org\bouncycastle\bcprov-jdk15\1.45\bcprov-jdk15-1.45.jar;C:\Users\awajda\.m2\repository\org\apache\poi\poi\3.8-beta5\poi-3.8-beta5.jar;C:\Users\awajda\.m2\repository\org\apache\poi\poi-scratchpad\3.8-beta5\poi-scratchpad-3.8-beta5.jar;C:\Users\awajda\.m2\repository\org\apache\poi\poi-ooxml\3.8-beta5\poi-ooxml-3.8-beta5.jar;C:\Users\awajda\.m2\repository\org\apache\poi\poi-ooxml-schemas\3.8-beta5\poi-ooxml-schemas-3.8-beta5.jar;C:\Users\awajda\.m2\repository\org\apache\xmlbeans\xmlbeans\2.3.0\xmlbeans-2.3.0.jar;C:\Users\awajda\.m2\repository\org\apache\geronimo\specs\geronimo-stax-api_1.0_spec\1.0.1\geronimo-stax-api_1.0_spec-1.0.1.jar;C:\Users\awajda\.m2\repository\org\ccil\cowan\tagsoup\tagsoup\1.2.1\tagsoup-1.2.1.jar;C:\Users\awajda\.m2\repository\asm\asm\3.1\asm-3.1.jar;C:\Users\awajda\.m2\repository\com\googlecode\mp4parser\isoparser\1.0-beta-5\isoparser-1.0-beta-5.jar;C:\Users\awajda\.m2\repository\net\sf\scannotation\scannotation\1.0.2\scannotation-1.0.2.jar;C:\Users\awajda\.m2\repository\com\drewnoakes\metadata-extractor\2.4.0-beta-1\metadata-extractor-2.4.0-beta-1.jar;C:\Users\awajda\.m2\repository\de\l3s\boilerpipe\boilerpipe\1.1.0\boilerpipe-1.1.0.jar;C:\Users\awajda\.m2\repository\rome\rome\0.9\rome-0.9.jar;C:\Users\awajda\.m2\repository\jdom\jdom\1.0\jdom-1.0.jar;C:\Users\awajda\.m2\repository\org\gagravarr\vorbis-java-core\0.1\vorbis-java-core-0.1.jar;C:\Users\awajda\.m2\repository\joda-time\joda-time\2.1\joda-time-2.1.jar;C:\Users\awajda\.m2\repository\org\joda\joda-convert\1.2\joda-convert-1.2.jar;C:\Users\awajda\.m2\repository\org\scala-lang\scala-library\2.10.0\scala-library-2.10.0.jar;C:\Users\awajda\.m2\repository\org\scala-lang\scala-compiler\2.10.0\scala-compiler-2.10.0.jar;C:\Users\awajda\.m2\repository\org\scala-lang\scala-reflect\2.10.0\scala-reflect-2.10.0.jar -feature -d C:\work\webchannel\search-indexer\trunk\indexer-core\target\classes -target:jvm-1.7
[INFO] 
[INFO]   last tree to typer: Ident(Duration)
[INFO]               symbol: <none> (flags: )
[INFO]    symbol definition: <none>
[INFO]        symbol owners: 
[INFO]       context owners: value $anonfun -> value $anonfun -> value $anonfun -> value <local $anon> -> anonymous class $anon -> method apply -> object FromResearchDocumentConverter -> package converter
[INFO] 
[INFO] == Enclosing template or block ==
[INFO] 
[INFO] Template( // val <local $anon>: <notype>
[INFO]   "SolrDocumentEx" // parents
[INFO]   ValDef(
[INFO]     private
[INFO]     "_"
[INFO]     <tpt>
[INFO]     <empty>
[INFO]   )
[INFO]   // 26 statements
[INFO]   DefDef( // def <init>(): com.idc.webchannel.search.indexer.solr.SolrDocumentEx{}
[INFO]     <method>
[INFO]     "<init>"
[INFO]     []
[INFO]     List(Nil)
[INFO]     <tpt> // tree.tpe=com.idc.webchannel.search.indexer.solr.SolrDocumentEx{}
[INFO]     Block( // tree.tpe=Unit
[INFO]       Apply( // def <init>(): com.idc.webchannel.search.indexer.solr.SolrDocumentEx in class SolrDocumentEx, tree.tpe=com.idc.webchannel.search.indexer.solr.SolrDocumentEx
[INFO]         $anon.super."<init>" // def <init>(): com.idc.webchannel.search.indexer.solr.SolrDocumentEx in class SolrDocumentEx, tree.tpe=()com.idc.webchannel.search.indexer.solr.SolrDocumentEx
[INFO]         Nil
[INFO]       )
[INFO]       ()
[INFO]     )
[INFO]   )
[INFO]   ValDef( // private[this] val md: com.idc.webchannel.search.indexer.core.converter.FromResearchDocumentConverter.MetaCopDocument
[INFO]     private <local> <triedcooking>
[INFO]     "md"
[INFO]     "MetaCopDocument"
[INFO]     Block(
[INFO]       ValDef( // val md: com.idc.publishing.metacop.consumer.entity.Document
[INFO]         <triedcooking>
[INFO]         "md"
[INFO]         <tpt> // tree.tpe=com.idc.publishing.metacop.consumer.entity.Document
[INFO]         Apply( // def getDocumentById(x$1: String): com.idc.publishing.metacop.consumer.entity.Document in class DocumentService, tree.tpe=com.idc.publishing.metacop.consumer.entity.Document
[INFO]           "metacopDocumentService"."getDocumentById" // def getDocumentById(x$1: String): com.idc.publishing.metacop.consumer.entity.Document in class DocumentService, tree.tpe=(x$1: String)com.idc.publishing.metacop.consumer.entity.Document
[INFO]           "d"."containerId" // def containerId: String in class Document, tree.tpe=String
[INFO]         )
[INFO]       )
[INFO]       If(
[INFO]         Apply( // final def !=(x$1: AnyRef): Boolean in class Object, tree.tpe=Boolean
[INFO]           "md"."$bang$eq" // final def !=(x$1: AnyRef): Boolean in class Object, tree.tpe=(x$1: AnyRef)Boolean
[INFO]           null
[INFO]         )
[INFO]         "md" // val md: com.idc.publishing.metacop.consumer.entity.Document, tree.tpe=com.idc.publishing.metacop.consumer.entity.Document
[INFO]         Block(
[INFO]           ClassDef( // final class $anon extends Document
[INFO]             final
[INFO]             "$anon"
[INFO]             []
[INFO]             Template( // val <local $anon>: <notype>
[INFO]               "MetaCopDocument" // parents
[INFO]               ValDef(
[INFO]                 private
[INFO]                 "_"
[INFO]                 <tpt>
[INFO]                 <empty>
[INFO]               )
[INFO]               // 4 statements
[INFO]               DefDef( // def <init>(): com.idc.publishing.metacop.consumer.entity.Document
[INFO]                 <method> <triedcooking>
[INFO]                 "<init>"
[INFO]                 []
[INFO]                 List(Nil)
[INFO]                 <tpt> // tree.tpe=com.idc.publishing.metacop.consumer.entity.Document
[INFO]                 Block( // tree.tpe=Unit
[INFO]                   Apply( // def <init>(): com.idc.publishing.metacop.consumer.entity.Document in class Document, tree.tpe=com.idc.publishing.metacop.consumer.entity.Document
[INFO]                     $anon.super."<init>" // def <init>(): com.idc.publishing.metacop.consumer.entity.Document in class Document, tree.tpe=()com.idc.publishing.metacop.consumer.entity.Document
[INFO]                     Nil
[INFO]                   )
[INFO]                   ()
[INFO]                 )
[INFO]               )
[INFO]               Apply(
[INFO]                 "setContainerId"
[INFO]                 "d"."containerId" // def containerId: String in class Document, tree.tpe=String
[INFO]               )
[INFO]               Apply(
[INFO]                 "setCompanies"
[INFO]                 TypeApply(
[INFO]                   "immutable"."Set"."empty"
[INFO]                   "Company"
[INFO]                 )
[INFO]               )
[INFO]               Apply(
[INFO]                 "setCategories"
[INFO]                 TypeApply(
[INFO]                   "immutable"."Set"."empty"
[INFO]                   "Category"
[INFO]                 )
[INFO]               )
[INFO]             )
[INFO]           )
[INFO]           Apply( // def <init>(): com.idc.publishing.metacop.consumer.entity.Document, tree.tpe=com.idc.publishing.metacop.consumer.entity.Document
[INFO]             new $anon."<init>" // def <init>(): com.idc.publishing.metacop.consumer.entity.Document, tree.tpe=()com.idc.publishing.metacop.consumer.entity.Document
[INFO]             Nil
[INFO]           )
[INFO]         )
[INFO]       )
[INFO]     )
[INFO]   )
[INFO]   Apply(
[INFO]     "addField"
[INFO]     // 2 arguments
[INFO]     "rsd_container_id"
[INFO]     "d"."containerId" // def containerId: String in class Document, tree.tpe=String
[INFO]   )
[INFO]   Apply(
[INFO]     "addField"
[INFO]     // 2 arguments
[INFO]     "rsd_ccon_id"
[INFO]     "d"."cconId" // def cconId: Long in class Document, tree.tpe=Long
[INFO]   )
[INFO]   Apply(
[INFO]     "addField"
[INFO]     // 2 arguments
[INFO]     "rsd_doc_type_id"
[INFO]     "d"."docTypeId" // def docTypeId: Long in class Document, tree.tpe=Long
[INFO]   )
[INFO]   Apply(
[INFO]     "addField"
[INFO]     // 2 arguments
[INFO]     "rsd_doc_type_code"
[INFO]     "d"."docTypeCode" // def docTypeCode: String in class Document, tree.tpe=String
[INFO]   )
[INFO]   Apply(
[INFO]     "addField"
[INFO]     // 2 arguments
[INFO]     "rsd_doc_type_name"
[INFO]     "d"."docTypeName" // def docTypeName: String in class Document, tree.tpe=String
[INFO]   )
[INFO]   Apply(
[INFO]     "addField"
[INFO]     // 2 arguments
[INFO]     "rsd_doc_subtype_id"
[INFO]     "d"."docSubTypeId" // def docSubTypeId: Long in class Document, tree.tpe=Long
[INFO]   )
[INFO]   Apply(
[INFO]     "addField"
[INFO]     // 2 arguments
[INFO]     "rsd_doc_subtype_code"
[INFO]     "d"."docSubTypeCode" // def docSubTypeCode: String in class Document, tree.tpe=String
[INFO]   )
[INFO]   Apply(
[INFO]     "addField"
[INFO]     // 2 arguments
[INFO]     "rsd_doc_subtype_name"
[INFO]     "d"."docSubTypeName" // def docSubTypeName: String in class Document, tree.tpe=String
[INFO]   )
[INFO]   ValDef( // private[this] val lang: String
[INFO]     private <local> <triedcooking>
[INFO]     "lang"
[INFO]     <tpt> // tree.tpe=String
[INFO]     Apply( // def getOrElse[B1 >: B](key: A,default: => B1): B1 in trait MapLike
[INFO]       "ISOLanguageConverter"."two2three"."getOrElse" // def getOrElse[B1 >: B](key: A,default: => B1): B1 in trait MapLike, tree.tpe=[B1 >: String](key: String, default: => B1)B1
[INFO]       // 2 arguments
[INFO]       "md"."getLanguage"
[INFO]       "xxx"
[INFO]     )
[INFO]   )
[INFO]   Apply(
[INFO]     "addField"
[INFO]     // 2 arguments
[INFO]     "rsd_lang"
[INFO]     "lang"
[INFO]   )
[INFO]   Apply(
[INFO]     "addField"
[INFO]     // 2 arguments
[INFO]     Apply( // final def +(x$1: Any): String in class String
[INFO]       "rsd_title_"."$plus" // final def +(x$1: Any): String in class String, tree.tpe=(x$1: Any)String
[INFO]       "lang"
[INFO]     )
[INFO]     "d"."title" // def title: String in class Document, tree.tpe=String
[INFO]   )
[INFO]   Apply(
[INFO]     "d"."services"."foreach"
[INFO]     Function( // val $anonfun: <notype>
[INFO]       ValDef( // s: com.idc.webchannel.search.indexer.domain.SubscriptionService
[INFO]         <param> <triedcooking>
[INFO]         "s"
[INFO]         <tpt> // tree.tpe=com.idc.webchannel.search.indexer.domain.SubscriptionService
[INFO]         <empty>
[INFO]       )
[INFO]       Block(
[INFO]         // 2 statements
[INFO]         Apply(
[INFO]           "addField"
[INFO]           // 2 arguments
[INFO]           "rsd_service_id"
[INFO]           "s"."id" // def id: Long in class SubscriptionService, tree.tpe=Long
[INFO]         )
[INFO]         Apply(
[INFO]           "addField"
[INFO]           // 2 arguments
[INFO]           "rsd_service_name"
[INFO]           "s"."name" // val name: String in class SubscriptionService, tree.tpe=String
[INFO]         )
[INFO]         Apply(
[INFO]           "addField"
[INFO]           // 2 arguments
[INFO]           "rsd_service_json"
[INFO]           new JSONObject(s)."toString"
[INFO]         )
[INFO]       )
[INFO]     )
[INFO]   )
[INFO]   Apply(
[INFO]     "addField"
[INFO]     // 2 arguments
[INFO]     "rsd_source_company"
[INFO]     "d"."sourceCompanyCode" // def sourceCompanyCode: String in class Document, tree.tpe=String
[INFO]   )
[INFO]   Apply(
[INFO]     "addField"
[INFO]     // 2 arguments
[INFO]     "rsd_has_competitive_analysis"
[INFO]     "d"."hasCompetitiveAnalysis" // def hasCompetitiveAnalysis: Boolean in class Document, tree.tpe=Boolean
[INFO]   )
[INFO]   Apply(
[INFO]     "addField"
[INFO]     // 2 arguments
[INFO]     "rsd_has_survey"
[INFO]     "d"."hasSurveyData" // def hasSurveyData: Boolean in class Document, tree.tpe=Boolean
[INFO]   )
[INFO]   Apply(
[INFO]     "addKeywordsForContextualBoosting"
[INFO]     "d" // d: com.idc.webchannel.search.indexer.core.converter.FromResearchDocumentConverter.IndexerDocument, tree.tpe=com.idc.webchannel.search.indexer.core.converter.FromResearchDocumentConverter.IndexerDocument
[INFO]   )
[INFO]   Apply(
[INFO]     "addField"
[INFO]     // 2 arguments
[INFO]     "rsd_has_forecast"
[INFO]     Apply( // final def !=(x$1: AnyRef): Boolean in class Object, tree.tpe=Boolean
[INFO]       "d"."forecast"."$bang$eq" // final def !=(x$1: AnyRef): Boolean in class Object, tree.tpe=(x$1: AnyRef)Boolean
[INFO]       null
[INFO]     )
[INFO]   )
[INFO]   If(
[INFO]     Apply( // final def !=(x$1: AnyRef): Boolean in class Object, tree.tpe=Boolean
[INFO]       "d"."forecast"."$bang$eq" // final def !=(x$1: AnyRef): Boolean in class Object, tree.tpe=(x$1: AnyRef)Boolean
[INFO]       null
[INFO]     )
[INFO]     Block(
[INFO]       Apply(
[INFO]         "addField"
[INFO]         // 2 arguments
[INFO]         "rsd_forecast_begin_year"
[INFO]         "d"."forecast"."beginYear" // val beginYear: Integer in class Forecast, tree.tpe=Integer
[INFO]       )
[INFO]       Apply(
[INFO]         "addField"
[INFO]         // 2 arguments
[INFO]         "rsd_forecast_end_year"
[INFO]         "d"."forecast"."endYear" // val endYear: Integer in class Forecast, tree.tpe=Integer
[INFO]       )
[INFO]     )
[INFO]     ()
[INFO]   )
[INFO]   Apply(
[INFO]     "d"."authors"."foreach"
[INFO]     Function( // val $anonfun: <notype>
[INFO]       ValDef( // author: com.idc.webchannel.search.indexer.domain.Author
[INFO]         <param> <triedcooking>
[INFO]         "author"
[INFO]         <tpt> // tree.tpe=com.idc.webchannel.search.indexer.domain.Author
[INFO]         <empty>
[INFO]       )
[INFO]       Block(
[INFO]         // 2 statements
[INFO]         Apply(
[INFO]           "addField"
[INFO]           // 2 arguments
[INFO]           "rsd_author_id"
[INFO]           "author"."prfId" // val prfId: String in class Author, tree.tpe=String
[INFO]         )
[INFO]         Apply(
[INFO]           "addField"
[INFO]           // 2 arguments
[INFO]           "rsd_author_name"
[INFO]           "author"."fullName" // val fullName: String in class Author, tree.tpe=String
[INFO]         )
[INFO]         Apply(
[INFO]           "addField"
[INFO]           // 2 arguments
[INFO]           "rsd_author_json"
[INFO]           new JSONObject(author)."toString"
[INFO]         )
[INFO]       )
[INFO]     )
[INFO]   )
[INFO]   Apply(
[INFO]     "d"."acl"."foreach"
[INFO]     Function( // val $anonfun: <notype>
[INFO]       ValDef( // x$1: String
[INFO]         <param> <synthetic> <triedcooking>
[INFO]         "x$1"
[INFO]         <tpt> // tree.tpe=String
[INFO]         <empty>
[INFO]       )
[INFO]       Apply(
[INFO]         "addField"
[INFO]         // 2 arguments
[INFO]         "rsd_acl"
[INFO]         "x$1" // x$1: String, tree.tpe=String
[INFO]       )
[INFO]     )
[INFO]   )
[INFO]   Apply(
[INFO]     "md"."getCompanies"."foreach"
[INFO]     Function( // val $anonfun: <notype>
[INFO]       ValDef( // company: com.idc.publishing.metacop.consumer.entity.Company
[INFO]         <param> <triedcooking>
[INFO]         "company"
[INFO]         <tpt> // tree.tpe=com.idc.publishing.metacop.consumer.entity.Company
[INFO]         <empty>
[INFO]       )
[INFO]       Block(
[INFO]         // 4 statements
[INFO]         Apply(
[INFO]           "addField"
[INFO]           // 2 arguments
[INFO]           "rsd_company_name"
[INFO]           "company"."getName" // def getName(): String in class Company, tree.tpe=()String
[INFO]         )
[INFO]         Apply(
[INFO]           "addField"
[INFO]           // 2 arguments
[INFO]           "rsd_company_symbol"
[INFO]           "company"."getSymbol" // def getSymbol(): String in class Company, tree.tpe=()String
[INFO]         )
[INFO]         Apply(
[INFO]           "addField"
[INFO]           // 2 arguments
[INFO]           "rsd_company_ticker"
[INFO]           "company"."getTicker" // def getTicker(): String in class Company, tree.tpe=()String
[INFO]         )
[INFO]         If(
[INFO]           Apply(
[INFO]             "company"."getAliases"."$bang$eq"
[INFO]             null
[INFO]           )
[INFO]           Apply(
[INFO]             "company"."getAliases"."foreach"
[INFO]             Function( // val $anonfun: <notype>
[INFO]               ValDef( // x$2: String
[INFO]                 <param> <synthetic> <triedcooking>
[INFO]                 "x$2"
[INFO]                 <tpt> // tree.tpe=String
[INFO]                 <empty>
[INFO]               )
[INFO]               Apply(
[INFO]                 "addField"
[INFO]                 // 2 arguments
[INFO]                 "rsd_company_alias"
[INFO]                 "x$2" // x$2: String, tree.tpe=String
[INFO]               )
[INFO]             )
[INFO]           )
[INFO]           ()
[INFO]         )
[INFO]         Apply(
[INFO]           "addField"
[INFO]           // 2 arguments
[INFO]           "rsd_company_json"
[INFO]           new JSONObject().put("name", company.getName).put("symbol", company.getSymbol).put("ticker", company.getTicker).put("aliases", company.getAliases)."toString"
[INFO]         )
[INFO]       )
[INFO]     )
[INFO]   )
[INFO]   Apply(
[INFO]     taxonomyTokensOf(md.getCategories.map(((cat: com.idc.publishing.metacop.consumer.entity.Category) => Option(cat.getTaxonomyClass))).filter(None.$bang$eq).map(((x$3: Option[com.idc.publishing.metacop.consumer.entity.TaxonomyClass]) => x$3.get)))."foreach"
[INFO]     Match(
[INFO]       <empty>
[INFO]       CaseDef(
[INFO]         Apply( // object Tuple2 in package scala
[INFO]           "scala"."Tuple2" // object Tuple2 in package scala, tree.tpe=Tuple2.type
[INFO]           // 2 arguments
[INFO]           Bind( // val txRootNode: com.idc.webchannel.search.indexer.solr.TxNodeName.TxNodeName, tree.tpe=com.idc.webchannel.search.indexer.solr.TxNodeName.TxNodeName
[INFO]             "txRootNode"
[INFO]             "_" // tree.tpe=com.idc.webchannel.search.indexer.solr.TxNodeName.TxNodeName
[INFO]           )
[INFO]           Bind( // val txToken: com.idc.webchannel.search.indexer.solr.TxToken, tree.tpe=com.idc.webchannel.search.indexer.solr.TxToken
[INFO]             "txToken"
[INFO]             "_" // tree.tpe=com.idc.webchannel.search.indexer.solr.TxToken
[INFO]           )
[INFO]         )
[INFO]         Block(
[INFO]           Apply(
[INFO]             "addTaxonomyField"
[INFO]             // 2 arguments
[INFO]             "txRootNode" // val txRootNode: com.idc.webchannel.search.indexer.solr.TxNodeName.TxNodeName, tree.tpe=com.idc.webchannel.search.indexer.solr.TxNodeName.TxNodeName
[INFO]             "txToken" // val txToken: com.idc.webchannel.search.indexer.solr.TxToken, tree.tpe=com.idc.webchannel.search.indexer.solr.TxToken
[INFO]           )
[INFO]           Match(
[INFO]             Apply( // object Tuple2 in package scala
[INFO]               "scala"."Tuple2" // object Tuple2 in package scala, tree.tpe=Tuple2.type
[INFO]               // 2 arguments
[INFO]               "txRootNode" // val txRootNode: com.idc.webchannel.search.indexer.solr.TxNodeName.TxNodeName, tree.tpe=com.idc.webchannel.search.indexer.solr.TxNodeName.TxNodeName
[INFO]               "txToken" // val txToken: com.idc.webchannel.search.indexer.solr.TxToken, tree.tpe=com.idc.webchannel.search.indexer.solr.TxToken
[INFO]             )
[INFO]             // 3 cases
[INFO]             CaseDef(
[INFO]               Apply( // object Tuple2 in package scala
[INFO]                 "scala"."Tuple2" // object Tuple2 in package scala, tree.tpe=Tuple2.type
[INFO]                 // 2 arguments
[INFO]                 "TxNodeName"."VerticalMarket"
[INFO]                 Apply(
[INFO]                   "TxToken"
[INFO]                   // 4 arguments
[INFO]                   0
[INFO]                   "_" // tree.tpe=String
[INFO]                   Bind( // val nodeId: String, tree.tpe=String
[INFO]                     "nodeId"
[INFO]                     "_" // tree.tpe=String
[INFO]                   )
[INFO]                   "_" // tree.tpe=String
[INFO]                 )
[INFO]               )
[INFO]               Match(
[INFO]                 Apply( // def get(key: A): Option[B] in trait MapLike, tree.tpe=Option[com.idc.webchannel.search.indexer.solr.BusinessUnit.Value]
[INFO]                   "buMapping"."decode"."get" // def get(key: A): Option[B] in trait MapLike, tree.tpe=(key: String)Option[com.idc.webchannel.search.indexer.solr.BusinessUnit.Value]
[INFO]                   "nodeId" // val nodeId: String, tree.tpe=String
[INFO]                 )
[INFO]                 // 2 cases
[INFO]                 CaseDef(
[INFO]                   Apply(
[INFO]                     "Some"
[INFO]                     Bind( // val site: com.idc.webchannel.search.indexer.solr.BusinessUnit.Value, tree.tpe=com.idc.webchannel.search.indexer.solr.BusinessUnit.Value
[INFO]                       "site"
[INFO]                       "_" // tree.tpe=com.idc.webchannel.search.indexer.solr.BusinessUnit.Value
[INFO]                     )
[INFO]                   )
[INFO]                   Apply(
[INFO]                     "addField"
[INFO]                     // 2 arguments
[INFO]                     "show_on_site"
[INFO]                     "site" // val site: com.idc.webchannel.search.indexer.solr.BusinessUnit.Value, tree.tpe=com.idc.webchannel.search.indexer.solr.BusinessUnit.Value
[INFO]                   )
[INFO]                 )
[INFO]                 CaseDef(
[INFO]                   "None"
[INFO]                   ()
[INFO]                 )
[INFO]               )
[INFO]             )
[INFO]             CaseDef(
[INFO]               Apply( // object Tuple2 in package scala
[INFO]                 "scala"."Tuple2" // object Tuple2 in package scala, tree.tpe=Tuple2.type
[INFO]                 // 2 arguments
[INFO]                 "TxNodeName"."ContentGroups"
[INFO]                 Apply(
[INFO]                   "TxToken"
[INFO]                   // 4 arguments
[INFO]                   "_" // tree.tpe=Int
[INFO]                   "_" // tree.tpe=String
[INFO]                   Bind( // val nodeId: String, tree.tpe=String
[INFO]                     "nodeId"
[INFO]                     "_" // tree.tpe=String
[INFO]                   )
[INFO]                   "_" // tree.tpe=String
[INFO]                 )
[INFO]               )
[INFO]               Match(
[INFO]                 Apply( // def get(key: A): Option[B] in trait MapLike, tree.tpe=Option[com.idc.webchannel.search.indexer.solr.TxNodeName.Value]
[INFO]                   "txMapping"."decode"."get" // def get(key: A): Option[B] in trait MapLike, tree.tpe=(key: String)Option[com.idc.webchannel.search.indexer.solr.TxNodeName.Value]
[INFO]                   "nodeId" // val nodeId: String, tree.tpe=String
[INFO]                 )
[INFO]                 // 3 cases
[INFO]                 CaseDef(
[INFO]                   Apply(
[INFO]                     "Some"
[INFO]                     "TxNodeName"."ContentGroups_MarketScape"
[INFO]                   )
[INFO]                   Apply(
[INFO]                     referenceBulkData(Companies).asInstanceOf[Iterable[Company]]."foreach"
[INFO]                     Function( // val $anonfun: <notype>
[INFO]                       ValDef( // company: com.idc.publishing.metacop.consumer.entity.Company
[INFO]                         <param> <triedcooking>
[INFO]                         "company"
[INFO]                         <tpt> // tree.tpe=com.idc.publishing.metacop.consumer.entity.Company
[INFO]                         <empty>
[INFO]                       )
[INFO]                       Apply(
[INFO]                         "addField"
[INFO]                         // 2 arguments
[INFO]                         "rsd_market_scape_company_kwd"
[INFO]                         "company"."getName" // def getName(): String in class Company, tree.tpe=()String
[INFO]                       )
[INFO]                     )
[INFO]                   )
[INFO]                 )
[INFO]                 CaseDef(
[INFO]                   Apply(
[INFO]                     "Some"
[INFO]                     "TxNodeName"."ContentGroups_MAP"
[INFO]                   )
[INFO]                   Block(
[INFO]                     Apply(
[INFO]                       referenceBulkData(TaxonomyTopics).asInstanceOf[Iterable[TaxonomyClass]]."foreach"
[INFO]                       Function( // val $anonfun: <notype>
[INFO]                         ValDef( // topic: com.idc.publishing.metacop.consumer.entity.TaxonomyClass
[INFO]                           <param> <triedcooking>
[INFO]                           "topic"
[INFO]                           <tpt> // tree.tpe=com.idc.publishing.metacop.consumer.entity.TaxonomyClass
[INFO]                           <empty>
[INFO]                         )
[INFO]                         Apply(
[INFO]                           "addField"
[INFO]                           // 2 arguments
[INFO]                           "rsd_map_topic_kwd"
[INFO]                           "topic"."getText" // def getText(): String in class TaxonomyClass, tree.tpe=()String
[INFO]                         )
[INFO]                       )
[INFO]                     )
[INFO]                     Apply(
[INFO]                       referenceBulkData(TaxonomyVerticalMarkets).asInstanceOf[Iterable[TaxonomyClass]]."foreach"
[INFO]                       Function( // val $anonfun: <notype>
[INFO]                         ValDef( // vm: com.idc.publishing.metacop.consumer.entity.TaxonomyClass
[INFO]                           <param> <triedcooking>
[INFO]                           "vm"
[INFO]                           <tpt> // tree.tpe=com.idc.publishing.metacop.consumer.entity.TaxonomyClass
[INFO]                           <empty>
[INFO]                         )
[INFO]                         Apply(
[INFO]                           "addField"
[INFO]                           // 2 arguments
[INFO]                           "rsd_map_vertical_market_kwd"
[INFO]                           "vm"."getText" // def getText(): String in class TaxonomyClass, tree.tpe=()String
[INFO]                         )
[INFO]                       )
[INFO]                     )
[INFO]                   )
[INFO]                 )
[INFO]                 CaseDef( // tree.tpe=Unit
[INFO]                   "_" // tree.tpe=Option[com.idc.webchannel.search.indexer.solr.TxNodeName.Value]
[INFO]                   ()
[INFO]                 )
[INFO]               )
[INFO]             )
[INFO]             CaseDef( // tree.tpe=Unit
[INFO]               "_" // tree.tpe=(com.idc.webchannel.search.indexer.solr.TxNodeName.TxNodeName, com.idc.webchannel.search.indexer.solr.TxToken)
[INFO]               ()
[INFO]             )
[INFO]           )
[INFO]         )
[INFO]       )
[INFO]     )
[INFO]   )
[INFO]   Block(
[INFO]     // 5 statements
[INFO]     TypeDef( // type Field = (String, String)
[INFO]       0
[INFO]       "Field"
[INFO]       []
[INFO]       AppliedTypeTree( // case class Tuple2[+T1, +T2] extends Product2[T1,T2] with Product with Serializable in package scala
[INFO]         "scala"."Tuple2" // case class Tuple2[+T1, +T2] extends Product2[T1,T2] with Product with Serializable in package scala, tree.tpe=Tuple2
[INFO]         // 2 arguments
[INFO]         "String"
[INFO]         "String"
[INFO]       )
[INFO]     )
[INFO]     TypeDef( // type IndexedAttachment = List[(String, String)]
[INFO]       0
[INFO]       "IndexedAttachment"
[INFO]       []
[INFO]       AppliedTypeTree(
[INFO]         "List"
[INFO]         "Field" // type Field = (String, String), tree.tpe=(String, String)
[INFO]       )
[INFO]     )
[INFO]     ValDef( // val attachmentsFuture: scala.concurrent.Future[List[IndexedAttachment]]
[INFO]       <triedcooking>
[INFO]       "attachmentsFuture"
[INFO]       AppliedTypeTree(
[INFO]         "Future"
[INFO]         AppliedTypeTree(
[INFO]           "List"
[INFO]           "IndexedAttachment" // type IndexedAttachment = List[(String, String)], tree.tpe=IndexedAttachment
[INFO]         )
[INFO]       )
[INFO]       Block(
[INFO]         DefDef( // def asIndexedAttachment(attach: com.idc.webchannel.search.indexer.domain.Attachment): IndexedAttachment
[INFO]           <method> <triedcooking>
[INFO]           "asIndexedAttachment"
[INFO]           []
[INFO]           // 1 parameter list
[INFO]           ValDef( // attach: com.idc.webchannel.search.indexer.domain.Attachment
[INFO]             <param> <triedcooking>
[INFO]             "attach"
[INFO]             "Attachment"
[INFO]             <empty>
[INFO]           )
[INFO]           "IndexedAttachment" // type IndexedAttachment = List[(String, String)], tree.tpe=IndexedAttachment
[INFO]           Block(
[INFO]             ValDef( // val indexerAttach: List[(String, String)]
[INFO]               <triedcooking>
[INFO]               "indexerAttach"
[INFO]               <tpt> // tree.tpe=List[(String, String)]
[INFO]               Apply(
[INFO]                 "List"
[INFO]                 // 2 arguments
[INFO]                 Apply(
[INFO]                   "rsd_attachment_json"."$minus$greater"
[INFO]                   new JSONObject(attach)."toString"
[INFO]                 )
[INFO]                 Apply(
[INFO]                   "rsd_attachment_filetype"."$minus$greater"
[INFO]                   "attach"."filetype" // val filetype: String in class Attachment, tree.tpe=String
[INFO]                 )
[INFO]               )
[INFO]             )
[INFO]             If(
[INFO]               "attach"."indexed"."unary_$bang" // def unary_!: Boolean in class Boolean, tree.tpe=Boolean
[INFO]               "indexerAttach" // val indexerAttach: List[(String, String)], tree.tpe=List[(String, String)]
[INFO]               Block(
[INFO]                 ValDef( // val attachmentFile: java.io.File
[INFO]                   <triedcooking>
[INFO]                   "attachmentFile"
[INFO]                   <tpt> // tree.tpe=java.io.File
[INFO]                   Apply( // def getAttachmentFileFor(documentId: String,fileType: String): java.io.File in trait DocumentAttachmentService, tree.tpe=java.io.File
[INFO]                     "attachmentService"."getAttachmentFileFor" // def getAttachmentFileFor(documentId: String,fileType: String): java.io.File in trait DocumentAttachmentService, tree.tpe=(documentId: String, fileType: String)java.io.File
[INFO]                     // 2 arguments
[INFO]                     "d"."containerId" // def containerId: String in class Document, tree.tpe=String
[INFO]                     "attach"."filename" // val filename: String in class Attachment, tree.tpe=String
[INFO]                   )
[INFO]                 )
[INFO]                 If(
[INFO]                   Apply( // final def ==(x$1: AnyRef): Boolean in class Object, tree.tpe=Boolean
[INFO]                     "attachmentFile"."$eq$eq" // final def ==(x$1: AnyRef): Boolean in class Object, tree.tpe=(x$1: AnyRef)Boolean
[INFO]                     null
[INFO]                   )
[INFO]                   "indexerAttach" // val indexerAttach: List[(String, String)], tree.tpe=List[(String, String)]
[INFO]                   Block(
[INFO]                     ValDef( // val attachmentText: String
[INFO]                       <triedcooking>
[INFO]                       "attachmentText"
[INFO]                       <tpt> // tree.tpe=String
[INFO]                       Try(
[INFO]                         Apply( // def extractFrom(file: java.io.File): String in trait TextExtractor, tree.tpe=String
[INFO]                           "textExtractor"."extractFrom" // def extractFrom(file: java.io.File): String in trait TextExtractor, tree.tpe=(file: java.io.File)String
[INFO]                           "attachmentFile" // val attachmentFile: java.io.File, tree.tpe=java.io.File
[INFO]                         )
[INFO]                         // 2 cases
[INFO]                         CaseDef(
[INFO]                           Bind( // val e: InterruptedException
[INFO]                             "e"
[INFO]                             Typed(
[INFO]                               "_" // tree.tpe=InterruptedException
[INFO]                               "InterruptedException"
[INFO]                             )
[INFO]                           )
[INFO]                           Throw("e")tree.tpe=Nothing
[INFO]                         )
[INFO]                         CaseDef(
[INFO]                           Bind( // val e: Exception
[INFO]                             "e"
[INFO]                             Typed(
[INFO]                               "_" // tree.tpe=Exception
[INFO]                               "Exception"
[INFO]                             )
[INFO]                           )
[INFO]                           Block(
[INFO]                             Apply(
[WARNING]                               "log"."warn"
[INFO]                               // 3 arguments
[ERROR]                               "Error while extracting text from \'{}\': {}"
[INFO]                               "attachmentFile" // val attachmentFile: java.io.File, tree.tpe=java.io.File
[INFO]                               Apply(
[INFO]                                 "ExceptionUtils"."getRootCauseMessage"
[INFO]                                 "e" // val e: Exception, tree.tpe=Exception
[INFO]                               )
[INFO]                             )
[INFO]                             null
[INFO]                           )
[INFO]                         )
[INFO]                       )
[INFO]                     )
[INFO]                     Block(
[INFO]                       ValDef( // val x$4: (String, String)
[INFO]                         <synthetic> <triedcooking>
[INFO]                         "x$4"
[INFO]                         <tpt> // tree.tpe=(String, String)
[INFO]                         Apply(
[INFO]                           "rsd_attachment_content_".+(lang)."$minus$greater"
[INFO]                           "attachmentText" // val attachmentText: String, tree.tpe=String
[INFO]                         )
[INFO]                       )
[INFO]                       Apply( // override def +:[B >: A, That](elem: B)(implicit bf: scala.collection.generic.CanBuildFrom[List[A],B,That]): That in class List
[INFO]                         "indexerAttach"."$plus$colon" // override def +:[B >: A, That](elem: B)(implicit bf: scala.collection.generic.CanBuildFrom[List[A],B,That]): That in class List, tree.tpe=[B >: (String, String), That](elem: B)(implicit bf: scala.collection.generic.CanBuildFrom[List[(String, String)],B,That])That
[INFO]                         "x$4" // val x$4: (String, String), tree.tpe=(String, String)
[INFO]                       )
[INFO]                     )
[INFO]                   )
[INFO]                 )
[INFO]               )
[INFO]             )
[INFO]           )
[INFO]         )
[INFO]         Apply(
[INFO]           Block(
[INFO]             ValDef( // val x$5: scala.concurrent.Future[List[IndexedAttachment]]
[INFO]               <synthetic> <triedcooking>
[INFO]               "x$5"
[INFO]               <tpt> // tree.tpe=scala.concurrent.Future[List[IndexedAttachment]]
[INFO]               Apply(
[INFO]                 "Future"."successful"
[INFO]                 TypeApply(
[INFO]                   "List"."empty"
[INFO]                   "IndexedAttachment" // type IndexedAttachment = List[(String, String)], tree.tpe=IndexedAttachment
[INFO]                 )
[INFO]               )
[INFO]             )
[INFO]             Apply(
[INFO]               "d"."attachments"."$div$colon"
[INFO]               "x$5" // val x$5: scala.concurrent.Future[List[IndexedAttachment]], tree.tpe=scala.concurrent.Future[List[IndexedAttachment]]
[INFO]             )
[INFO]           )
[INFO]           Match(
[INFO]             <empty>
[INFO]             CaseDef(
[INFO]               Apply( // object Tuple2 in package scala
[INFO]                 "scala"."Tuple2" // object Tuple2 in package scala, tree.tpe=Tuple2.type
[INFO]                 // 2 arguments
[INFO]                 Bind( // val f: scala.concurrent.Future[List[IndexedAttachment]]
[INFO]                   "f"
[INFO]                   Typed(
[INFO]                     "_" // tree.tpe=scala.concurrent.Future[List[IndexedAttachment]]
[INFO]                     AppliedTypeTree(
[INFO]                       "Future"
[INFO]                       AppliedTypeTree(
[INFO]                         "List"
[INFO]                         "IndexedAttachment" // type IndexedAttachment = List[(String, String)], tree.tpe=IndexedAttachment
[INFO]                       )
[INFO]                     )
[INFO]                   )
[INFO]                 )
[INFO]                 Bind( // val attach: com.idc.webchannel.search.indexer.domain.Attachment
[INFO]                   "attach"
[INFO]                   Typed(
[INFO]                     "_" // tree.tpe=com.idc.webchannel.search.indexer.domain.Attachment
[INFO]                     "Attachment"
[INFO]                   )
[INFO]                 )
[INFO]               )
[INFO]               Apply( // def map[S](f: T => S)(implicit executor: scala.concurrent.ExecutionContext): scala.concurrent.Future[S] in trait Future
[INFO]                 "f"."map" // def map[S](f: T => S)(implicit executor: scala.concurrent.ExecutionContext): scala.concurrent.Future[S] in trait Future, tree.tpe=[S](f: List[IndexedAttachment] => S)(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[S]
[INFO]                 Function( // val $anonfun: <notype>
[INFO]                   ValDef( // x$6: List[IndexedAttachment]
[INFO]                     <param> <synthetic> <triedcooking>
[INFO]                     "x$6"
[INFO]                     <tpt> // tree.tpe=List[IndexedAttachment]
[INFO]                     <empty>
[INFO]                   )
[INFO]                   Block(
[INFO]                     ValDef( // val x$7: IndexedAttachment
[INFO]                       <synthetic> <triedcooking>
[INFO]                       "x$7"
[INFO]                       <tpt> // tree.tpe=IndexedAttachment
[INFO]                       Apply( // def asIndexedAttachment(attach: com.idc.webchannel.search.indexer.domain.Attachment): IndexedAttachment, tree.tpe=IndexedAttachment
[INFO]                         "asIndexedAttachment" // def asIndexedAttachment(attach: com.idc.webchannel.search.indexer.domain.Attachment): IndexedAttachment, tree.tpe=(attach: com.idc.webchannel.search.indexer.domain.Attachment)IndexedAttachment
[INFO]                         "attach" // val attach: com.idc.webchannel.search.indexer.domain.Attachment, tree.tpe=com.idc.webchannel.search.indexer.domain.Attachment
[INFO]                       )
[INFO]                     )
[INFO]                     Apply( // override def +:[B >: A, That](elem: B)(implicit bf: scala.collection.generic.CanBuildFrom[List[A],B,That]): That in class List
[INFO]                       "x$6"."$plus$colon" // override def +:[B >: A, That](elem: B)(implicit bf: scala.collection.generic.CanBuildFrom[List[A],B,That]): That in class List, tree.tpe=[B >: IndexedAttachment, That](elem: B)(implicit bf: scala.collection.generic.CanBuildFrom[List[IndexedAttachment],B,That])That
[INFO]                       "x$7" // val x$7: IndexedAttachment, tree.tpe=IndexedAttachment
[INFO]                     )
[INFO]                   )
[INFO]                 )
[INFO]               )
[INFO]             )
[INFO]           )
[INFO]         )
[INFO]       )
[INFO]     )
[INFO]     ValDef( // val synopsisFuture: scala.concurrent.Future[List[(String, String)]]
[INFO]       <triedcooking>
[INFO]       "synopsisFuture"
[INFO]       AppliedTypeTree(
[INFO]         "Future"
[INFO]         AppliedTypeTree(
[INFO]           "List"
[INFO]           "Field" // type Field = (String, String), tree.tpe=(String, String)
[INFO]         )
[INFO]       )
[INFO]       If(
[INFO]         Apply( // final def !=(x$1: AnyRef): Boolean in class Object, tree.tpe=Boolean
[INFO]           "d"."synopsis"."$bang$eq" // final def !=(x$1: AnyRef): Boolean in class Object, tree.tpe=(x$1: AnyRef)Boolean
[INFO]           null
[INFO]         )
[INFO]         Apply(
[INFO]           "future"
[INFO]           Apply(
[INFO]             "List"
[INFO]             // 2 arguments
[INFO]             Apply(
[INFO]               "rsd_synopsis"."$minus$greater"
[INFO]               "d"."synopsis" // def synopsis: String in class Document, tree.tpe=String
[INFO]             )
[INFO]             Apply(
[INFO]               "rsd_synopsis_".+(lang)."$minus$greater"
[INFO]               Apply( // def extractFromHTML(html: String): String in trait TextExtractor, tree.tpe=String
[INFO]                 "textExtractor"."extractFromHTML" // def extractFromHTML(html: String): String in trait TextExtractor, tree.tpe=(html: String)String
[INFO]                 "d"."synopsis" // def synopsis: String in class Document, tree.tpe=String
[INFO]               )
[INFO]             )
[INFO]           )
[INFO]         )
[INFO]         Apply(
[INFO]           "Future"."successful"
[INFO]           "List"."empty"
[INFO]         )
[INFO]       )
[INFO]     )
[INFO]     ValDef( // val sectionsFuture: scala.concurrent.Future[List[(String, String)]]
[INFO]       <triedcooking>
[INFO]       "sectionsFuture"
[INFO]       AppliedTypeTree(
[INFO]         "Future"
[INFO]         AppliedTypeTree(
[INFO]           "List"
[INFO]           "Field" // type Field = (String, String), tree.tpe=(String, String)
[INFO]         )
[INFO]       )
[INFO]       Apply(
[INFO]         Block(
[INFO]           ValDef( // val x$9: scala.concurrent.Future[List[(String, String)]]
[INFO]             <synthetic> <triedcooking>
[INFO]             "x$9"
[INFO]             <tpt> // tree.tpe=scala.concurrent.Future[List[(String, String)]]
[INFO]             Apply(
[INFO]               "Future"."successful"
[INFO]               TypeApply(
[INFO]                 "List"."empty"
[INFO]                 "Field" // type Field = (String, String), tree.tpe=(String, String)
[INFO]               )
[INFO]             )
[INFO]           )
[INFO]           Apply(
[INFO]             d.sections.filter(((x$8: com.idc.webchannel.search.indexer.domain.DocumentSection) => x$8.body.!=(null)))."$div$colon"
[INFO]             "x$9" // val x$9: scala.concurrent.Future[List[(String, String)]], tree.tpe=scala.concurrent.Future[List[(String, String)]]
[INFO]           )
[INFO]         )
[INFO]         Match(
[INFO]           <empty>
[INFO]           CaseDef(
[INFO]             Apply( // object Tuple2 in package scala
[INFO]               "scala"."Tuple2" // object Tuple2 in package scala, tree.tpe=Tuple2.type
[INFO]               // 2 arguments
[INFO]               Bind( // val f: scala.concurrent.Future[List[(String, String)]], tree.tpe=scala.concurrent.Future[List[(String, String)]]
[INFO]                 "f"
[INFO]                 "_" // tree.tpe=scala.concurrent.Future[List[(String, String)]]
[INFO]               )
[INFO]               Bind( // val s: com.idc.webchannel.search.indexer.domain.DocumentSection, tree.tpe=com.idc.webchannel.search.indexer.domain.DocumentSection
[INFO]                 "s"
[INFO]                 "_" // tree.tpe=com.idc.webchannel.search.indexer.domain.DocumentSection
[INFO]               )
[INFO]             )
[INFO]             Apply( // def map[S](f: T => S)(implicit executor: scala.concurrent.ExecutionContext): scala.concurrent.Future[S] in trait Future
[INFO]               "f"."map" // def map[S](f: T => S)(implicit executor: scala.concurrent.ExecutionContext): scala.concurrent.Future[S] in trait Future, tree.tpe=[S](f: List[(String, String)] => S)(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[S]
[INFO]               Function( // val $anonfun: <notype>
[INFO]                 ValDef( // x$10: List[(String, String)]
[INFO]                   <param> <synthetic> <triedcooking>
[INFO]                   "x$10"
[INFO]                   <tpt> // tree.tpe=List[(String, String)]
[INFO]                   <empty>
[INFO]                 )
[INFO]                 Block(
[INFO]                   ValDef( // val x$11: (String, String)
[INFO]                     <synthetic> <triedcooking>
[INFO]                     "x$11"
[INFO]                     <tpt> // tree.tpe=(String, String)
[INFO]                     Apply(
[INFO]                       "rsd_content_".+(lang)."$minus$greater"
[INFO]                       Apply( // def extractFromHTML(html: String): String in trait TextExtractor, tree.tpe=String
[INFO]                         "textExtractor"."extractFromHTML" // def extractFromHTML(html: String): String in trait TextExtractor, tree.tpe=(html: String)String
[INFO]                         "s"."body" // val body: String in class DocumentSection, tree.tpe=String
[INFO]                       )
[INFO]                     )
[INFO]                   )
[INFO]                   Apply( // override def +:[B >: A, That](elem: B)(implicit bf: scala.collection.generic.CanBuildFrom[List[A],B,That]): That in class List
[INFO]                     "x$10"."$plus$colon" // override def +:[B >: A, That](elem: B)(implicit bf: scala.collection.generic.CanBuildFrom[List[A],B,That]): That in class List, tree.tpe=[B >: (String, String), That](elem: B)(implicit bf: scala.collection.generic.CanBuildFrom[List[(String, String)],B,That])That
[INFO]                     "x$11" // val x$11: (String, String), tree.tpe=(String, String)
[INFO]                   )
[INFO]                 )
[INFO]               )
[INFO]             )
[INFO]           )
[INFO]         )
[INFO]       )
[INFO]     )
[INFO]     Apply(
[INFO]       "Await"."result"
[INFO]       // 2 arguments
[INFO]       AssignOrNamedArg(
[INFO]         "atMost"
[INFO]         "Duration"."Inf"
[INFO]       )
[INFO]       AssignOrNamedArg(
[INFO]         "awaitable"
[INFO]         Apply( // def flatMap[S](f: T => scala.concurrent.Future[S])(implicit executor: scala.concurrent.ExecutionContext): scala.concurrent.Future[S] in trait Future
[INFO]           "attachmentsFuture"."flatMap" // def flatMap[S](f: T => scala.concurrent.Future[S])(implicit executor: scala.concurrent.ExecutionContext): scala.concurrent.Future[S] in trait Future, tree.tpe=[S](f: List[IndexedAttachment] => scala.concurrent.Future[S])(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[S]
[INFO]           Function( // val $anonfun: <notype>
[INFO]             ValDef( // indexedAttachments: List[IndexedAttachment]
[INFO]               <param> <triedcooking>
[INFO]               "indexedAttachments"
[INFO]               <tpt> // tree.tpe=List[IndexedAttachment]
[INFO]               <empty>
[INFO]             )
[INFO]             Apply(
[INFO]               synopsisFuture.withFilter(((check$ifrefutable$1: List[(String, String)]) => check$ifrefutable$1: @scala.unchecked match {
[INFO]   case (synopsis @ (_: List[Field])) => true
[INFO]   case _ => false
[INFO] }))."flatMap"
[INFO]               Function( // val $anonfun: <notype>
[INFO]                 ValDef( // synopsis: List[(String, String)]
[INFO]                   <param> <triedcooking>
[INFO]                   "synopsis"
[INFO]                   AppliedTypeTree(
[INFO]                     "List"
[INFO]                     "Field" // type Field = (String, String), tree.tpe=(String, String)
[INFO]                   )
[INFO]                   <empty>
[INFO]                 )
[INFO]                 Apply(
[INFO]                   sectionsFuture.withFilter(((check$ifrefutable$2: List[(String, String)]) => check$ifrefutable$2: @scala.unchecked match {
[INFO]   case (sections @ (_: List[Field])) => true
[INFO]   case _ => false
[INFO] }))."flatMap"
[INFO]                   Function( // val $anonfun: <notype>
[INFO]                     ValDef( // sections: List[(String, String)]
[INFO]                       <param> <triedcooking>
[INFO]                       "sections"
[INFO]                       AppliedTypeTree(
[INFO]                         "List"
[INFO]                         "Field" // type Field = (String, String), tree.tpe=(String, String)
[INFO]                       )
[INFO]                       <empty>
[INFO]                     )
[INFO]                     Apply(
[INFO]                       indexedAttachments.view.flatten.$plus$plus(synopsis).$plus$plus(sections)."map"
[INFO]                       Function( // val $anonfun: <notype>
[INFO]                         ValDef( // x$12: (String, String)
[INFO]                           <param> <synthetic> <triedcooking>
[INFO]                           "x$12"
[INFO]                           <tpt> // tree.tpe=(String, String)
[INFO]                           <empty>
[INFO]                         )
[INFO]                         Match(
[INFO]                           Annotated( // tree.tpe=(String, String) @unchecked
[INFO]                             Apply( // def <init>(): unchecked in class unchecked, tree.tpe=(String, String) @unchecked
[INFO]                               new scala.unchecked."<init>" // def <init>(): unchecked in class unchecked, tree.tpe=()unchecked
[INFO]                               Nil
[INFO]                             )
[INFO]                             "x$12" // x$12: (String, String), tree.tpe=(String, String)
[INFO]                           )
[INFO]                           CaseDef(
[INFO]                             Apply( // object Tuple2 in package scala
[INFO]                               "scala"."Tuple2" // object Tuple2 in package scala, tree.tpe=Tuple2.type
[INFO]                               // 2 arguments
[INFO]                               Bind( // val field: String, tree.tpe=String
[INFO]                                 "field"
[INFO]                                 "_" // tree.tpe=String
[INFO]                               )
[INFO]                               Bind( // val value: String, tree.tpe=String
[INFO]                                 "value"
[INFO]                                 "_" // tree.tpe=String
[INFO]                               )
[INFO]                             )
[INFO]                             Apply(
[INFO]                               "addField"
[INFO]                               // 2 arguments
[INFO]                               "field" // val field: String, tree.tpe=String
[INFO]                               "value" // val value: String, tree.tpe=String
[INFO]                             )
[INFO]                           )
[INFO]                         )
[INFO]                       )
[INFO]                     )
[INFO]                   )
[INFO]                 )
[INFO]               )
[INFO]             )
[INFO]           )
[INFO]         )
[INFO]       )
[INFO]     )
[INFO]   )
[INFO]   DefDef( // private def addKeywordsForContextualBoosting(d: com.idc.webchannel.search.indexer.core.converter.FromResearchDocumentConverter.IndexerDocument): Unit
[INFO]     <method> private <triedcooking>
[INFO]     "addKeywordsForContextualBoosting"
[INFO]     []
[INFO]     // 1 parameter list
[INFO]     ValDef( // d: com.idc.webchannel.search.indexer.core.converter.FromResearchDocumentConverter.IndexerDocument
[INFO]       <param>
[INFO]       "d"
[INFO]       "IndexerDocument"
[INFO]       <empty>
[INFO]     )
[INFO]     "scala"."Unit" // final abstract class Unit extends AnyVal in package scala, tree.tpe=Unit
[INFO]     Block(
[INFO]       // 2 statements
[INFO]       TypeDef(
[INFO]         0
[INFO]         "KeywordsProvider"
[INFO]         []
[INFO]         AppliedTypeTree(
[INFO]           "_root_"."scala"."Function1"
[INFO]           // 2 arguments
[INFO]           "String"
[INFO]           AppliedTypeTree(
[INFO]             "Iterator"
[INFO]             "String"
[INFO]           )
[INFO]         )
[INFO]       )
[INFO]       ValDef(
[INFO]         0
[INFO]         "daoKeywordsProvider"
[INFO]         "KeywordsProvider"
[INFO]         Function(
[INFO]           ValDef(
[INFO]             <param>
[INFO]             "keywordGroup"
[INFO]             <tpt>
[INFO]             <empty>
[INFO]           )
[INFO]           dao.getKeywordsFor(keywordGroup)."iterator"
[INFO]         )
[INFO]       )
[INFO]       Apply(
[INFO]         List[Triple[Boolean, String, KeywordsProvider]](scala.Tuple3(d.title.$bang$eq(null).$amp$amp(d.title.toLowerCase.contains("worldwide")), "NO_WW_IN_TITLE", ((x$13) => referenceBulkData(TaxonomyGeography).asInstanceOf[Iterable[TaxonomyClass]].iterator.filter(((x$14) => x$14.getId.$bang$eq(txMapping.encode(TxNodeName.Geo_US)))).map(((x$15) => x$15.getText)))), scala.Tuple3(d.hasSurveyData, "SURVEY", daoKeywordsProvider), scala.Tuple3(d.hasCompetitiveAnalysis, "MARKET_SHARE", daoKeywordsProvider), scala.Tuple3(d.hasCompetitiveAnalysis, "MARKET_SHARE_COMPANY", ((x$16) => referenceBulkData(Companies).asInstanceOf[Iterable[Company]].iterator.map(((x$17) => x$17.getName)))), scala.Tuple3(d.isBlackBook, "BLACK_BOOK", daoKeywordsProvider), scala.Tuple3(d.forecast.$bang$eq(null), "FORECAST", daoKeywordsProvider)).filter(((x$18) => x$18._1))."foreach"
[INFO]         Match(
[INFO]           <empty>
[INFO]           CaseDef(
[INFO]             Apply(
[INFO]               "scala"."Tuple3"
[INFO]               // 3 arguments
[INFO]               "_"
[INFO]               Bind(
[INFO]                 "keywordGroup"
[INFO]                 "_"
[INFO]               )
[INFO]               Bind(
[INFO]                 "keywords"
[INFO]                 Typed(
[INFO]                   "_"
[INFO]                   "KeywordsProvider"
[INFO]                 )
[INFO]               )
[INFO]             )
[INFO]             Apply(
[INFO]               keywords(keywordGroup)."foreach"
[INFO]               Function(
[INFO]                 ValDef(
[INFO]                   <param>
[INFO]                   "keyword"
[INFO]                   <tpt>
[INFO]                   <empty>
[INFO]                 )
[INFO]                 Apply(
[INFO]                   "addField"
[INFO]                   // 2 arguments
[INFO]                   Apply(
[INFO]                     "rsd_".$plus(keywordGroup.toLowerCase)."$plus"
[INFO]                     "_kwd"
[INFO]                   )
[INFO]                   "keyword"
[INFO]                 )
[INFO]               )
[INFO]             )
[INFO]           )
[INFO]         )
[INFO]       )
[INFO]     )
[INFO]   )
[INFO] )
[INFO] 
[INFO] uncaught exception during compilation: java.lang.NullPointerException
[ERROR] error: java.lang.NullPointerException
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.adapt(Typers.scala:1131)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5467)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedBlock(Typers.scala:2341)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5387)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5458)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.scala$tools$nsc$typechecker$Typers$Typer$$typedStat$1(Typers.scala:2770)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
[INFO] 	at scala.collection.immutable.List.loop$1(List.scala:164)
[INFO] 	at scala.collection.immutable.List.mapConserve(List.scala:180)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:2870)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedTemplate(Typers.scala:1862)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedClassDef(Typers.scala:1726)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5400)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5458)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.scala$tools$nsc$typechecker$Typers$Typer$$typedStat$1(Typers.scala:2770)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
[INFO] 	at scala.collection.immutable.List.loop$1(List.scala:164)
[INFO] 	at scala.collection.immutable.List.mapConserve(List.scala:180)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:2870)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedBlock(Typers.scala:2340)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5387)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5458)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedArg(Typers.scala:2880)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.loop$1(Typers.scala:2907)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.loop$1(Typers.scala:2910)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedArgs(Typers.scala:2913)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.handleMonomorphicCall$1(Typers.scala:3172)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.doTypedApply(Typers.scala:3216)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$86.apply(Typers.scala:4423)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$86.apply(Typers.scala:4423)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.silent(Typers.scala:721)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.tryTypedApply$1(Typers.scala:4423)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.normalTypedApply$1(Typers.scala:4476)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedApply$1(Typers.scala:4509)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5381)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5458)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5526)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.computeType(Typers.scala:5621)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer.assignTypeToTree(Namers.scala:813)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer.methodSig(Namers.scala:1051)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer.getSig$1(Namers.scala:1305)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer.typeSig(Namers.scala:1347)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer$$anonfun$monoTypeCompleter$1$$anonfun$apply$1.apply$mcV$sp(Namers.scala:709)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer$$anonfun$monoTypeCompleter$1$$anonfun$apply$1.apply(Namers.scala:708)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer$$anonfun$monoTypeCompleter$1$$anonfun$apply$1.apply(Namers.scala:708)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer.scala$tools$nsc$typechecker$Namers$Namer$$logAndValidate(Namers.scala:1385)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer$$anonfun$monoTypeCompleter$1.apply(Namers.scala:708)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer$$anonfun$monoTypeCompleter$1.apply(Namers.scala:707)
[INFO] 	at scala.tools.nsc.typechecker.Namers$$anon$1.completeImpl(Namers.scala:1496)
[INFO] 	at scala.tools.nsc.typechecker.Namers$LockingTypeCompleter$class.complete(Namers.scala:1504)
[INFO] 	at scala.tools.nsc.typechecker.Namers$$anon$1.complete(Namers.scala:1494)
[INFO] 	at scala.reflect.internal.Symbols$Symbol.info(Symbols.scala:1217)
[INFO] 	at scala.reflect.internal.Symbols$Symbol.initialize(Symbols.scala:1352)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5119)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5458)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.scala$tools$nsc$typechecker$Typers$Typer$$typedStat$1(Typers.scala:2770)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
[INFO] 	at scala.collection.immutable.List.loop$1(List.scala:164)
[INFO] 	at scala.collection.immutable.List.mapConserve(List.scala:180)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:2870)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedTemplate(Typers.scala:1862)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedModuleDef(Typers.scala:1769)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5401)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5458)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.scala$tools$nsc$typechecker$Typers$Typer$$typedStat$1(Typers.scala:2770)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
[INFO] 	at scala.collection.immutable.List.loop$1(List.scala:164)
[INFO] 	at scala.collection.immutable.List.mapConserve(List.scala:180)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:2870)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedPackageDef$1(Typers.scala:5127)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5404)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5458)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5509)
[INFO] 	at scala.tools.nsc.typechecker.Analyzer$typerFactory$$anon$3.apply(Analyzer.scala:98)
[INFO] 	at scala.tools.nsc.Global$GlobalPhase.applyPhase(Global.scala:461)
[INFO] 	at scala.tools.nsc.typechecker.Analyzer$typerFactory$$anon$3$$anonfun$run$1.apply(Analyzer.scala:90)
[INFO] 	at scala.tools.nsc.typechecker.Analyzer$typerFactory$$anon$3$$anonfun$run$1.apply(Analyzer.scala:90)
[INFO] 	at scala.collection.Iterator$class.foreach(Iterator.scala:727)
[INFO] 	at scala.collection.AbstractIterator.foreach(Iterator.scala:1156)
[INFO] 	at scala.tools.nsc.typechecker.Analyzer$typerFactory$$anon$3.run(Analyzer.scala:90)
[INFO] 	at scala.tools.nsc.Global$Run.compileUnitsInternal(Global.scala:1574)
[INFO] 	at scala.tools.nsc.Global$Run.compileUnits(Global.scala:1548)
[INFO] 	at scala.tools.nsc.Global$Run.compileSources(Global.scala:1544)
[INFO] 	at scala.tools.nsc.Global$Run.compile(Global.scala:1654)
[INFO] 	at scala.tools.nsc.Driver.doCompile(Driver.scala:33)
[INFO] 	at scala.tools.nsc.Main$.doCompile(Main.scala:79)
[INFO] 	at scala.tools.nsc.Driver.process(Driver.scala:54)
[INFO] 	at scala.tools.nsc.Driver.main(Driver.scala:67)
[INFO] 	at scala.tools.nsc.Main.main(Main.scala)
[INFO] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
[INFO] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
[INFO] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
[INFO] 	at java.lang.reflect.Method.invoke(Method.java:601)
[INFO] 	at org_scala_tools_maven_executions.MainHelper.runMain(MainHelper.java:161)
[INFO] 	at org_scala_tools_maven_executions.MainWithArgsInFile.main(MainWithArgsInFile.java:26)
[INFO] 
[INFO] java.lang.reflect.InvocationTargetException
[INFO] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
[INFO] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
[INFO] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
[INFO] 	at java.lang.reflect.Method.invoke(Method.java:601)
[INFO] 	at org_scala_tools_maven_executions.MainHelper.runMain(MainHelper.java:161)
[INFO] 	at org_scala_tools_maven_executions.MainWithArgsInFile.main(MainWithArgsInFile.java:26)
[INFO] Caused by: java.lang.NullPointerException
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.adapt(Typers.scala:1131)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5467)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedBlock(Typers.scala:2341)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5387)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5458)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.scala$tools$nsc$typechecker$Typers$Typer$$typedStat$1(Typers.scala:2770)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
[INFO] 	at scala.collection.immutable.List.loop$1(List.scala:164)
[INFO] 	at scala.collection.immutable.List.mapConserve(List.scala:180)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:2870)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedTemplate(Typers.scala:1862)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedClassDef(Typers.scala:1726)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5400)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5458)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.scala$tools$nsc$typechecker$Typers$Typer$$typedStat$1(Typers.scala:2770)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
[INFO] 	at scala.collection.immutable.List.loop$1(List.scala:164)
[INFO] 	at scala.collection.immutable.List.mapConserve(List.scala:180)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:2870)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedBlock(Typers.scala:2340)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5387)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5458)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedArg(Typers.scala:2880)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.loop$1(Typers.scala:2907)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.loop$1(Typers.scala:2910)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedArgs(Typers.scala:2913)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.handleMonomorphicCall$1(Typers.scala:3172)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.doTypedApply(Typers.scala:3216)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$86.apply(Typers.scala:4423)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$86.apply(Typers.scala:4423)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.silent(Typers.scala:721)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.tryTypedApply$1(Typers.scala:4423)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.normalTypedApply$1(Typers.scala:4476)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedApply$1(Typers.scala:4509)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5381)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5458)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5526)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.computeType(Typers.scala:5621)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer.assignTypeToTree(Namers.scala:813)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer.methodSig(Namers.scala:1051)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer.getSig$1(Namers.scala:1305)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer.typeSig(Namers.scala:1347)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer$$anonfun$monoTypeCompleter$1$$anonfun$apply$1.apply$mcV$sp(Namers.scala:709)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer$$anonfun$monoTypeCompleter$1$$anonfun$apply$1.apply(Namers.scala:708)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer$$anonfun$monoTypeCompleter$1$$anonfun$apply$1.apply(Namers.scala:708)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer.scala$tools$nsc$typechecker$Namers$Namer$$logAndValidate(Namers.scala:1385)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer$$anonfun$monoTypeCompleter$1.apply(Namers.scala:708)
[INFO] 	at scala.tools.nsc.typechecker.Namers$Namer$$anonfun$monoTypeCompleter$1.apply(Namers.scala:707)
[INFO] 	at scala.tools.nsc.typechecker.Namers$$anon$1.completeImpl(Namers.scala:1496)
[INFO] 	at scala.tools.nsc.typechecker.Namers$LockingTypeCompleter$class.complete(Namers.scala:1504)
[INFO] 	at scala.tools.nsc.typechecker.Namers$$anon$1.complete(Namers.scala:1494)
[INFO] 	at scala.reflect.internal.Symbols$Symbol.info(Symbols.scala:1217)
[INFO] 	at scala.reflect.internal.Symbols$Symbol.initialize(Symbols.scala:1352)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5119)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5458)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.scala$tools$nsc$typechecker$Typers$Typer$$typedStat$1(Typers.scala:2770)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
[INFO] 	at scala.collection.immutable.List.loop$1(List.scala:164)
[INFO] 	at scala.collection.immutable.List.mapConserve(List.scala:180)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:2870)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedTemplate(Typers.scala:1862)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedModuleDef(Typers.scala:1769)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5401)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5458)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.scala$tools$nsc$typechecker$Typers$Typer$$typedStat$1(Typers.scala:2770)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
[INFO] 	at scala.collection.immutable.List.loop$1(List.scala:164)
[INFO] 	at scala.collection.immutable.List.mapConserve(List.scala:180)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:2870)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typedPackageDef$1(Typers.scala:5127)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5404)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5458)
[INFO] 	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5509)
[INFO] 	at scala.tools.nsc.typechecker.Analyzer$typerFactory$$anon$3.apply(Analyzer.scala:98)
[INFO] 	at scala.tools.nsc.Global$GlobalPhase.applyPhase(Global.scala:461)
[INFO] 	at scala.tools.nsc.typechecker.Analyzer$typerFactory$$anon$3$$anonfun$run$1.apply(Analyzer.scala:90)
[INFO] 	at scala.tools.nsc.typechecker.Analyzer$typerFactory$$anon$3$$anonfun$run$1.apply(Analyzer.scala:90)
[INFO] 	at scala.collection.Iterator$class.foreach(Iterator.scala:727)
[INFO] 	at scala.collection.AbstractIterator.foreach(Iterator.scala:1156)
[INFO] 	at scala.tools.nsc.typechecker.Analyzer$typerFactory$$anon$3.run(Analyzer.scala:90)
[INFO] 	at scala.tools.nsc.Global$Run.compileUnitsInternal(Global.scala:1574)
[INFO] 	at scala.tools.nsc.Global$Run.compileUnits(Global.scala:1548)
[INFO] 	at scala.tools.nsc.Global$Run.compileSources(Global.scala:1544)
[INFO] 	at scala.tools.nsc.Global$Run.compile(Global.scala:1654)
[INFO] 	at scala.tools.nsc.Driver.doCompile(Driver.scala:33)
[INFO] 	at scala.tools.nsc.Main$.doCompile(Main.scala:79)
[INFO] 	at scala.tools.nsc.Driver.process(Driver.scala:54)
[INFO] 	at scala.tools.nsc.Driver.main(Driver.scala:67)
[INFO] 	at scala.tools.nsc.Main.main(Main.scala)
[INFO] 	... 6 more
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] 
[INFO] IDC Search Indexer - parent ....................... SUCCESS [1.550s]
[INFO] IDC Solr Plugin ................................... SUCCESS [5.287s]
[INFO] IDC Search Indexer - Core ......................... FAILURE [5.479s]
[INFO] IDC Search Indexer - Webapp ....................... SKIPPED
[INFO] IDC Search Indexer ................................ SKIPPED
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 12.537s
[INFO] Finished at: Wed Jan 23 11:40:52 CET 2013
[INFO] Final Memory: 16M/490M
[INFO] ------------------------------------------------------------------------

{noformat}
I came up with the short piece of code which compiles with the same exception.

From the Scala perspective the code itself is wrong, so the expected behaviour of the compiler would be just to complain about the type of value passing to the argument 'b' not matching the type of the argument.

{code}
  def f[T](a: Int, b: Int) = ???

  f(b = 1, a = "foo")
{code}

The attempt to compile this code results in

{noformat}
error:
     while compiling: <console>
        during phase: typer
     library version: version 2.10.0
    compiler version: version 2.10.0
  reconstructed args:

  last tree to typer: Literal(Constant(1))
              symbol: null
   symbol definition: null
                 tpe: Int(1)
       symbol owners:
      context owners: value res0 -> object $iw -> object $iw -> object $read -> package $line9

== Enclosing template or block ==

Template( // val <local $iw>: <notype>
  "java.lang.Object" // parents
  ValDef(
    private
    "_"
    <tpt>
    <empty>
  )
  // 2 statements
  DefDef( // def <init>: <?>
    <method>
    "<init>"
    []
    List(Nil)
    <tpt>
    Block(
      Apply(
        super."<init>"
        Nil
      )
      ()
    )
  )
  ValDef( // private[this] val res0: <?>
    private <local>
    "res0"
    <tpt>
    Apply(
      "f"
      // 2 arguments
      AssignOrNamedArg(
        "b"
        1
      )
      AssignOrNamedArg(
        "a"
        "foo"
      )
    )
  )
)

== Expanded type of tree ==

ConstantType(value = Constant(1))

uncaught exception during compilation: java.lang.NullPointerException
java.lang.NullPointerException
        at scala.tools.selectivecps.CPSUtils$class.hasCpsParamTypes(CPSUtils.scala:71)
        at scala.tools.selectivecps.CPSAnnotationChecker.hasCpsParamTypes(CPSAnnotationChecker.scala:9)
        at scala.tools.selectivecps.CPSAnnotationChecker$checker$$anonfun$addAnnotations$2.apply(CPSAnnotationChecker.scala:399)
        at scala.tools.selectivecps.CPSAnnotationChecker$checker$$anonfun$addAnnotations$2.apply(CPSAnnotationChecker.scala:399)
        at scala.util.control.Exception$Catch.apply(Exception.scala:102)
        at scala.tools.selectivecps.CPSAnnotationChecker$checker$.addAnnotations(CPSAnnotationChecker.scala:399)
        at scala.reflect.internal.AnnotationCheckers$$anonfun$addAnnotations$1.apply(AnnotationCheckers.scala:111)
        at scala.reflect.internal.AnnotationCheckers$$anonfun$addAnnotations$1.apply(AnnotationCheckers.scala:110)
        at scala.collection.LinearSeqOptimized$class.foldLeft(LinearSeqOptimized.scala:110)
        at scala.collection.immutable.List.foldLeft(List.scala:78)
        at scala.reflect.internal.AnnotationCheckers$class.addAnnotations(AnnotationCheckers.scala:110)
        at scala.reflect.internal.SymbolTable.addAnnotations(SymbolTable.scala:12)
        at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5466)
        at scala.tools.nsc.interpreter.ReplGlobal$$anon$1$$anon$2.typed(ReplGlobal.scala:29)
        at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5526)
        at scala.tools.nsc.typechecker.Typers$Typer.computeType(Typers.scala:5621)
        at scala.tools.nsc.typechecker.Namers$Namer.assignTypeToTree(Namers.scala:813)
        at scala.tools.nsc.typechecker.Namers$Namer.getSig$1(Namers.scala:1319)
        at scala.tools.nsc.typechecker.Namers$Namer.typeSig(Namers.scala:1347)
        at scala.tools.nsc.typechecker.Namers$Namer$$anonfun$monoTypeCompleter$1$$anonfun$apply$1.apply$mcV$sp(Namers.scala:709)
        at scala.tools.nsc.typechecker.Namers$Namer$$anonfun$monoTypeCompleter$1$$anonfun$apply$1.apply(Namers.scala:708)
        at scala.tools.nsc.typechecker.Namers$Namer$$anonfun$monoTypeCompleter$1$$anonfun$apply$1.apply(Namers.scala:708)
        at scala.tools.nsc.typechecker.Namers$Namer.scala$tools$nsc$typechecker$Namers$Namer$$logAndValidate(Namers.scala:1385)
        at scala.tools.nsc.typechecker.Namers$Namer$$anonfun$monoTypeCompleter$1.apply(Namers.scala:708)
        at scala.tools.nsc.typechecker.Namers$Namer$$anonfun$monoTypeCompleter$1.apply(Namers.scala:707)
        at scala.tools.nsc.typechecker.Namers$$anon$1.completeImpl(Namers.scala:1496)
        at scala.tools.nsc.typechecker.Namers$LockingTypeCompleter$class.complete(Namers.scala:1504)
        at scala.tools.nsc.typechecker.Namers$$anon$1.complete(Namers.scala:1494)
        at scala.reflect.internal.Symbols$Symbol.info(Symbols.scala:1217)
        at scala.reflect.internal.Symbols$Symbol.initialize(Symbols.scala:1352)
        at scala.tools.nsc.typechecker.MethodSynthesis$MethodSynth$class.addDerivedTrees(MethodSynthesis.scala:224)
        at scala.tools.nsc.typechecker.Namers$Namer.addDerivedTrees(Namers.scala:55)
        at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$29.apply(Typers.scala:1860)
        at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$29.apply(Typers.scala:1860)
        at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$rewrappingWrapperTrees$1.apply(Typers.scala:1798)
        at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$rewrappingWrapperTrees$1.apply(Typers.scala:1795)
        at scala.collection.TraversableLike$$anonfun$flatMap$1.apply(TraversableLike.scala:251)
        at scala.collection.TraversableLike$$anonfun$flatMap$1.apply(TraversableLike.scala:251)
        at scala.collection.immutable.List.foreach(List.scala:309)
        at scala.collection.TraversableLike$class.flatMap(TraversableLike.scala:251)
        at scala.collection.AbstractTraversable.flatMap(Traversable.scala:105)
        at scala.tools.nsc.typechecker.Typers$Typer.typedTemplate(Typers.scala:1860)
        at scala.tools.nsc.typechecker.Typers$Typer.typedModuleDef(Typers.scala:1769)
        at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5401)
        at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5458)
        at scala.tools.nsc.interpreter.ReplGlobal$$anon$1$$anon$2.typed(ReplGlobal.scala:29)
        at scala.tools.nsc.typechecker.Typers$Typer.scala$tools$nsc$typechecker$Typers$Typer$$typedStat$1(Typers.scala:2770)
        at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
        at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
        at scala.collection.immutable.List.loop$1(List.scala:164)
        at scala.collection.immutable.List.mapConserve(List.scala:180)
        at scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:2870)
        at scala.tools.nsc.typechecker.Typers$Typer.typedTemplate(Typers.scala:1862)
        at scala.tools.nsc.typechecker.Typers$Typer.typedModuleDef(Typers.scala:1769)
        at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5401)
        at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5458)
        at scala.tools.nsc.interpreter.ReplGlobal$$anon$1$$anon$2.typed(ReplGlobal.scala:29)
        at scala.tools.nsc.typechecker.Typers$Typer.scala$tools$nsc$typechecker$Typers$Typer$$typedStat$1(Typers.scala:2770)
        at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
        at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
        at scala.collection.immutable.List.loop$1(List.scala:164)
        at scala.collection.immutable.List.mapConserve(List.scala:180)
        at scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:2870)
        at scala.tools.nsc.typechecker.Typers$Typer.typedTemplate(Typers.scala:1862)
        at scala.tools.nsc.typechecker.Typers$Typer.typedModuleDef(Typers.scala:1769)
        at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5401)
        at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5458)
        at scala.tools.nsc.interpreter.ReplGlobal$$anon$1$$anon$2.typed(ReplGlobal.scala:29)
        at scala.tools.nsc.typechecker.Typers$Typer.scala$tools$nsc$typechecker$Typers$Typer$$typedStat$1(Typers.scala:2770)
        at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
        at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$55.apply(Typers.scala:2870)
        at scala.collection.immutable.List.loop$1(List.scala:164)
        at scala.collection.immutable.List.mapConserve(List.scala:180)
        at scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:2870)
        at scala.tools.nsc.typechecker.Typers$Typer.typedPackageDef$1(Typers.scala:5127)
        at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5404)
        at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5458)
        at scala.tools.nsc.interpreter.ReplGlobal$$anon$1$$anon$2.typed(ReplGlobal.scala:29)
        at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5509)
        at scala.tools.nsc.typechecker.Analyzer$typerFactory$$anon$3.apply(Analyzer.scala:98)
        at scala.tools.nsc.Global$GlobalPhase.applyPhase(Global.scala:461)
        at scala.tools.nsc.typechecker.Analyzer$typerFactory$$anon$3$$anonfun$run$1.apply(Analyzer.scala:90)
        at scala.tools.nsc.typechecker.Analyzer$typerFactory$$anon$3$$anonfun$run$1.apply(Analyzer.scala:90)
        at scala.collection.Iterator$class.foreach(Iterator.scala:727)
        at scala.collection.AbstractIterator.foreach(Iterator.scala:1156)
        at scala.tools.nsc.typechecker.Analyzer$typerFactory$$anon$3.run(Analyzer.scala:90)
        at scala.tools.nsc.Global$Run.compileUnitsInternal(Global.scala:1574)
        at scala.tools.nsc.Global$Run.compileUnits(Global.scala:1548)
        at scala.tools.nsc.Global$Run.compileSources(Global.scala:1544)
        at scala.tools.nsc.interpreter.IMain.compileSourcesKeepingRun(IMain.scala:425)
        at scala.tools.nsc.interpreter.IMain$ReadEvalPrint.compileAndSaveRun(IMain.scala:798)
        at scala.tools.nsc.interpreter.IMain$ReadEvalPrint.compile(IMain.scala:758)
        at scala.tools.nsc.interpreter.IMain$Request.compile$lzycompute(IMain.scala:933)
        at scala.tools.nsc.interpreter.IMain$Request.compile(IMain.scala:928)
        at scala.tools.nsc.interpreter.IMain.interpret(IMain.scala:600)
        at scala.tools.nsc.interpreter.IMain.interpret(IMain.scala:565)
        at scala.tools.nsc.interpreter.ILoop.reallyInterpret$1(ILoop.scala:745)
        at scala.tools.nsc.interpreter.ILoop.interpretStartingWith(ILoop.scala:790)
        at scala.tools.nsc.interpreter.ILoop.command(ILoop.scala:702)
        at scala.tools.nsc.interpreter.ILoop.processLine$1(ILoop.scala:566)
        at scala.tools.nsc.interpreter.ILoop.innerLoop$1(ILoop.scala:573)
        at scala.tools.nsc.interpreter.ILoop.loop(ILoop.scala:576)
        at scala.tools.nsc.interpreter.ILoop$$anonfun$process$1.apply$mcZ$sp(ILoop.scala:867)
        at scala.tools.nsc.interpreter.ILoop$$anonfun$process$1.apply(ILoop.scala:822)
        at scala.tools.nsc.interpreter.ILoop$$anonfun$process$1.apply(ILoop.scala:822)
        at scala.tools.nsc.util.ScalaClassLoader$.savingContextLoader(ScalaClassLoader.scala:135)
        at scala.tools.nsc.interpreter.ILoop.process(ILoop.scala:822)
        at scala.tools.nsc.MainGenericRunner.runTarget$1(MainGenericRunner.scala:83)
        at scala.tools.nsc.MainGenericRunner.process(MainGenericRunner.scala:96)
        at scala.tools.nsc.MainGenericRunner$.main(MainGenericRunner.scala:105)
        at scala.tools.nsc.MainGenericRunner.main(MainGenericRunner.scala)

{noformat}
Duplicate of SI-6829, fixed coming soon in 2.10.1.
