The problem that causes (("abc".reverse.reverse) == "abc") == false) is not directly related.

The main issue is letting the type of the variable to be inferred as Object or AnyVal rather than making the programmer specify the type.

Combined with implicit conversions this could lead to all sorts of confusion (the firs example with "123" string).
Here is another example, this time with overloading.

{code}
object Overloaded {
    def f(a: AnyVal) = println("anyval")
    def f(a: Number) = println("number")
    def f(a: Float) = println("float")
}

val condition = true
val test = if (condition) 123 else 123f
Overloaded.f(test)
{code}

The problem here is that the behaviour is not obvious nor intuitive... and most likely not what the developer intended to do. Basically I am trying to argue that the type inference should only work when all the if-branches return the same type. Otherwise the compiler should generate and error and let the programmer specify the type.

Specifying the type would result in either:
- Forcing an implicit conversion and make the program work as intended
- Discovering a type error at compile time rather than having unexpected results at runtime

Another thing worth noting is that most of the time upcasting to Object or AnyVal works. So when it does not work, it is the last place a developer would look at, because it is expected to work. This makes a potent source of hard to find bugs.
