Okay, here's a diagnosis:

1. In the constructors phase, the construction code for check is duplicated to have two versions: one for the generic class (protected by the specinstance check) and one for the specialized class:
{code}
[[syntax trees at end of              constructors]] // t9531.scala
package <empty> {
  class Val extends Object {
    protected[this] var check: Object = _;
    <accessor> def check(): Object = Val.this.check;
    <accessor> def check_=(x$1: Object): Unit = Val.this.check = x$1;
    <accessor> <specialized> def check$mcI$sp(): Int = scala.Int.unbox(Val.this.check());
    <accessor> <specialized> def check$mcI$sp_=(x$1: Int): Unit = Val.this.check_=(scala.Int.box(x$1));
    def specInstance$(): Boolean = false;
    def <init>(): Val = {
      Val.super.<init>();
      if (Val.this.specInstance$().unary_!())
        {
          Val.this.check_=({
            val actual: String = "xyz";
            scala.this.Predef.assert(actual.==("abc"));
            scala.this.Predef.???()
          });
          ()
        };
      ()
    }
  };
  <specialized> class Val$mcI$sp extends Val {
    <specialized> protected[this] var check$mcI$sp: Int = _;
    <accessor> <specialized> def check$mcI$sp(): Int = Val$mcI$sp.this.check$mcI$sp;
    override <accessor> <specialized> def check(): Int = Val$mcI$sp.this.check$mcI$sp();
    <accessor> <specialized> def check$mcI$sp_=(x$1: Int): Unit = Val$mcI$sp.this.check$mcI$sp = x$1;
    override <accessor> <specialized> def check_=(x$1: Int): Unit = Val$mcI$sp.this.check$mcI$sp_=(x$1);
    def specInstance$(): Boolean = true;
    override <bridge> <specialized> <artifact> def check_=(x$1: Object): Unit = Val$mcI$sp.this.check_=(scala.Int.unbox(x$1));
    override <bridge> <specialized> <artifact> def check(): Object = scala.Int.box(Val$mcI$sp.this.check());
    <specialized> def <init>(): Val$mcI$sp = {
      Val$mcI$sp.super.<init>();
      Val$mcI$sp.this.check_=({
        private[this] val actual: String = "xyz";
        scala.this.Predef.assert(Val$mcI$sp.this.actual.==("abc"));
        scala.this.Predef.???()
      });
      ()
    }
  }
}
{code}

2. When duplicating the code inside the constructor, duplicators.retyped clears the symbols for all definitions in the block and re-type-checks the block. Specifically, it clears the symbol for:
```
val actual: String = "xyz";
```

3. Now, retypechecking should create a symbol for "actual", but since it's missing the context that this is inside a local scope, it actually creates two symbols:
  * private[this] actual of type String
  * getter, which is assigned a NullaryMethodType(String)

4. Later on, it rewires the reference to actual in assert(actual == "abc") to the getter:
{code}
     Val$mcI$sp#22027.this.check_=#8400({
        private[this] val actual#29539: String#232 = "xyz";
        scala#21.this.Predef#885.assert#7894(Val$mcI$sp#22027.this.actual#29538.==#5938("abc"));
        scala#21.this.Predef#885.???#7909()
      });
{code}
Note the two "actual"-s:  private[this] val actual#29539 and Val$mcI$sp#22027.this.actual#29538, specifically 29539 vs 29538.

5. Finally, since this happens in constructors, the NullaryMethodType is never seen by uncurry, so it never gets eliminated, crashing the backend.

Now, the easiest way to handle this would be to signal to the typer that we're inside a method, so it should treat values as local. Can we do this?

My comment: using a phase as late as constructors to duplicate (untype + retype) code is a bad idea (TM). Miniboxing was able to duplicate constructor code before erasure reliably, so it definitely can be done.
