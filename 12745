The "scalac sudoku.scala" command where sudoku.scala is the source from http://scala.sygneca.com/code/sudoku fails with scala-2.6.0-RC2 giving the following error message:


{code}
exception when transforming body%2(x$$0,temp5$$0){
  if (SudokuSolver.this.m().apply(temp5$$0).apply(x$$0).!=('0'))
    _search(x$$0.+(1), temp5$$0, f$$0, accu)
  else
    SudokuSolver.this.fold({
      @serializable final <synthetic> class $$anonfun$$2 extends java.lang.Object with Function2 with ScalaObject {
        def this(): template $$anonfun$$2 = {
          $$anonfun$$2.super.this();
          $$anonfun$$2.this.$$asInstanceOf[Function2$$class]()./*Function2$$class*/$$init$$();
          ()
        };
        final def apply(accu: Int, n: Int): Int = if (SudokuSolver.this.invalid(0, x$$0, temp5$$0, n.+(48).toChar()))
          accu
        else
          {
            SudokuSolver.this.m().apply(temp5$$0).update(x$$0, n.+(48).toChar());
            val newaccu: Int = SudokuSolver.this.search(x$$0.+(1), temp5$$0, f$$0, accu);
            SudokuSolver.this.m().apply(temp5$$0).update(x$$0, '0');
            newaccu
          };
        final <bridge> def apply(x$$1: java.lang.Object, x$$2: java.lang.Object): java.lang.Object = scala.Int.box($$anonfun$$2.this.apply(scala.Int.unbox(x$$1), scala.Int.unbox(x$$2)))
      };
      (new template $$anonfun$$2(): Function2)
    }, accu, 1, 10)
}
exception when transforming {
  <synthetic> var temp5$$0: scala.runtime.IntRef = temp5$$0;
  val x$$0: Int = temp4;
  body%2(x$$0,temp5$$0){
    if (SudokuSolver.this.m().apply(temp5$$0).apply(x$$0).!=('0'))
      _search(x$$0.+(1), temp5$$0, f$$0, accu)
    else
      SudokuSolver.this.fold({
        @serializable final <synthetic> class $$anonfun$$2 extends java.lang.Object with Function2 with ScalaObject {
          def this(): template $$anonfun$$2 = {
            $$anonfun$$2.super.this();
            $$anonfun$$2.this.$$asInstanceOf[Function2$$class]()./*Function2$$class*/$$init$$();
            ()
          };
          final def apply(accu: Int, n: Int): Int = if (SudokuSolver.this.invalid(0, x$$0, temp5$$0, n.+(48).toChar()))
            accu
          else
            {
              SudokuSolver.this.m().apply(temp5$$0).update(x$$0, n.+(48).toChar());
              val newaccu: Int = SudokuSolver.this.search(x$$0.+(1), temp5$$0, f$$0, accu);
              SudokuSolver.this.m().apply(temp5$$0).update(x$$0, '0');
              newaccu
            };
          final <bridge> def apply(x$$1: java.lang.Object, x$$2: java.lang.Object): java.lang.Object = scala.Int.box($$anonfun$$2.this.apply(scala.Int.unbox(x$$1), scala.Int.unbox(x$$2)))
        };
        (new template $$anonfun$$2(): Function2)
      }, accu, 1, 10)
  }
}
exception when transforming if (temp5$$0.==(9))
  body%1(){
    scala.Int.unbox(f$$0.apply(scala.Int.box(accu)))
  }
else
  {
    <synthetic> var temp5$$0: scala.runtime.IntRef = temp5$$0;
    val x$$0: Int = temp4;
    body%2(x$$0,temp5$$0){
      if (SudokuSolver.this.m().apply(temp5$$0).apply(x$$0).!=('0'))
        _search(x$$0.+(1), temp5$$0, f$$0, accu)
      else
        SudokuSolver.this.fold({
          @serializable final <synthetic> class $$anonfun$$2 extends java.lang.Object with Function2 with ScalaObject {
            def this(): template $$anonfun$$2 = {
              $$anonfun$$2.super.this();
              $$anonfun$$2.this.$$asInstanceOf[Function2$$class]()./*Function2$$class*/$$init$$();
              ()
            };
            final def apply(accu: Int, n: Int): Int = if (SudokuSolver.this.invalid(0, x$$0, temp5$$0, n.+(48).toChar()))
              accu
            else
              {
                SudokuSolver.this.m().apply(temp5$$0).update(x$$0, n.+(48).toChar());
                val newaccu: Int = SudokuSolver.this.search(x$$0.+(1), temp5$$0, f$$0, accu);
                SudokuSolver.this.m().apply(temp5$$0).update(x$$0, '0');
                newaccu
              };
            final <bridge> def apply(x$$1: java.lang.Object, x$$2: java.lang.Object): java.lang.Object = scala.Int.box($$anonfun$$2.this.apply(scala.Int.unbox(x$$1), scala.Int.unbox(x$$2)))
          };
          (new template $$anonfun$$2(): Function2)
        }, accu, 1, 10)
    }
  }
exception when transforming case 0 => if (temp5$$0.==(9))
  body%1(){
    scala.Int.unbox(f$$0.apply(scala.Int.box(accu)))
  }
else
  {
    <synthetic> var temp5$$0: scala.runtime.IntRef = temp5$$0;
    val x$$0: Int = temp4;
    body%2(x$$0,temp5$$0){
      if (SudokuSolver.this.m().apply(temp5$$0).apply(x$$0).!=('0'))
        _search(x$$0.+(1), temp5$$0, f$$0, accu)
      else
        SudokuSolver.this.fold({
          @serializable final <synthetic> class $$anonfun$$2 extends java.lang.Object with Function2 with ScalaObject {
            def this(): template $$anonfun$$2 = {
              $$anonfun$$2.super.this();
              $$anonfun$$2.this.$$asInstanceOf[Function2$$class]()./*Function2$$class*/$$init$$();
              ()
            };
            final def apply(accu: Int, n: Int): Int = if (SudokuSolver.this.invalid(0, x$$0, temp5$$0, n.+(48).toChar()))
              accu
            else
              {
                SudokuSolver.this.m().apply(temp5$$0).update(x$$0, n.+(48).toChar());
                val newaccu: Int = SudokuSolver.this.search(x$$0.+(1), temp5$$0, f$$0, accu);
                SudokuSolver.this.m().apply(temp5$$0).update(x$$0, '0');
                newaccu
              };
            final <bridge> def apply(x$$1: java.lang.Object, x$$2: java.lang.Object): java.lang.Object = scala.Int.box($$anonfun$$2.this.apply(scala.Int.unbox(x$$1), scala.Int.unbox(x$$2)))
          };
          (new template $$anonfun$$2(): Function2)
        }, accu, 1, 10)
    }
  }
exception when transforming (temp4: Int) match {
  case 9 => _search(0, temp5$$0.+(1), f$$0, accu)
  case 0 => if (temp5$$0.==(9))
    body%1(){
      scala.Int.unbox(f$$0.apply(scala.Int.box(accu)))
    }
  else
    {
      <synthetic> var temp5$$0: scala.runtime.IntRef = temp5$$0;
      val x$$0: Int = temp4;
      body%2(x$$0,temp5$$0){
        if (SudokuSolver.this.m().apply(temp5$$0).apply(x$$0).!=('0'))
          _search(x$$0.+(1), temp5$$0, f$$0, accu)
        else
          SudokuSolver.this.fold({
            @serializable final <synthetic> class $$anonfun$$2 extends java.lang.Object with Function2 with ScalaObject {
              def this(): template $$anonfun$$2 = {
                $$anonfun$$2.super.this();
                $$anonfun$$2.this.$$asInstanceOf[Function2$$class]()./*Function2$$class*/$$init$$();
                ()
              };
              final def apply(accu: Int, n: Int): Int = if (SudokuSolver.this.invalid(0, x$$0, temp5$$0, n.+(48).toChar()))
                accu
              else
                {
                  SudokuSolver.this.m().apply(temp5$$0).update(x$$0, n.+(48).toChar());
                  val newaccu: Int = SudokuSolver.this.search(x$$0.+(1), temp5$$0, f$$0, accu);
                  SudokuSolver.this.m().apply(temp5$$0).update(x$$0, '0');
                  newaccu
                };
              final <bridge> def apply(x$$1: java.lang.Object, x$$2: java.lang.Object): java.lang.Object = scala.Int.box($$anonfun$$2.this.apply(scala.Int.unbox(x$$1), scala.Int.unbox(x$$2)))
            };
            (new template $$anonfun$$2(): Function2)
          }, accu, 1, 10)
      }
    }
  case _ => body%2(temp4, temp5$$0)
}
exception when transforming {
  <synthetic> var temp3: Tuple2 = temp2.get().$$asInstanceOf[Tuple2]();
  <synthetic> var temp4: Int = scala.Int.unbox(temp3._1());
  <synthetic> var temp5$$0: scala.runtime.IntRef = scala.Int.unbox(temp3._2());
  (temp4: Int) match {
    case 9 => _search(0, temp5$$0.+(1), f$$0, accu)
    case 0 => if (temp5$$0.==(9))
      body%1(){
        scala.Int.unbox(f$$0.apply(scala.Int.box(accu)))
      }
    else
      {
        <synthetic> var temp5$$0: scala.runtime.IntRef = temp5$$0;
        val x$$0: Int = temp4;
        body%2(x$$0,temp5$$0){
          if (SudokuSolver.this.m().apply(temp5$$0).apply(x$$0).!=('0'))
            _search(x$$0.+(1), temp5$$0, f$$0, accu)
          else
            SudokuSolver.this.fold({
              @serializable final <synthetic> class $$anonfun$$2 extends java.lang.Object with Function2 with ScalaObject {
                def this(): template $$anonfun$$2 = {
                  $$anonfun$$2.super.this();
                  $$anonfun$$2.this.$$asInstanceOf[Function2$$class]()./*Function2$$class*/$$init$$();
                  ()
                };
                final def apply(accu: Int, n: Int): Int = if (SudokuSolver.this.invalid(0, x$$0, temp5$$0, n.+(48).toChar()))
                  accu
                else
                  {
                    SudokuSolver.this.m().apply(temp5$$0).update(x$$0, n.+(48).toChar());
                    val newaccu: Int = SudokuSolver.this.search(x$$0.+(1), temp5$$0, f$$0, accu);
                    SudokuSolver.this.m().apply(temp5$$0).update(x$$0, '0');
                    newaccu
                  };
                final <bridge> def apply(x$$1: java.lang.Object, x$$2: java.lang.Object): java.lang.Object = scala.Int.box($$anonfun$$2.this.apply(scala.Int.unbox(x$$1), scala.Int.unbox(x$$2)))
              };
              (new template $$anonfun$$2(): Function2)
            }, accu, 1, 10)
        }
      }
    case _ => body%2(temp4, temp5$$0)
  }
}
exception when transforming if (temp2.isEmpty().unary_!())
  {
    <synthetic> var temp3: Tuple2 = temp2.get().$$asInstanceOf[Tuple2]();
    <synthetic> var temp4: Int = scala.Int.unbox(temp3._1());
    <synthetic> var temp5$$0: scala.runtime.IntRef = scala.Int.unbox(temp3._2());
    (temp4: Int) match {
      case 9 => _search(0, temp5$$0.+(1), f$$0, accu)
      case 0 => if (temp5$$0.==(9))
        body%1(){
          scala.Int.unbox(f$$0.apply(scala.Int.box(accu)))
        }
      else
        {
          <synthetic> var temp5$$0: scala.runtime.IntRef = temp5$$0;
          val x$$0: Int = temp4;
          body%2(x$$0,temp5$$0){
            if (SudokuSolver.this.m().apply(temp5$$0).apply(x$$0).!=('0'))
              _search(x$$0.+(1), temp5$$0, f$$0, accu)
            else
              SudokuSolver.this.fold({
                @serializable final <synthetic> class $$anonfun$$2 extends java.lang.Object with Function2 with ScalaObject {
                  def this(): template $$anonfun$$2 = {
                    $$anonfun$$2.super.this();
                    $$anonfun$$2.this.$$asInstanceOf[Function2$$class]()./*Function2$$class*/$$init$$();
                    ()
                  };
                  final def apply(accu: Int, n: Int): Int = if (SudokuSolver.this.invalid(0, x$$0, temp5$$0, n.+(48).toChar()))
                    accu
                  else
                    {
                      SudokuSolver.this.m().apply(temp5$$0).update(x$$0, n.+(48).toChar());
                      val newaccu: Int = SudokuSolver.this.search(x$$0.+(1), temp5$$0, f$$0, accu);
                      SudokuSolver.this.m().apply(temp5$$0).update(x$$0, '0');
                      newaccu
                    };
                  final <bridge> def apply(x$$1: java.lang.Object, x$$2: java.lang.Object): java.lang.Object = scala.Int.box($$anonfun$$2.this.apply(scala.Int.unbox(x$$1), scala.Int.unbox(x$$2)))
                };
                (new template $$anonfun$$2(): Function2)
              }, accu, 1, 10)
          }
        }
      case _ => body%2(temp4, temp5$$0)
    }
  }
else
  throw new MatchError(temp1)
exception when transforming {
  <synthetic> var temp1: Tuple2 = scala.this.Predef.Pair.apply(scala.Int.box(x), scala.Int.box(y));
  <synthetic> var temp2: Option = scala.this.Predef.Pair.unapply(temp1);
  if (temp2.isEmpty().unary_!())
    {
      <synthetic> var temp3: Tuple2 = temp2.get().$$asInstanceOf[Tuple2]();
      <synthetic> var temp4: Int = scala.Int.unbox(temp3._1());
      <synthetic> var temp5$$0: scala.runtime.IntRef = scala.Int.unbox(temp3._2());
      (temp4: Int) match {
        case 9 => _search(0, temp5$$0.+(1), f$$0, accu)
        case 0 => if (temp5$$0.==(9))
          body%1(){
            scala.Int.unbox(f$$0.apply(scala.Int.box(accu)))
          }
        else
          {
            <synthetic> var temp5$$0: scala.runtime.IntRef = temp5$$0;
            val x$$0: Int = temp4;
            body%2(x$$0,temp5$$0){
              if (SudokuSolver.this.m().apply(temp5$$0).apply(x$$0).!=('0'))
                _search(x$$0.+(1), temp5$$0, f$$0, accu)
              else
                SudokuSolver.this.fold({
                  @serializable final <synthetic> class $$anonfun$$2 extends java.lang.Object with Function2 with ScalaObject {
                    def this(): template $$anonfun$$2 = {
                      $$anonfun$$2.super.this();
                      $$anonfun$$2.this.$$asInstanceOf[Function2$$class]()./*Function2$$class*/$$init$$();
                      ()
                    };
                    final def apply(accu: Int, n: Int): Int = if (SudokuSolver.this.invalid(0, x$$0, temp5$$0, n.+(48).toChar()))
                      accu
                    else
                      {
                        SudokuSolver.this.m().apply(temp5$$0).update(x$$0, n.+(48).toChar());
                        val newaccu: Int = SudokuSolver.this.search(x$$0.+(1), temp5$$0, f$$0, accu);
                        SudokuSolver.this.m().apply(temp5$$0).update(x$$0, '0');
                        newaccu
                      };
                    final <bridge> def apply(x$$1: java.lang.Object, x$$2: java.lang.Object): java.lang.Object = scala.Int.box($$anonfun$$2.this.apply(scala.Int.unbox(x$$1), scala.Int.unbox(x$$2)))
                  };
                  (new template $$anonfun$$2(): Function2)
                }, accu, 1, 10)
            }
          }
        case _ => body%2(temp4, temp5$$0)
      }
    }
  else
    throw new MatchError(temp1)
}
exception when transforming _search(x,y,f$$0,accu){
  <synthetic> var temp1: Tuple2 = scala.this.Predef.Pair.apply(scala.Int.box(x), scala.Int.box(y));
  <synthetic> var temp2: Option = scala.this.Predef.Pair.unapply(temp1);
  if (temp2.isEmpty().unary_!())
    {
      <synthetic> var temp3: Tuple2 = temp2.get().$$asInstanceOf[Tuple2]();
      <synthetic> var temp4: Int = scala.Int.unbox(temp3._1());
      <synthetic> var temp5$$0: scala.runtime.IntRef = scala.Int.unbox(temp3._2());
      (temp4: Int) match {
        case 9 => _search(0, temp5$$0.+(1), f$$0, accu)
        case 0 => if (temp5$$0.==(9))
          body%1(){
            scala.Int.unbox(f$$0.apply(scala.Int.box(accu)))
          }
        else
          {
            <synthetic> var temp5$$0: scala.runtime.IntRef = temp5$$0;
            val x$$0: Int = temp4;
            body%2(x$$0,temp5$$0){
              if (SudokuSolver.this.m().apply(temp5$$0).apply(x$$0).!=('0'))
                _search(x$$0.+(1), temp5$$0, f$$0, accu)
              else
                SudokuSolver.this.fold({
                  @serializable final <synthetic> class $$anonfun$$2 extends java.lang.Object with Function2 with ScalaObject {
                    def this(): template $$anonfun$$2 = {
                      $$anonfun$$2.super.this();
                      $$anonfun$$2.this.$$asInstanceOf[Function2$$class]()./*Function2$$class*/$$init$$();
                      ()
                    };
                    final def apply(accu: Int, n: Int): Int = if (SudokuSolver.this.invalid(0, x$$0, temp5$$0, n.+(48).toChar()))
                      accu
                    else
                      {
                        SudokuSolver.this.m().apply(temp5$$0).update(x$$0, n.+(48).toChar());
                        val newaccu: Int = SudokuSolver.this.search(x$$0.+(1), temp5$$0, f$$0, accu);
                        SudokuSolver.this.m().apply(temp5$$0).update(x$$0, '0');
                        newaccu
                      };
                    final <bridge> def apply(x$$1: java.lang.Object, x$$2: java.lang.Object): java.lang.Object = scala.Int.box($$anonfun$$2.this.apply(scala.Int.unbox(x$$1), scala.Int.unbox(x$$2)))
                  };
                  (new template $$anonfun$$2(): Function2)
                }, accu, 1, 10)
            }
          }
        case _ => body%2(temp4, temp5$$0)
      }
    }
  else
    throw new MatchError(temp1)
}
exception when transforming def search(x: Int, y: Int, f$$0: Function1, accu: Int): Int = _search(x,y,f$$0,accu){
  <synthetic> var temp1: Tuple2 = scala.this.Predef.Pair.apply(scala.Int.box(x), scala.Int.box(y));
  <synthetic> var temp2: Option = scala.this.Predef.Pair.unapply(temp1);
  if (temp2.isEmpty().unary_!())
    {
      <synthetic> var temp3: Tuple2 = temp2.get().$$asInstanceOf[Tuple2]();
      <synthetic> var temp4: Int = scala.Int.unbox(temp3._1());
      <synthetic> var temp5$$0: scala.runtime.IntRef = scala.Int.unbox(temp3._2());
      (temp4: Int) match {
        case 9 => _search(0, temp5$$0.+(1), f$$0, accu)
        case 0 => if (temp5$$0.==(9))
          body%1(){
            scala.Int.unbox(f$$0.apply(scala.Int.box(accu)))
          }
        else
          {
            <synthetic> var temp5$$0: scala.runtime.IntRef = temp5$$0;
            val x$$0: Int = temp4;
            body%2(x$$0,temp5$$0){
              if (SudokuSolver.this.m().apply(temp5$$0).apply(x$$0).!=('0'))
                _search(x$$0.+(1), temp5$$0, f$$0, accu)
              else
                SudokuSolver.this.fold({
                  @serializable final <synthetic> class $$anonfun$$2 extends java.lang.Object with Function2 with ScalaObject {
                    def this(): template $$anonfun$$2 = {
                      $$anonfun$$2.super.this();
                      $$anonfun$$2.this.$$asInstanceOf[Function2$$class]()./*Function2$$class*/$$init$$();
                      ()
                    };
                    final def apply(accu: Int, n: Int): Int = if (SudokuSolver.this.invalid(0, x$$0, temp5$$0, n.+(48).toChar()))
                      accu
                    else
                      {
                        SudokuSolver.this.m().apply(temp5$$0).update(x$$0, n.+(48).toChar());
                        val newaccu: Int = SudokuSolver.this.search(x$$0.+(1), temp5$$0, f$$0, accu);
                        SudokuSolver.this.m().apply(temp5$$0).update(x$$0, '0');
                        newaccu
                      };
                    final <bridge> def apply(x$$1: java.lang.Object, x$$2: java.lang.Object): java.lang.Object = scala.Int.box($$anonfun$$2.this.apply(scala.Int.unbox(x$$1), scala.Int.unbox(x$$2)))
                  };
                  (new template $$anonfun$$2(): Function2)
                }, accu, 1, 10)
            }
          }
        case _ => body%2(temp4, temp5$$0)
      }
    }
  else
    throw new MatchError(temp1)
}
exception when transforming java.lang.Object with Application with ScalaObject {
  def this(): object SudokuSolver = {
    SudokuSolver.super.this();
    SudokuSolver.this.$$asInstanceOf[Application$$class]()./*Application$$class*/$$init$$();
    ()
  };
  private[this] var m: Array[Array[Char]] = {
    <synthetic> val $$2$$: java.lang.Object = scala.runtime.ScalaRunTime.arrayValue(scala.List.tabulate(9, {
      @serializable final <synthetic> class $$anonfun$$0 extends java.lang.Object with Function1 with ScalaObject {
        def this(): template $$anonfun$$0 = {
          $$anonfun$$0.super.this();
          $$anonfun$$0.this.$$asInstanceOf[Function1$$class]()./*Function1$$class*/$$init$$();
          ()
        };
        final def apply(x: Int): Array[Char] = {
          <synthetic> val $$1$$: java.lang.Object = scala.runtime.ScalaRunTime.arrayValue({
            scala.this.Predef.stringWrapper(scala.Console.readLine())
          }.toArray(), classOf[scala.Char]);
          if ($$1$$.$$isInstanceOf[scala.runtime.BoxedArray]())
            scala.runtime.ScalaRunTime.arrayValue($$1$$.$$asInstanceOf[scala.runtime.BoxedArray](), classOf[scala.Char])
          else
            $$1$$.$$asInstanceOf[Array[Char]]()
        };
        final <bridge> def apply(x$$1: java.lang.Object): java.lang.Object = $$anonfun$$0.this.apply(scala.Int.unbox(x$$1))
      };
      (new template $$anonfun$$0(): Function1)
    }).toArray(), classOf[[C]);
    if ($$2$$.$$isInstanceOf[scala.runtime.BoxedArray]())
      scala.runtime.ScalaRunTime.arrayValue($$2$$.$$asInstanceOf[scala.runtime.BoxedArray](), classOf[[C])
    else
      $$2$$.$$asInstanceOf[Array[Array[Char]]]()
  };
  <accessor> def m(): Array[Array[Char]] = SudokuSolver.this.m;
  <accessor> def m_=(x$$1: Array[Array[Char]]): Unit = SudokuSolver.this.m = x$$1;
  def print(): Array[scala.runtime.BoxedUnit] = {
    scala.Console.println("");
    {
      <synthetic> val $$3$$: java.lang.Object = scala.runtime.ScalaRunTime.arrayValue(new scala.runtime.BoxedObjectArray(SudokuSolver.this.m().$$asInstanceOf[Array[java.lang.Object]]()).map({
        @serializable final <synthetic> class $$anonfun$$1 extends java.lang.Object with Function1 with ScalaObject {
          def this(): template $$anonfun$$1 = {
            $$anonfun$$1.super.this();
            $$anonfun$$1.this.$$asInstanceOf[Function1$$class]()./*Function1$$class*/$$init$$();
            ()
          };
          final def apply(carr: Array[Char]): Unit = scala.Console.println(new java.lang.String(carr));
          final <bridge> def apply(x$$1: java.lang.Object): java.lang.Object = {
            $$anonfun$$1.this.apply(if (x$$1.$$isInstanceOf[scala.runtime.BoxedArray]())
              scala.runtime.ScalaRunTime.arrayValue(x$$1.$$asInstanceOf[scala.runtime.BoxedArray](), classOf[scala.Char])
            else
              x$$1.$$asInstanceOf[Array[Char]]());
            scala.runtime.BoxedUnit.UNIT
          }
        };
        (new template $$anonfun$$1(): Function1)
      }), classOf[scala.runtime.BoxedUnit]);
      if ($$3$$.$$isInstanceOf[scala.runtime.BoxedArray]())
        scala.runtime.ScalaRunTime.arrayValue($$3$$.$$asInstanceOf[scala.runtime.BoxedArray](), classOf[scala.runtime.BoxedUnit])
      else
        $$3$$.$$asInstanceOf[Array[scala.runtime.BoxedUnit]]()
    }
  };
  def invalid(i: Int, x: Int, y: Int, n: Char): Boolean = _invalid(i,x,y,n){
    i.<(9).&&(SudokuSolver.this.m().apply(y).apply(i).==(n).||(SudokuSolver.this.m().apply(i).apply(x).==(n)).||(SudokuSolver.this.m().apply(y./(3).*(3).+(i./(3))).apply(x./(3).*(3).+(i.%(3))).==(n)).||(_invalid(i.+(1), x, y, n)))
  };
  def fold(f: Function2, accu: Int, l: Int, u: Int): Int = _fold(f,accu,l,u){
    if (l.==(u))
      accu
    else
      _fold(f, scala.Int.unbox(f.apply(scala.Int.box(accu), scala.Int.box(l))), l.+(1), u)
  };
  def search(x: Int, y: Int, f$$0: Function1, accu: Int): Int = _search(x,y,f$$0,accu){
    <synthetic> var temp1: Tuple2 = scala.this.Predef.Pair.apply(scala.Int.box(x), scala.Int.box(y));
    <synthetic> var temp2: Option = scala.this.Predef.Pair.unapply(temp1);
    if (temp2.isEmpty().unary_!())
      {
        <synthetic> var temp3: Tuple2 = temp2.get().$$asInstanceOf[Tuple2]();
        <synthetic> var temp4: Int = scala.Int.unbox(temp3._1());
        <synthetic> var temp5$$0: scala.runtime.IntRef = scala.Int.unbox(temp3._2());
        (temp4: Int) match {
          case 9 => _search(0, temp5$$0.+(1), f$$0, accu)
          case 0 => if (temp5$$0.==(9))
            body%1(){
              scala.Int.unbox(f$$0.apply(scala.Int.box(accu)))
            }
          else
            {
              <synthetic> var temp5$$0: scala.runtime.IntRef = temp5$$0;
              val x$$0: Int = temp4;
              body%2(x$$0,temp5$$0){
                if (SudokuSolver.this.m().apply(temp5$$0).apply(x$$0).!=('0'))
                  _search(x$$0.+(1), temp5$$0, f$$0, accu)
                else
                  SudokuSolver.this.fold({
                    @serializable final <synthetic> class $$anonfun$$2 extends java.lang.Object with Function2 with ScalaObject {
                      def this(): template $$anonfun$$2 = {
                        $$anonfun$$2.super.this();
                        $$anonfun$$2.this.$$asInstanceOf[Function2$$class]()./*Function2$$class*/$$init$$();
                        ()
                      };
                      final def apply(accu: Int, n: Int): Int = if (SudokuSolver.this.invalid(0, x$$0, temp5$$0, n.+(48).toChar()))
                        accu
                      else
                        {
                          SudokuSolver.this.m().apply(temp5$$0).update(x$$0, n.+(48).toChar());
                          val newaccu: Int = SudokuSolver.this.search(x$$0.+(1), temp5$$0, f$$0, accu);
                          SudokuSolver.this.m().apply(temp5$$0).update(x$$0, '0');
                          newaccu
                        };
                      final <bridge> def apply(x$$1: java.lang.Object, x$$2: java.lang.Object): java.lang.Object = scala.Int.box($$anonfun$$2.this.apply(scala.Int.unbox(x$$1), scala.Int.unbox(x$$2)))
                    };
                    (new template $$anonfun$$2(): Function2)
                  }, accu, 1, 10)
              }
            }
          case _ => body%2(temp4, temp5$$0)
        }
      }
    else
      throw new MatchError(temp1)
  };
  scala.Console.println("\012".+(scala.Int.box(SudokuSolver.this.search(0, 0, {
    @serializable final <synthetic> class $$anonfun$$3 extends java.lang.Object with Function1 with ScalaObject {
      def this(): template $$anonfun$$3 = {
        $$anonfun$$3.super.this();
        $$anonfun$$3.this.$$asInstanceOf[Function1$$class]()./*Function1$$class*/$$init$$();
        ()
      };
      final def apply(i: Int): Int = {
        SudokuSolver.this.print();
        i.+(1)
      };
      final <bridge> def apply(x$$1: java.lang.Object): java.lang.Object = scala.Int.box($$anonfun$$3.this.apply(scala.Int.unbox(x$$1)))
    };
    (new template $$anonfun$$3(): Function1)
  }, 0))).+(" solution(s)"))
}
exception when transforming final class SudokuSolver extends java.lang.Object with Application with ScalaObject {
  def this(): object SudokuSolver = {
    SudokuSolver.super.this();
    SudokuSolver.this.$$asInstanceOf[Application$$class]()./*Application$$class*/$$init$$();
    ()
  };
  private[this] var m: Array[Array[Char]] = {
    <synthetic> val $$2$$: java.lang.Object = scala.runtime.ScalaRunTime.arrayValue(scala.List.tabulate(9, {
      @serializable final <synthetic> class $$anonfun$$0 extends java.lang.Object with Function1 with ScalaObject {
        def this(): template $$anonfun$$0 = {
          $$anonfun$$0.super.this();
          $$anonfun$$0.this.$$asInstanceOf[Function1$$class]()./*Function1$$class*/$$init$$();
          ()
        };
        final def apply(x: Int): Array[Char] = {
          <synthetic> val $$1$$: java.lang.Object = scala.runtime.ScalaRunTime.arrayValue({
            scala.this.Predef.stringWrapper(scala.Console.readLine())
          }.toArray(), classOf[scala.Char]);
          if ($$1$$.$$isInstanceOf[scala.runtime.BoxedArray]())
            scala.runtime.ScalaRunTime.arrayValue($$1$$.$$asInstanceOf[scala.runtime.BoxedArray](), classOf[scala.Char])
          else
            $$1$$.$$asInstanceOf[Array[Char]]()
        };
        final <bridge> def apply(x$$1: java.lang.Object): java.lang.Object = $$anonfun$$0.this.apply(scala.Int.unbox(x$$1))
      };
      (new template $$anonfun$$0(): Function1)
    }).toArray(), classOf[[C]);
    if ($$2$$.$$isInstanceOf[scala.runtime.BoxedArray]())
      scala.runtime.ScalaRunTime.arrayValue($$2$$.$$asInstanceOf[scala.runtime.BoxedArray](), classOf[[C])
    else
      $$2$$.$$asInstanceOf[Array[Array[Char]]]()
  };
  <accessor> def m(): Array[Array[Char]] = SudokuSolver.this.m;
  <accessor> def m_=(x$$1: Array[Array[Char]]): Unit = SudokuSolver.this.m = x$$1;
  def print(): Array[scala.runtime.BoxedUnit] = {
    scala.Console.println("");
    {
      <synthetic> val $$3$$: java.lang.Object = scala.runtime.ScalaRunTime.arrayValue(new scala.runtime.BoxedObjectArray(SudokuSolver.this.m().$$asInstanceOf[Array[java.lang.Object]]()).map({
        @serializable final <synthetic> class $$anonfun$$1 extends java.lang.Object with Function1 with ScalaObject {
          def this(): template $$anonfun$$1 = {
            $$anonfun$$1.super.this();
            $$anonfun$$1.this.$$asInstanceOf[Function1$$class]()./*Function1$$class*/$$init$$();
            ()
          };
          final def apply(carr: Array[Char]): Unit = scala.Console.println(new java.lang.String(carr));
          final <bridge> def apply(x$$1: java.lang.Object): java.lang.Object = {
            $$anonfun$$1.this.apply(if (x$$1.$$isInstanceOf[scala.runtime.BoxedArray]())
              scala.runtime.ScalaRunTime.arrayValue(x$$1.$$asInstanceOf[scala.runtime.BoxedArray](), classOf[scala.Char])
            else
              x$$1.$$asInstanceOf[Array[Char]]());
            scala.runtime.BoxedUnit.UNIT
          }
        };
        (new template $$anonfun$$1(): Function1)
      }), classOf[scala.runtime.BoxedUnit]);
      if ($$3$$.$$isInstanceOf[scala.runtime.BoxedArray]())
        scala.runtime.ScalaRunTime.arrayValue($$3$$.$$asInstanceOf[scala.runtime.BoxedArray](), classOf[scala.runtime.BoxedUnit])
      else
        $$3$$.$$asInstanceOf[Array[scala.runtime.BoxedUnit]]()
    }
  };
  def invalid(i: Int, x: Int, y: Int, n: Char): Boolean = _invalid(i,x,y,n){
    i.<(9).&&(SudokuSolver.this.m().apply(y).apply(i).==(n).||(SudokuSolver.this.m().apply(i).apply(x).==(n)).||(SudokuSolver.this.m().apply(y./(3).*(3).+(i./(3))).apply(x./(3).*(3).+(i.%(3))).==(n)).||(_invalid(i.+(1), x, y, n)))
  };
  def fold(f: Function2, accu: Int, l: Int, u: Int): Int = _fold(f,accu,l,u){
    if (l.==(u))
      accu
    else
      _fold(f, scala.Int.unbox(f.apply(scala.Int.box(accu), scala.Int.box(l))), l.+(1), u)
  };
  def search(x: Int, y: Int, f$$0: Function1, accu: Int): Int = _search(x,y,f$$0,accu){
    <synthetic> var temp1: Tuple2 = scala.this.Predef.Pair.apply(scala.Int.box(x), scala.Int.box(y));
    <synthetic> var temp2: Option = scala.this.Predef.Pair.unapply(temp1);
    if (temp2.isEmpty().unary_!())
      {
        <synthetic> var temp3: Tuple2 = temp2.get().$$asInstanceOf[Tuple2]();
        <synthetic> var temp4: Int = scala.Int.unbox(temp3._1());
        <synthetic> var temp5$$0: scala.runtime.IntRef = scala.Int.unbox(temp3._2());
        (temp4: Int) match {
          case 9 => _search(0, temp5$$0.+(1), f$$0, accu)
          case 0 => if (temp5$$0.==(9))
            body%1(){
              scala.Int.unbox(f$$0.apply(scala.Int.box(accu)))
            }
          else
            {
              <synthetic> var temp5$$0: scala.runtime.IntRef = temp5$$0;
              val x$$0: Int = temp4;
              body%2(x$$0,temp5$$0){
                if (SudokuSolver.this.m().apply(temp5$$0).apply(x$$0).!=('0'))
                  _search(x$$0.+(1), temp5$$0, f$$0, accu)
                else
                  SudokuSolver.this.fold({
                    @serializable final <synthetic> class $$anonfun$$2 extends java.lang.Object with Function2 with ScalaObject {
                      def this(): template $$anonfun$$2 = {
                        $$anonfun$$2.super.this();
                        $$anonfun$$2.this.$$asInstanceOf[Function2$$class]()./*Function2$$class*/$$init$$();
                        ()
                      };
                      final def apply(accu: Int, n: Int): Int = if (SudokuSolver.this.invalid(0, x$$0, temp5$$0, n.+(48).toChar()))
                        accu
                      else
                        {
                          SudokuSolver.this.m().apply(temp5$$0).update(x$$0, n.+(48).toChar());
                          val newaccu: Int = SudokuSolver.this.search(x$$0.+(1), temp5$$0, f$$0, accu);
                          SudokuSolver.this.m().apply(temp5$$0).update(x$$0, '0');
                          newaccu
                        };
                      final <bridge> def apply(x$$1: java.lang.Object, x$$2: java.lang.Object): java.lang.Object = scala.Int.box($$anonfun$$2.this.apply(scala.Int.unbox(x$$1), scala.Int.unbox(x$$2)))
                    };
                    (new template $$anonfun$$2(): Function2)
                  }, accu, 1, 10)
              }
            }
          case _ => body%2(temp4, temp5$$0)
        }
      }
    else
      throw new MatchError(temp1)
  };
  scala.Console.println("\012".+(scala.Int.box(SudokuSolver.this.search(0, 0, {
    @serializable final <synthetic> class $$anonfun$$3 extends java.lang.Object with Function1 with ScalaObject {
      def this(): template $$anonfun$$3 = {
        $$anonfun$$3.super.this();
        $$anonfun$$3.this.$$asInstanceOf[Function1$$class]()./*Function1$$class*/$$init$$();
        ()
      };
      final def apply(i: Int): Int = {
        SudokuSolver.this.print();
        i.+(1)
      };
      final <bridge> def apply(x$$1: java.lang.Object): java.lang.Object = scala.Int.box($$anonfun$$3.this.apply(scala.Int.unbox(x$$1)))
    };
    (new template $$anonfun$$3(): Function1)
  }, 0))).+(" solution(s)"))
}
exception when transforming package <empty> {
  final class SudokuSolver extends java.lang.Object with Application with ScalaObject {
    def this(): object SudokuSolver = {
      SudokuSolver.super.this();
      SudokuSolver.this.$$asInstanceOf[Application$$class]()./*Application$$class*/$$init$$();
      ()
    };
    private[this] var m: Array[Array[Char]] = {
      <synthetic> val $$2$$: java.lang.Object = scala.runtime.ScalaRunTime.arrayValue(scala.List.tabulate(9, {
        @serializable final <synthetic> class $$anonfun$$0 extends java.lang.Object with Function1 with ScalaObject {
          def this(): template $$anonfun$$0 = {
            $$anonfun$$0.super.this();
            $$anonfun$$0.this.$$asInstanceOf[Function1$$class]()./*Function1$$class*/$$init$$();
            ()
          };
          final def apply(x: Int): Array[Char] = {
            <synthetic> val $$1$$: java.lang.Object = scala.runtime.ScalaRunTime.arrayValue({
              scala.this.Predef.stringWrapper(scala.Console.readLine())
            }.toArray(), classOf[scala.Char]);
            if ($$1$$.$$isInstanceOf[scala.runtime.BoxedArray]())
              scala.runtime.ScalaRunTime.arrayValue($$1$$.$$asInstanceOf[scala.runtime.BoxedArray](), classOf[scala.Char])
            else
              $$1$$.$$asInstanceOf[Array[Char]]()
          };
          final <bridge> def apply(x$$1: java.lang.Object): java.lang.Object = $$anonfun$$0.this.apply(scala.Int.unbox(x$$1))
        };
        (new template $$anonfun$$0(): Function1)
      }).toArray(), classOf[[C]);
      if ($$2$$.$$isInstanceOf[scala.runtime.BoxedArray]())
        scala.runtime.ScalaRunTime.arrayValue($$2$$.$$asInstanceOf[scala.runtime.BoxedArray](), classOf[[C])
      else
        $$2$$.$$asInstanceOf[Array[Array[Char]]]()
    };
    <accessor> def m(): Array[Array[Char]] = SudokuSolver.this.m;
    <accessor> def m_=(x$$1: Array[Array[Char]]): Unit = SudokuSolver.this.m = x$$1;
    def print(): Array[scala.runtime.BoxedUnit] = {
      scala.Console.println("");
      {
        <synthetic> val $$3$$: java.lang.Object = scala.runtime.ScalaRunTime.arrayValue(new scala.runtime.BoxedObjectArray(SudokuSolver.this.m().$$asInstanceOf[Array[java.lang.Object]]()).map({
          @serializable final <synthetic> class $$anonfun$$1 extends java.lang.Object with Function1 with ScalaObject {
            def this(): template $$anonfun$$1 = {
              $$anonfun$$1.super.this();
              $$anonfun$$1.this.$$asInstanceOf[Function1$$class]()./*Function1$$class*/$$init$$();
              ()
            };
            final def apply(carr: Array[Char]): Unit = scala.Console.println(new java.lang.String(carr));
            final <bridge> def apply(x$$1: java.lang.Object): java.lang.Object = {
              $$anonfun$$1.this.apply(if (x$$1.$$isInstanceOf[scala.runtime.BoxedArray]())
                scala.runtime.ScalaRunTime.arrayValue(x$$1.$$asInstanceOf[scala.runtime.BoxedArray](), classOf[scala.Char])
              else
                x$$1.$$asInstanceOf[Array[Char]]());
              scala.runtime.BoxedUnit.UNIT
            }
          };
          (new template $$anonfun$$1(): Function1)
        }), classOf[scala.runtime.BoxedUnit]);
        if ($$3$$.$$isInstanceOf[scala.runtime.BoxedArray]())
          scala.runtime.ScalaRunTime.arrayValue($$3$$.$$asInstanceOf[scala.runtime.BoxedArray](), classOf[scala.runtime.BoxedUnit])
        else
          $$3$$.$$asInstanceOf[Array[scala.runtime.BoxedUnit]]()
      }
    };
    def invalid(i: Int, x: Int, y: Int, n: Char): Boolean = _invalid(i,x,y,n){
      i.<(9).&&(SudokuSolver.this.m().apply(y).apply(i).==(n).||(SudokuSolver.this.m().apply(i).apply(x).==(n)).||(SudokuSolver.this.m().apply(y./(3).*(3).+(i./(3))).apply(x./(3).*(3).+(i.%(3))).==(n)).||(_invalid(i.+(1), x, y, n)))
    };
    def fold(f: Function2, accu: Int, l: Int, u: Int): Int = _fold(f,accu,l,u){
      if (l.==(u))
        accu
      else
        _fold(f, scala.Int.unbox(f.apply(scala.Int.box(accu), scala.Int.box(l))), l.+(1), u)
    };
    def search(x: Int, y: Int, f$$0: Function1, accu: Int): Int = _search(x,y,f$$0,accu){
      <synthetic> var temp1: Tuple2 = scala.this.Predef.Pair.apply(scala.Int.box(x), scala.Int.box(y));
      <synthetic> var temp2: Option = scala.this.Predef.Pair.unapply(temp1);
      if (temp2.isEmpty().unary_!())
        {
          <synthetic> var temp3: Tuple2 = temp2.get().$$asInstanceOf[Tuple2]();
          <synthetic> var temp4: Int = scala.Int.unbox(temp3._1());
          <synthetic> var temp5$$0: scala.runtime.IntRef = scala.Int.unbox(temp3._2());
          (temp4: Int) match {
            case 9 => _search(0, temp5$$0.+(1), f$$0, accu)
            case 0 => if (temp5$$0.==(9))
              body%1(){
                scala.Int.unbox(f$$0.apply(scala.Int.box(accu)))
              }
            else
              {
                <synthetic> var temp5$$0: scala.runtime.IntRef = temp5$$0;
                val x$$0: Int = temp4;
                body%2(x$$0,temp5$$0){
                  if (SudokuSolver.this.m().apply(temp5$$0).apply(x$$0).!=('0'))
                    _search(x$$0.+(1), temp5$$0, f$$0, accu)
                  else
                    SudokuSolver.this.fold({
                      @serializable final <synthetic> class $$anonfun$$2 extends java.lang.Object with Function2 with ScalaObject {
                        def this(): template $$anonfun$$2 = {
                          $$anonfun$$2.super.this();
                          $$anonfun$$2.this.$$asInstanceOf[Function2$$class]()./*Function2$$class*/$$init$$();
                          ()
                        };
                        final def apply(accu: Int, n: Int): Int = if (SudokuSolver.this.invalid(0, x$$0, temp5$$0, n.+(48).toChar()))
                          accu
                        else
                          {
                            SudokuSolver.this.m().apply(temp5$$0).update(x$$0, n.+(48).toChar());
                            val newaccu: Int = SudokuSolver.this.search(x$$0.+(1), temp5$$0, f$$0, accu);
                            SudokuSolver.this.m().apply(temp5$$0).update(x$$0, '0');
                            newaccu
                          };
                        final <bridge> def apply(x$$1: java.lang.Object, x$$2: java.lang.Object): java.lang.Object = scala.Int.box($$anonfun$$2.this.apply(scala.Int.unbox(x$$1), scala.Int.unbox(x$$2)))
                      };
                      (new template $$anonfun$$2(): Function2)
                    }, accu, 1, 10)
                }
              }
            case _ => body%2(temp4, temp5$$0)
          }
        }
      else
        throw new MatchError(temp1)
    };
    scala.Console.println("\012".+(scala.Int.box(SudokuSolver.this.search(0, 0, {
      @serializable final <synthetic> class $$anonfun$$3 extends java.lang.Object with Function1 with ScalaObject {
        def this(): template $$anonfun$$3 = {
          $$anonfun$$3.super.this();
          $$anonfun$$3.this.$$asInstanceOf[Function1$$class]()./*Function1$$class*/$$init$$();
          ()
        };
        final def apply(i: Int): Int = {
          SudokuSolver.this.print();
          i.+(1)
        };
        final <bridge> def apply(x$$1: java.lang.Object): java.lang.Object = scala.Int.box($$anonfun$$3.this.apply(scala.Int.unbox(x$$1)))
      };
      (new template $$anonfun$$3(): Function1)
    }, 0))).+(" solution(s)"))
  }
}

Exception in thread "main" java.lang.ClassCastException: scala.tools.nsc.ast.Tre
es$$Select cannot be cast to scala.tools.nsc.ast.Trees$$Ident
        at scala.tools.nsc.ast.Trees$$Transformer$$$$anonfun$$32.apply(Trees.scala:1350)
        at scala.tools.nsc.ast.Trees$$Transformer$$$$anonfun$$32.apply(Trees.scala:1350)
        at scala.List$$.loop$$0(List.scala:244)
        at scala.List$$.mapConserve(List.scala:261)
        at scala.tools.nsc.ast.Trees$$Transformer.transformIdents(Trees.scala:1350)
        at scala.tools.nsc.ast.Trees$$Transformer.transform(Trees.scala:1256)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.transform(TypingTransformers.scala:46)
        at scala.tools.nsc.transform.ExplicitOuter$$OuterPathTransformer.transform(ExplicitOuter.scala:207)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter.transform(LambdaLift.scala:397)
        at scala.tools.nsc.ast.Trees$$Transformer.transform(Trees.scala:1266)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.transform(TypingTransformers.scala:46)
        at scala.tools.nsc.transform.ExplicitOuter$$OuterPathTransformer.transform(ExplicitOuter.scala:207)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter.transform(LambdaLift.scala:397)
        at scala.tools.nsc.ast.Trees$$Transformer.transform(Trees.scala:1288)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.transform(TypingTransformers.scala:46)
        at scala.tools.nsc.transform.ExplicitOuter$$OuterPathTransformer.transform(ExplicitOuter.scala:207)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter.transform(LambdaLift.scala:397)
        at scala.tools.nsc.ast.Trees$$Transformer.transform(Trees.scala:1268)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.transform(TypingTransformers.scala:46)
        at scala.tools.nsc.transform.ExplicitOuter$$OuterPathTransformer.transform(ExplicitOuter.scala:207)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter.transform(LambdaLift.scala:397)
        at scala.tools.nsc.ast.Trees$$Transformer$$$$anonfun$$31.apply(Trees.scala:1348)
        at scala.tools.nsc.ast.Trees$$Transformer$$$$anonfun$$31.apply(Trees.scala:1348)
        at scala.List$$.loop$$0(List.scala:244)
        at scala.List$$.mapConserve(List.scala:261)
        at scala.List$$.loop$$0(List.scala:248)
        at scala.List$$.mapConserve(List.scala:261)
        at scala.tools.nsc.ast.Trees$$Transformer.transformCaseDefs(Trees.scala:1348)
        at scala.tools.nsc.ast.Trees$$Transformer.transform(Trees.scala:1290)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.transform(TypingTransformers.scala:46)
        at scala.tools.nsc.transform.ExplicitOuter$$OuterPathTransformer.transform(ExplicitOuter.scala:207)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter.transform(LambdaLift.scala:397)
        at scala.tools.nsc.ast.Trees$$Transformer.transform(Trees.scala:1266)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.transform(TypingTransformers.scala:46)
        at scala.tools.nsc.transform.ExplicitOuter$$OuterPathTransformer.transform(ExplicitOuter.scala:207)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter.transform(LambdaLift.scala:397)
        at scala.tools.nsc.ast.Trees$$Transformer.transform(Trees.scala:1288)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.transform(TypingTransformers.scala:46)
        at scala.tools.nsc.transform.ExplicitOuter$$OuterPathTransformer.transform(ExplicitOuter.scala:207)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter.transform(LambdaLift.scala:397)
        at scala.tools.nsc.ast.Trees$$Transformer.transform(Trees.scala:1266)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.transform(TypingTransformers.scala:46)
        at scala.tools.nsc.transform.ExplicitOuter$$OuterPathTransformer.transform(ExplicitOuter.scala:207)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter.transform(LambdaLift.scala:397)
        at scala.tools.nsc.ast.Trees$$Transformer.transform(Trees.scala:1256)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.transform(TypingTransformers.scala:46)
        at scala.tools.nsc.transform.ExplicitOuter$$OuterPathTransformer.transform(ExplicitOuter.scala:207)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter.transform(LambdaLift.scala:397)
        at scala.tools.nsc.ast.Trees$$Transformer$$$$anonfun$$24.apply(Trees.scala:1249)
        at scala.tools.nsc.ast.Trees$$Transformer$$$$anonfun$$24.apply(Trees.scala:1248)
        at scala.tools.nsc.ast.Trees$$Transformer.atOwner(Trees.scala:1360)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.atOwner(TypingTransformers.scala:33)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.atOwner(TypingTransformers.scala:27)
        at scala.tools.nsc.ast.Trees$$Transformer.transform(Trees.scala:1247)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.transform(TypingTransformers.scala:46)
        at scala.tools.nsc.transform.ExplicitOuter$$OuterPathTransformer.transform(ExplicitOuter.scala:207)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter.transform(LambdaLift.scala:397)
        at scala.tools.nsc.ast.Trees$$Transformer$$$$anonfun$$33.apply(Trees.scala:1354)
        at scala.tools.nsc.ast.Trees$$Transformer$$$$anonfun$$33.apply(Trees.scala:1352)
        at scala.List$$.loop$$0(List.scala:244)
        at scala.List$$.mapConserve(List.scala:261)
        at scala.List$$.loop$$0(List.scala:248)
        at scala.List$$.mapConserve(List.scala:261)
        at scala.List$$.loop$$0(List.scala:248)
        at scala.List$$.mapConserve(List.scala:261)
        at scala.tools.nsc.ast.Trees$$Transformer.transformStats(Trees.scala:1352)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter.transformStats(LambdaLift.scala:411)
        at scala.tools.nsc.ast.Trees$$Transformer.transform(Trees.scala:1264)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.scala$$tools$$nsc$$transform$$TypingTransformers$$TypingTransformer$$$$super$$transform(TypingTransformers.scala:44)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer$$$$anonfun$$0.apply(TypingTransformers.scala:44)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer$$$$anonfun$$0.apply(TypingTransformers.scala:44)
        at scala.tools.nsc.ast.Trees$$Transformer.atOwner(Trees.scala:1360)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.atOwner(TypingTransformers.scala:33)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.atOwner(TypingTransformers.scala:27)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.transform(TypingTransformers.scala:44)
        at scala.tools.nsc.transform.ExplicitOuter$$OuterPathTransformer.transform(ExplicitOuter.scala:207)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter.transform(LambdaLift.scala:397)
        at scala.tools.nsc.ast.Trees$$Transformer.transformTemplate(Trees.scala:1338)
        at scala.tools.nsc.ast.Trees$$Transformer$$$$anonfun$$21.apply(Trees.scala:1236)
        at scala.tools.nsc.ast.Trees$$Transformer$$$$anonfun$$21.apply(Trees.scala:1236)
        at scala.tools.nsc.ast.Trees$$Transformer.atOwner(Trees.scala:1360)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.atOwner(TypingTransformers.scala:33)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.atOwner(TypingTransformers.scala:27)
        at scala.tools.nsc.ast.Trees$$Transformer.transform(Trees.scala:1235)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.transform(TypingTransformers.scala:46)
        at scala.tools.nsc.transform.ExplicitOuter$$OuterPathTransformer.transform(ExplicitOuter.scala:207)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter.transform(LambdaLift.scala:397)
        at scala.tools.nsc.ast.Trees$$Transformer$$$$anonfun$$33.apply(Trees.scala:1354)
        at scala.tools.nsc.ast.Trees$$Transformer$$$$anonfun$$33.apply(Trees.scala:1352)
        at scala.List$$.loop$$0(List.scala:244)
        at scala.List$$.mapConserve(List.scala:261)
        at scala.tools.nsc.ast.Trees$$Transformer.transformStats(Trees.scala:1352)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter.transformStats(LambdaLift.scala:411)
        at scala.tools.nsc.ast.Trees$$Transformer$$$$anonfun$$20.apply(Trees.scala:1232)
        at scala.tools.nsc.ast.Trees$$Transformer$$$$anonfun$$20.apply(Trees.scala:1232)
        at scala.tools.nsc.ast.Trees$$Transformer.atOwner(Trees.scala:1360)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.atOwner(TypingTransformers.scala:33)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.atOwner(TypingTransformers.scala:27)
        at scala.tools.nsc.ast.Trees$$Transformer.transform(Trees.scala:1231)
        at scala.tools.nsc.transform.TypingTransformers$$TypingTransformer.transform(TypingTransformers.scala:46)
        at scala.tools.nsc.transform.ExplicitOuter$$OuterPathTransformer.transform(ExplicitOuter.scala:207)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter.transform(LambdaLift.scala:397)
        at scala.tools.nsc.ast.Trees$$Transformer.transformUnit(Trees.scala:1355)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter.scala$$tools$$nsc$$transform$$LambdaLift$$LambdaLifter$$$$super$$transformUnit(LambdaLift.scala:416)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter$$$$anonfun$$15.apply(LambdaLift.scala:416)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter$$$$anonfun$$15.apply(LambdaLift.scala:416)
        at scala.tools.nsc.symtab.SymbolTable.atPhase(SymbolTable.scala:85)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter.transformUnit(LambdaLift.scala:416)
        at scala.tools.nsc.transform.LambdaLift$$LambdaLifter.transformUnit(LambdaLift.scala:45)
        at scala.tools.nsc.transform.Transform$$Phase.apply(Transform.scala:30)
        at scala.tools.nsc.Global$$GlobalPhase.applyPhase(Global.scala:243)
        at scala.tools.nsc.Global$$GlobalPhase$$$$anonfun$$2.apply(Global.scala:232)
        at scala.tools.nsc.Global$$GlobalPhase$$$$anonfun$$2.apply(Global.scala:232)
        at scala.Iterator$$class.foreach(Iterator.scala:375)
        at scala.collection.mutable.ListBuffer$$$$anon$$0.foreach(ListBuffer.scala:255)
        at scala.tools.nsc.Global$$GlobalPhase.run(Global.scala:232)
        at scala.tools.nsc.Global$$Run.compileSources(Global.scala:528)
        at scala.tools.nsc.Global$$Run.compile(Global.scala:609)
        at scala.tools.nsc.Main$$.process(Main.scala:86)
        at scala.tools.nsc.Main$$.main(Main.scala:107)
        at scala.tools.nsc.Main.main(Main.scala)
{code}
