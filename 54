I fiddled with this some more, and adding a type parameter `TFoo` to buildProd is enough to get the program to type check. This makes me think the original problem is not directly related to dependent method types (in fact, it encodes them, but I don't think it _uses_ them).

{code}
case class buildProd[TFoo <: Foo](foo: TFoo) {  // now it works
  def apply(a: foo.Arg): foo.Prod = foo.makeProd(a)
}
{code}
