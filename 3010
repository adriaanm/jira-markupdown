First, there was a bug in the way existential types are printed. It printed them with wildcards even if there was sharing. This will corrected in my next checkin. Second, try writing the definition of y like this:
{code}
 val y : Pair[B,B] forSome {type B} = Pair("a","a") 
{code}
this is exactly the same as yours; the type name is locally bound, so using A as a type parameter twice will have no effect except add confusion. Alternatively you could try to compile or use the REPL with -uniqid.
With the changed output method, I now get:
{code}
scala> List(x, y)
res1: List[Pair[_3,_4] forSome { type _3 >: B with A; type _4 >: B with A }] forSome { type B; type A } = List(Pair(1,1), Pair(a,a))
{code}
This is the type I would expect. The problem here is when you write x, y, their (existential) types are unpacked, like this:
{code}
  x: Pair['A, 'A]
  y: Pair['B, 'B]
{code}
for some unknown types 'A, 'B which correspond to the type parameters A, B.
When forming the List(x, y), the resulting type is packed again. 

You would probably like the type of x and y to not be unpacked and the resulting existential to be used as the list element type. But that's not how existentials work in Scala. In fact specifying something like that would make them highly ambiguous.





