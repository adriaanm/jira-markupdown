it doesn't crash for me, but it gives an error message with a huge structural type, which could be due to the way how arrays are handled in the compiler.


{code}
Test1.scala:3: error: type mismatch;
 found   : (String) => Option[Array[String]]
 required: (String) => Option[Seq[String]{def projection: Seq.Projection[String]{def append[B >: String](=> Iterable[B]): Seq.Projection[B]{def append[B >: B](=> Iterable[B]): Seq.Projection[B]{def append[B >: B](=> Iterable[B]): Seq.Projection[B]}; def force: Seq[B]{def ++[B >: B](Iterable[B]): Seq[B]}}; def force: Seq[String]{def projection: Seq.Projection[String]{def append[B >: String](=> Iterable[B]): Seq.Projection[B]; def reverse: Seq.Projection[String]; def drop(Int): Seq.Projection[String]; def take(Int): Seq.Projection[String]}; def reverse: Seq[String]{def ++[B >: String](Iterable[B]): Seq[B]}; [.............] def ++[B >: B](Iterable[B]): Seq[B]{def ++[B >: B](Iterable[B]): Seq[B]}}}]
        get(key, getValues _, setValues _, f)
                 ^
{code}
