In Java, I have:
{code:title=java/p/UseIt.java}
package p;

import q.Z;

public class UseIt {
    public static Z getZ() {
        return new Z();
    }
    
    public static q.Z zFullyQualified() {
        return getZ();
    }
}
{code} 
{code:title=java/p/Z.java}
package p;
public class Z {}
{code} 
{code:title=java/q/Z.java}
package q;
public class Z {}
{code}

In Scala:

{code:title=scala/SomeClass.scala}
class SomeClass {
  val z: q.Z = p.UseIt.zFullyQualified
  val z2: q.Z = p.UseIt.getZ //error here
}
{code}

When compiling, there is an error:
{noformat}
src/scala/SomeClass.scala:3: error: type mismatch;
 found   : p.Z
 required: q.Z
  val z2: q.Z = p.UseIt.getZ //error here
                        ^
one error found
{noformat}

This works when the return type in Java is fully qualified.

I think what's causing this is a difference in precedence/shadowing between Scala and Java. In Java, although {{UseIt}} is in package {{p}} and has access to {{p.Z}}, the {{import q.Z}} shadows it:
JLS 6.4.1:
{quote}A single-type-import declaration d in a compilation unit c of package p that imports a type named n shadows, throughout c, the declarations of: 
 * any top level type named n declared in another compilation unit of p{quote}

In the SLS chapter 2, assuming a "compilation unit" includes all classes in a package regardless of which file they are in, the class {{p.Z}} has a higher precedence than the {{import q.Z}}. I assume that when the Scala compiler reads in Java and does the Scala conversion, it ends up mistakenly using the scoping rules from Scala instead of Java.

