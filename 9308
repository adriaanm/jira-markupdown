I think this is all in line with the spec.
```
If an identifier or selection e references several members of a class, the context of the reference is used to identify a unique member. The way this is done depends on whether or not e is used as a function. Let A be the set of members referenced by e.
Assume first that e appears as a function in an application, as in e(e1, ..., em).

...
A polymorphic method of type [a1 >: L1 <: U1, ..., an >: Ln <: Un]T is as specific as some other member of type S if T is as specific as S under the assumption that for i = 1, . . . , n each ai is an abstract type name bounded frombelowbyLi and from above by Ui.
...

Assume next that e appears as a function in a type application, as in e[targs]. Then all alternatives in A which take the same number of type parameters as there are type arguments in targs are chosen. It is an error if no such alternative exists. If there are several such alternatives, overloading resolution is applied again to the whole expression e[targs].
```

Without explicit type arguments, the compiler chooses between [T](x: Traversable[_ <: T])Seq[T] and [U](x: Iterable[_ <: U])Seq[U]. I've changed the type parameter names to distinguish them. They are unrelated types, so neither function has parameters of types that are applicable to the other.
