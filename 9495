Also interesting for comparison:
```scala
sealed abstract class B;
case object True extends B;
case object False extends B;

object Test2 {

  val X: B = True
  val Y: B = False

  (null: Tuple1[B]) match {
    case Tuple1(X) =>
    case Tuple1(Y) => // no warning
    case _      =>
  }
}
```
```
reachable:
 -V1=null#1  /\
   V2=Y#3
under prefix:
 V2=False.type#4  \/ V2=True.type#5 \/ V2=null#6  /\
     -V2=Y#3      \/    -V2=X#2     \/     /\
     -V2=Y#3      \/   -V2=null#6   \/     /\
 -V2=False.type#4 \/   -V2=null#6   \/     /\
     -V2=X#2      \/   -V2=null#6   \/     /\
 -V2=True.type#5  \/   -V2=null#6   \/     /\
    V1=null#1     \/    -V2=X#2     \/     via Map(V2=Y#3 -> true, V2=False.type#4 -> true, V2=X#2 -> false, V1=null#1 -> false, V2=null#6 -> false)
```

Compare with the unsatisfiable model for:
```scala
object Test {
  val X, Y = true
  (null: Tuple1[Boolean]) match {
    case Tuple1(X) =>
    case Tuple1(Y) => // unreachable
    case _      =>
  }
}
```
```
unreachable:
 -V1=null#1  /\
   V2=Y#3
under prefix:
  V2=true#4  \/ V2=false#5   /\
   -V2=X#2   \/ -V2=false#5  /\
   -V2=X#2   \/   -V2=Y#3    /\
   -V2=X#2   \/ -V2=true#4   /\
 -V2=false#5 \/   -V2=Y#3    /\
 -V2=false#5 \/ -V2=true#4   /\
   -V2=Y#3   \/ -V2=true#4   /\
  V1=null#1  \/   -V2=X#2
```
