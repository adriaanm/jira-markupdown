It would be very handy if Future.map and Future.flatMap returned a Future, instead of returning only a Responder.

Since Responders lacks Future's apply() methods and can't be used with Futures.awaitAll (resp. awaitEither), mapping a future currently limits it's further use to CPS programming.

Having the Future monad transform to itself instead of a weaker superclass would also be more elegant:

{code}
def f(fi: Future[Int], fj: Future[Int]) : Future[Int] = for (
  i <- fi;
  j <- fy
) yield {
  i + j
}

println( f(a !! (x, ...), b !! (y, ...)) () )
{code}


Is this doable?
