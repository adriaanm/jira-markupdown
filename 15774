There's a structural invocation in {{nsc.ast.parser.Scanners}}. Not sure whether there's a performance impact, but doing away with it is easy. Rather than defining {{lookaheadReader}} (in  {{CharArrayReader.scala}}) to have a refinement type, give a name to its class: 


{code}
  /** A new reader that takes off at the current character position */
  def lookaheadReader = new CharArrayReaderForLookahead 

  class CharArrayReaderForLookahead extends CharArrayReader {  
    val buf = self.buf
    charOffset = self.charOffset
    ch = self.ch
    override def decodeUni = self.decodeUni
    def error(offset: Int, msg: String) = self.error(offset, msg)
    /** A mystery why CharArrayReader.nextChar() returns Unit */
    def getc() = { nextChar() ; ch }
  }
{code}


Besides that one, there are three other cases of dynamic dispatch in the compiler sources (granted, {{forMSIL}} without {{-optimize}}) found after placing a breakpoint at {{CleanUp}} on:

{{    case ad@ApplyDynamic(qual0, params) =>  }}

{code}
(1)
    pos: scala\\tools\\nsc\\typechecker\\Implicits.scala,line-857,offset=39632
    qual = "ImplicitSearch.this.scala$$tools$$nsc$$typechecker$$Implicits$$ImplicitSearch$$$$$$outer().global().erasure().erasure()"
    args = "List(parents)"
    symbol = "method intersectionDominator"

(2) 
    pos: scala\\tools\\nsc\\io\\File.scala,line-31,offset=1334
    qual = "target"
    args = "List()"
    symbol = "method close"

(3) 
    pos: "scala\\tools\\nsc\\io\\ZipArchive.scala,line-265,offset=8462"
    qual = "x.traverser()"
    args = "List()"
    symbol = "method zis"

{code}
