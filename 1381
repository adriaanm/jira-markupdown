I hit the same problem a few weeks back but didn't get around to reporting it. The above solution is better than the current state, but still not complete wrt. the Java Language Specification. I would propose to add the following methods to JavaTokenParsers:

{code}
    def decimalIntegerLiteral: Parser[String] =
      """-?(0|[1-9]\d*)[lL]?""".r
    def octalIntegerLiteral: Parser[String] =
      """-?0[0-7]+[lL]?""".r
    def hexIntegerLiteral: Parser[String] =
      """-?0[xX][0-9a-fA-F]+[lL]?""".r
    def floatingPointLiteral: Parser[String] =
      ("-?(" +
      """(\d+\.\d*|\.\d+)([eE][+-]?\d+)?[fFdD]?|""" +
      """\d+[eE][+-]?\d+[fFdD]?|""" +
      """\d+([eE][+-]?\d+)?[fFdD]""" +
      ")").r
{code}

The integers can be parsed using java.lang.Integer.decode(), parseInt() does not handle the radix prefix. I've broken up the float expression for readability, but I hope that this does not incur a runtime cost.
