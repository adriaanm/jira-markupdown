The change wasn't in the typechecker, it was in the library. Matching against `scala.util.Right` still gives the error.
```scala
object Test {
  sealed trait Foo
  object Bar extends Foo

  object Other
  val OtherAlias = Other

  def f(x: Foo) = x match {
    case Other => true // warns
    case _     => false
  }

  def g(x: Foo) = x match {
    case OtherAlias => true // no warning.
    case _          => false
  }
}
```

The check happens in `adapt`, which calls `inferModulePattern` if the pattern's symbol is a module. Seems to me that we should make the check for any stable identifier pattern:
```
A stable identifier pattern is a stable identifier r (ยง3.1). The type of r must conform to the expected type of the pattern. The pattern matches any value v such that r == v (ยง12.1).
```
