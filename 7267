OK, I'm pretty sure the issue is that makeSpecializedMembers/specName is linking the type params to the wrong class. For example:
```scala
[log explicitouter] creating tree for C2$mcLV$sp.<init>
[log explicitouter] specName(value v) env: Map(type A -> A$sp, type B -> scala.this.Unit) tvars: Set(type A)
[log explicitouter] specName #2 Map(C2.A -> C2$mcLZ$sp.A$sp, C2.B -> scala.Unit)
[log explicitouter] specName(value w) env: Map(type A -> A$sp, type B -> scala.this.Unit) tvars: Set(type B)
[log explicitouter] specName #2 Map(C2.A -> C2$mcLZ$sp.A$sp, C2.B -> scala.Unit)
```

(I added the "specName #2" log line which maps the value TypeRef into its symbol's fullName)

Notice that we're interested in C2$mcLV$sp but we're getting an A$sp owned by C2$mcLZ$sp (Z instead of V).

OK... now all we need to do is figure out what needs to be fixed to make specName return the right thing (which might include passing it more context).
