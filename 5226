Hey, interesting.  Last time I tried something like this (it was a while ago) the type system would not cooperate.  But now this works, at least in limited testing.
{code}
implicit def IterableSubclass[CC[X] <: Iterable[X], T: Ordering] : Ordering[CC[T]] = {
  new Ordering[CC[T]] {
    val ord = implicitly[Ordering[T]]
    def compare(x: CC[T], y: CC[T]): Int = {
      val xe = x.iterator
      val ye = y.iterator

      while (xe.hasNext && ye.hasNext) {
        val res = ord.compare(xe.next, ye.next)
        if (res != 0) return res
      }

      Ordering.Boolean.compare(xe.hasNext, ye.hasNext)
    }
  }
}  
{code}
{code}
scala> List(List(1,2,5),List(1,2,10),List(1,2),List(3,1,249,4)).sorted
res0: List[List[Int]] = List(List(1, 2), List(1, 2, 5), List(1, 2, 10), List(3, 1, 249, 4))

scala> Seq(Seq(1, 2, 5), Seq(5, 4, 3), Seq( 1, 2)).sorted
res1: Seq[Seq[Int]] = List(List(1, 2), List(1, 2, 5), List(5, 4, 3))  
{code}
