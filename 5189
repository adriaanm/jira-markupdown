I found what looks to be a workaround, using  [http://groups.google.com/group/scalaz/browse_thread/thread/862543e872b09f3c type lambdas] instead of the ComposeT trait. The working file looks like:

{code}
trait Functor[F[_]] {
  def map[A,B](fa: F[A], f: A => B): F[B]
}

case class Compose[F[_],G[_]]() {
  def Functor(implicit f: Functor[F], g: Functor[G]): Functor[({type f[x] = F[G[x]]})#f] =
    new Functor[({type f[x] = F[G[x]]})#f] {
      def map[A,B](c: F[G[A]], h: A => B): F[G[B]] = 
        f.map(c, (x:G[A]) => g.map(x,h))
    }
}

object Cat {
  def compose[F[_],G[_]] = Compose[F,G]()
}

object Functors {
  implicit val List = new Functor[List] { 
    def map[A,B](fa: List[A], f: A => B): List[B] = fa map f
  }
  implicit val Option = new Functor[Option] { 
    def map[A,B](fa: Option[A], f: A => B): Option[B] = fa map f
  }
}

object Main {
  import Functors._
  val cf = Cat.compose[List,Option].Functor
}
{code}
