Well, at this point I have traced the problem back to the typer incorrectly deciding the type of C2$mcLI$sp's constructor, despite getting it right in the case of C1$mcLI$sp. The difference between C1 and C2 is that the typer substitutes String for A$sp whereas in C2 it doesn't.

The relevant typer debug output of C1 looks like:

{code}
    typing new <empty>.this.C1$mcLI$sp[lang.this.String].<init>("abc", 123): pt = ?: undetparams=, implicitsEnabled=false, silent=false, context.owner=method main
[log explicitouter] [context] ++ test.scala / Apply
        typing new <empty>.this.C1$mcLI$sp[lang.this.String].<init>: pt = ?: undetparams=, implicitsEnabled=false, silent=true, context.owner=method main
            typing new <empty>.this.C1$mcLI$sp[lang.this.String]: pt = ?: undetparams=, implicitsEnabled=false, silent=true, context.owner=method main
            typed new <empty>.this.C1$mcLI$sp[lang.this.String]: <empty>.this.C1$mcLI$sp[lang.this.String]
            adapted new <empty>.this.C1$mcLI$sp[lang.this.String]: <empty>.this.C1$mcLI$sp[lang.this.String] to ?, 
        typed new <empty>.this.C1$mcLI$sp[lang.this.String].<init>: (<param> v: lang.this.String, <param> w: scala.this.Int)<empty>.this.C1$mcLI$sp[lang.this.String]
{code}

The broken typer output of C2 looks like:

{code}
    typing new <empty>.this.C2$mcLI$sp[lang.this.String].<init>("abc", 123): pt = ?: undetparams=, implicitsEnabled=false, silent=false, context.owner=method main
[log explicitouter] [context] ++ test.scala / Apply
        typing new <empty>.this.C2$mcLI$sp[lang.this.String].<init>: pt = ?: undetparams=, implicitsEnabled=false, silent=true, context.owner=method main
            typing new <empty>.this.C2$mcLI$sp[lang.this.String]: pt = ?: undetparams=, implicitsEnabled=false, silent=true, context.owner=method main
            typed new <empty>.this.C2$mcLI$sp[lang.this.String]: <empty>.this.C2$mcLI$sp[lang.this.String]
            adapted new <empty>.this.C2$mcLI$sp[lang.this.String]: <empty>.this.C2$mcLI$sp[lang.this.String] to ?, 
        typed new <empty>.this.C2$mcLI$sp[lang.this.String].<init>: (<param> v: A$sp, <param> w: scala.this.Int)<empty>.this.C2$mcLI$sp[A$sp]
{code}

I'm still trying to understand how this all works, so I don't have any futher insight. But up to this point the trees seem identical (AFAIK) so I assume that some internal state somewhere else is what is different.
