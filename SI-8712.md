{code:java}
scala> "\u000A".map(_.toInt)
res7: scala.collection.immutable.IndexedSeq[Int] = Vector(10)

scala> """\u000A""".map(_.toInt)
res8: scala.collection.immutable.IndexedSeq[Int] = Vector(10)

scala> "\u001A".map(_.toInt)
res9: scala.collection.immutable.IndexedSeq[Int] = Vector(26)

scala> """\u001A""".map(_.toInt)
<console>:1: error: illegal character
       """\u001A""".map(_.toInt)
               ^
{code}
Normally, with any quoting:
{code}
suend.scala:5: error: unclosed multi-line string literal
  Console println ("""\u001A""" map (_.toInt))
                   ^
suend.scala:5: error: illegal character
  Console println ("""\u001A""" map (_.toInt))
                           ^
{code}
or
{code}
suend.scala:6: error: illegal character
  Console println ("\u001A" map (_.toInt))
                         ^
{code}
And for example,
{code}
suend.scala:5: error: unclosed comment
  /* \u001a */
  ^
{code}
The behavior of SU (substitute for a bad char) kind of explains
{code}
      case SU => // strangely enough, Character.isUnicodeIdentifierPart(SU) returns true!
        finishNamed()
{code}
that is, because or despite the fact that
{code}
Character.isIdentifierIgnorable(SU)
{code}
Scala balks at the interloper.

If a fellow in a mask showed up in your room, would you say, "Oh, he might be Zorro or maybe Batman, I mustn't kick him out!"

Or perhaps, because he is ignorable, you settle deeper into your armchair and go on reading your novel.

This may not be something to advertize, but a workaround is to use interpolation, where scanning is subtly different because, you know, it's different code:
{code}
scala> val x = s"""\u001A"""
x: String = ?
{code}
