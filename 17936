Below I show two lines of code which should be equivalent but aren't - implicit resolution has issues on the first. The workaround was simply to desugar the context bound `That: Man` into an implicit parameter - hence I would say that this is a bug. `-Xprint:typer` suggest that this bug will stay open for long, as explained below.

Non-working version:
```scala
def map[B:Man, That:Man](f: Exp[A] => Exp[B])(implicit foo: CanBuild1[B, That]): Exp[That]
```
Working version:
```scala
def map[B:Man, That](f: Exp[A] => Exp[B])(implicit foo: CanBuild1[B, That], m: Man[That]): Exp[That]
```
Note that the two lines desugar into different things: the order of implicit parameters is different.
The first desugars to:
```scala
def map[B >: Nothing <: Any, That >: Nothing <: Any](f: BugMan.Exp[A] => BugMan.Exp[B])(implicit evidence$6: BugMan.Man[B], evidence$7: BugMan.Man[That], foo: BugMan.CanBuild1[B,That]): BugMan.Exp[That] = scala.sys.`package`.error("TraversableOps1.map")
//Call site:
new BugMan.TraversableOps1[Int]()(BugMan.this.man[Int]).map[Int, List[Int]](((x: BugMan.Exp[Int]) => x))(BugMan.this.man[Int], BugMan.this.man[Nothing], BugMan.this.canBuildList1[Int](BugMan.this.man[Int]));
```
Note that `That` is deduced from the **last** parameter and used before.
The second example desugars to:
```scala
def map[B >: Nothing <: Any, That >: Nothing <: Any](f: BugMan.Exp[A] => BugMan.Exp[B])(implicit evidence$9: BugMan.Man[B], foo: BugMan.CanBuild1[B,That], m: BugMan.Man[That]): BugMan.Exp[That] = scala.sys.`package`.error("TraversableOps1.map")
//Call site:
new BugMan.TraversableOps2[Int]()(BugMan.this.man[Int]).map[Int, List[Int]](((x: BugMan.Exp[Int]) => x))(BugMan.this.man[Int], BugMan.this.canBuildList1[Int](BugMan.this.man[Int]), BugMan.this.man[List[Int]])
```

Complete example and error message below.

The error message mentions `Nothing`, as if type inference hadn't fully happened. In fact, this code would require the different implicits to be in different parameter lists - or failing that, scalac should do type inference across a single parameter list, the kind of thing which it consciously refuses to do for e.g. non-curried fold methods. Given that the second thing is not going to happen soon, I'd mention again my proposal for multiple implicit parameter lists:

http://blaisorbladeprog.blogspot.de/2013/01/flexible-implicits-from-agda-for-scala.html

Note that if instead of a generic `Man` I use `Manifest` (as I was doing before reducing the example), the error message is completely different - it claims another implicit is missing, of type `CanBuild1\[Int,That]` - as if `That` hadn't yet been deduced.
```scala
object BugMan {
  class Man[T]
  implicit def man[T] = new Man[T]

  class Exp[A:Man]
  class CanBuild1[B:Man, That:Man]
  implicit def canBuildList1[A:Man] = new CanBuild1[A, List[A]]
  //Fails:
//  /*
  class TraversableOps1[A:Man] {
    def map[B:Man, That:Man](f: Exp[A] => Exp[B])(implicit foo: CanBuild1[B, That]): Exp[That] = sys error "TraversableOps1.map"
  }
  for { x <- new TraversableOps1[Int] } yield x
//  */
  class TraversableOps2[A:Man] {
    def map[B:Man, That](f: Exp[A] => Exp[B])(implicit foo: CanBuild1[B, That], m: Man[That]): Exp[That] = sys error "TraversableOps1.map"
  }
  for { x <- new TraversableOps2[Int] } yield x
}

object BugManifest {
  class Exp[A:Manifest]
  class CanBuild1[B:Manifest, That:Manifest]
  implicit def canBuildList1[A:Manifest] = new CanBuild1[A, List[A]]
  //Fails:
//  /*
  class TraversableOps1[A:Manifest] {
    def map[B:Manifest, That:Manifest](f: Exp[A] => Exp[B])(implicit foo: CanBuild1[B, That]): Exp[That] = sys error "TraversableOps1.map"
  }
  for { x <- new TraversableOps1[Int] } yield x
//  */
  class TraversableOps2[A:Manifest] {
    def map[B:Manifest, That](f: Exp[A] => Exp[B])(implicit foo: CanBuild1[B, That], m: Manifest[That]): Exp[That] = sys error "TraversableOps1.map"
  }
  for { x <- new TraversableOps2[Int] } yield x
}
```

Scalac's lament:
```scala
bugReport.scala:14: error: type mismatch;
 found   : BugMan.Man[Nothing]
 required: BugMan.Man[List[Int]]
Note: Nothing <: List[Int], but class Man is invariant in type T.
You may wish to define T as +T instead. (SLS 4.5)
  for { x <- new TraversableOps1[Int] } yield x
          ^
bugReport.scala:31: error: could not find implicit value for parameter foo: BugManifest.CanBuild1[Int,That]
  for { x <- new TraversableOps1[Int] } yield x
          ^
two errors found
```
