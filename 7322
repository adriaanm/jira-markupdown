Okay, I think I got it. I have a working patch but I'm trying to understand why the problem is limited to Function1 and doesn't affect Function2. I have to thank Lukas for clearing things up.

Short explanation:
 - during definition initialization, Scala creates symbols for F$mcI$sp since it finds it in the classpath - it creates 3 symbols - the class (trait), module and module class with Lazy types
 - if something would force .info on the lazy type, it would read the signatures and eliminate the symbol from scope, as it's a synthetic class generated by scala
 - until GenJVM, nobody forces the .info, so the F$mcI$sp class, module and module class symbols are kept in package <root>
 - when specialization creates the correct F$mcI$sp, it overwrites the class symbol, but the module symbol is kept
 - in GenJVM, the addInnerClass attempts to get the owner class and module, getting the specialization-generated symbol for F$mcI$sp and the lazy type symbol for the module -- and forces .info on it
 - once this happens, the class is read and the signature for F$mcI$sp is set to an incorrect value (see above)

{code}       
phase     before parser (Definition.<init>          specialization                 genJVM

source    ---------------------------------------- trait F -----------------------------------------------------
code                                       \
              / class sym (lazy type)  ----  ----- synthetic F$mcI$sp ------- force .info - signature messed up --- crash
existing  ---<- module sym (lazy type) -------------------------------------- force .info - eliminated
bytecode      \ mclass sym (lazy type) ---------------------------------------------------- eliminated

{code}

A localized solution is to force .info on all members with the same name before creating a specialized version of a class - and this fixes the particular problem - but shouldn't this be done everytime we create a synthetic class?
