Java 7 has added MethodHandle's which can take any arguments types and their result can be cast to any return type.
The signature polymorphism was introduced that "connects this freedom of invocation directly to the JVM execution stack"

Currently the code
{code}
        val mt = MethodType.methodType(classOf[Int]);
        val mh = MethodHandles.lookup().findVirtual(classOf[java.lang.String], "length", mt)
        var  s = mh.invoke("bla").asInstanceOf[Int]
{code}

compiles to 
{code}
        0: getstatic     #17                 // Field java/lang/Integer.TYPE:Ljava/lang/Class;
       3: invokestatic  #23                 // Method java/lang/invoke/MethodType.methodType:(Ljava/lang/Class;)Ljava/lang/invoke/MethodType;
       6: astore_1      
       7: invokestatic  #29                 // Method java/lang/invoke/MethodHandles.lookup:()Ljava/lang/invoke/MethodHandles$Lookup;
      10: ldc           #31                 // class java/lang/String
      12: ldc           #33                 // String length
      14: aload_1       
      15: invokevirtual #39                 // Method java/lang/invoke/MethodHandles$Lookup.findVirtual:(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;
      18: astore_2      
      19: aload_2       
      20: iconst_1      
      21: anewarray     #5                  // class java/lang/Object
      24: dup           
      25: iconst_0      
      26: ldc           #41                 // String bla
      28: aastore       
      29: invokevirtual #47                 // Method java/lang/invoke/MethodHandle.invoke:([Ljava/lang/Object;)Ljava/lang/Object;
      32: invokestatic  #53                 // Method scala/runtime/BoxesRunTime.unboxToInt:(Ljava/lang/Object;)I
      35: istore_3
{code}
has the wrong call in the end, as compiler shouldn't have boxed "bla" to array


The equivalent to java code 
{code}
               MethodType mt = MethodType.methodType(int.class);
                MethodHandle mh = lookup.findVirtual(java.lang.String.class, "length", mt);
                int s = 0;
                s = (int)mh.invoke("bla");
{code}
compiles to this
{code}
      0: invokestatic  #2                  // Method java/lang/invoke/MethodHandles.lookup:()Ljava/lang/invoke/MethodHandles$Lookup;
       3: astore_1      
       4: getstatic     #13                 // Field java/lang/Integer.TYPE:Ljava/lang/Class;
       7: invokestatic  #4                  // Method java/lang/invoke/MethodType.methodType:(Ljava/lang/Class;)Ljava/lang/invoke/MethodType;
      10: astore_2      
      11: aload_1       
      12: ldc           #3                  // class java/lang/String
      14: ldc           #14                 // String length
      16: aload_2       
      17: invokevirtual #6                  // Method java/lang/invoke/MethodHandles$Lookup.findVirtual:(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;
      20: astore_3      
      21: iconst_0      
      22: istore        4
      24: aload_3       
      25: ldc           #15                 // String bla
      27: invokevirtual #16                 // Method java/lang/invoke/MethodHandle.invoke:(Ljava/lang/String;)I
      30: istore        4
{code}
You can see that "bla" in the last call was just forwarded to invoke, without being boxed, and the return value is being treated AS an int, not being casted to it.

Such behaviour should be used when method is marked with @PolymorphicSignature annotation.
