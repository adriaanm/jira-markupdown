To get a handle on this problem, I've implemented a fix in the experimental optimizer http://magarciaepfl.github.com/scala/

As a result:

- all callsites to final methods of traits are emitted as invokestatic
- of the above, those methods additionally marked @inline are inlined too

In the example

{code}
trait T {
  @inline final def m(x: Int) {
    println(x)
  }
}
class C {
  def host(y: T) {
    y.m(7)
  }
}

{code}


The resulting bytecode for {{host()}} is:

{code}
public void host(T);
  Code:
   Stack=2, Locals=3, Args_size=2
   0:	bipush	7
   2:	istore_2
   3:	getstatic	#15; //Field scala/Predef$.MODULE$:Lscala/Predef$;
   6:	iload_2
   7:	invokestatic	#21; //Method scala/runtime/BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer;
   10:	invokevirtual	#25; //Method scala/Predef$.println:(Ljava/lang/Object;)V
   13:	return
{code}

Without the @inline annotation, the bytecode for {{host()}} looks like:

{code}
public void host(T);
  Code:
   Stack=2, Locals=2, Args_size=2
   0:	aload_1
   1:	bipush	7
   3:	invokestatic	#15; //Method T$class.m:(LT;I)V
   6:	return
{code}


With the current optimizer as we know the callsite to {{T.m(Int)}} is emitted as:

{code}
   3:	invokeinterface	#15,  2; //InterfaceMethod T.m:(I)V
{code}

Here's how the new optimizer supports inlining of trait methods, documentation included:

https://github.com/magarciaEPFL/scala/commit/dbf85bfef19e285daa191875338b70f0b64dc20e

