If I annotate a field like so:

@Foo
@BeanProperty
var bar: String = _

... the generated methods getBar and setBar are given the @Foo annotation also. This causes problems for widely used Java libraries that rely on the convention of either the field OR the method being annotated.

Given @BeanProperty's express purpose for Java interoperability, the default behavior for @BeanProperty should be aligned with the prevailing Java convention. The generated getter and setter should *not* have the underlying field's annotations added. 

If a developer wishes to have annotations defined on the Java-visible getter or setter, they should define those methods explicitly in the Scala class, and add the desired annotations manually.

This is not a duplicate of SI-1846 or SI-2245. Those tickets both raise this issue, but request that the problem be addressed by either adding more metadata at the Scala language level, or by providing compiler plugins that add knowledge of the annotations in use. For the @BeanProperty use cases, this is overkill. I am requesting that incorrect compiler behavior be removed.
Having thought about this more, I think that while it would be safe (and correct) to omit a field's annotations on a getter/setter generated by `@BeanProperty` and `@BooleanBeanProperty`, it _would not_ be safe to omit them on the regular Scala generated accessor/mutator (`def x():Foo` and `def x_(foo:Foo)`). I suspect that this would impact Scala's adherence to the Uniform Access Principle, and the assumptions that come with it.

So I now understand why James and Florian's tickets (SI-2245, SI-1846) take the approaches they do. Unfortunately it seems that the UAP and Scala interoperability with Java annotation conventions are mutually conflicting requirements.

Given that, I still feel that this bug is valid in the limited scope of the `@BeanProperty` and `@BooleanBeanProperty` behavior.

Replying to [comment:3 cherro]:
> Having thought about this more, I think that while it would be safe (and correct) to omit a field's annotations on a getter/setter generated by `@BeanProperty` and `@BooleanBeanProperty`, it _would not_ be safe to omit them on the regular Scala generated accessor/mutator (`def x():Foo` and `def x_(foo:Foo)`). I suspect that this would impact Scala's adherence to the Uniform Access Principle, and the assumptions that come with it.

I don't know about the UAP (I don't think that has any relation with annotations), but I do know about the _actual_ trouble with field annotations getting replicated to accessors. JPA, JSR-299, Spring: there are lots of frameworks and standards using annotations to say _inject a value here_. What does it mean to have such an annotation on a getter/accessor? Do you know what these existing frameworks do when they encounter one? I'll tell you: they break.
