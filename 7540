I think this is as-spec'ed, or at least out of scope for the pattern matcher. The pattern gives rise to an equality check one == one, which produces the same error:

{code}
scala> one == one
<console>:11: error: ambiguous reference to overloaded definition,
both method == in class Object of type (x$1: AnyRef)Boolean
and  method == in class Int of type (x: Double)Boolean
match argument types (myx)
              one == one
                  ^
error: type mismatch;
 found   : Double
 required: AnyRef
Note: an implicit exists from scala.Double => java.lang.Double, but
methods inherited from Object are rendered ambiguous.  This is to avoid
a blanket implicit which would convert any scala.Double to any AnyRef.
You may wish to use a type ascription: `x: java.lang.Double`.
{code}
