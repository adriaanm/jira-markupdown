Whoo-whee, that was interesting.

This is damage inflicted by a combination of lossy java interop and the insanity of constructors which take "Object", which isn't so hot in any language.

Notice that TreePath has two public constructors:

  TreePath(Object lastPathComponent)
  TreePath(Object[] path)

So what happens if you say

  new TreePath(Array("abc"))

Overloading resolution has to choose a constructor.  An Array[String] is not an Array[Object] (arrays are not covariant, not in this language) so it chooses the Object constructor, which of course an Array is.

Were there no Object constructor, the expression would not typecheck as Array[String] and the inferencer would choose Array[Object].  But as it is, it's just following orders.

You can work around this by specifying the type.

  new TreePath(Array[Object]("abc"))

or whatever the equivalent is in your code.
{noformat}
scala> val x1 = new TreePath(Array("abc"))
x1: javax.swing.tree.TreePath = [[Ljava.lang.String;@77c16c5f]

scala> val x2 = new TreePath(Array[Object]("abc"))
x2: javax.swing.tree.TreePath = [abc]
{noformat}



