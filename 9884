It is actually different situation when value classes are involved. Let me demonstrate the problem:

{code}
class Foo[T](val x: T) extends AnyVal

class FooFunction extends Function1[Foo[Int], Foo[Int]] {
  def apply(foo: Foo[Int]): Foo[Int] = new Foo(foo.x+1)
}

val f: FooFunction = new FooFunction
val foo = new Foo(12) // foo has erased type Int
f.apply(foo) // no boxing here, we should go straight to apply(I)I method
(f: Function1[Foo[Int], Foo[Int]]).apply(foo) // we need to box into Foo before calling apply(LObject)LObject and then that method unboxes and forwards to apply(I)I
{code}

In this case everything works ok. However, replace Int by Object and you'll see we have a clash, you need two apply's one which assumes you have Foo passed in (and unwraps it) and the other one which assumes you have underlaying content of the method passed in. They have different method bodies but exactly the same signature. That's the problem.
