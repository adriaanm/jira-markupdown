Let's say one wished to find out via reflection (or with direct compiler internals access - the problem isn't limited to reflection) which of an abstract class's methods require implementations. This seems unambitious and realistic. How is one expected to go about it?
```scala
abstract class A           { def f: Int = 1 }
abstract class B extends A { def f: Int     }
abstract class C extends B

/**

// This returns the concrete f owned by A
scala> typeOf[C] member TermName("f")
res0: $r.intp.global.Symbol = method f 

// This returns nothing
scala> typeOf[C] decl TermName("f")
res1: $r.intp.global.Symbol = <none>

// And therefore inspecting all members and all decls of C we
// are never shown a deferred member.

scala> new C { }
<console>:37: error: object creation impossible, since there is a deferred declaration of method f in class B of type => Int which is not implemented in a subclass
              new C { }
                  ^

**/
```
