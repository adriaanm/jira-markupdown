That one is actually fixed (well I have slightly more global change but logic is the same). Unfortunately optimizer has a bug and in situation like:
```scala
trait Foo[T] { val foo: T}

class A extends Foo[Unit]{
  lazy val foo = println("Unit: called A.foo")
}
```

the following call is eliminated during dead code elimination:
```scala
val a: Foo[Unit] = new A
a.foo
```
