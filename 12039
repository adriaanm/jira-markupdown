No, not the same issue; anyway, the other issue progressed.

Overriding without a result type narrows the result to what is inferred for the RHS, i.e., Nothing. There is a ticket to make it not narrow the type,

This isn't something you'd do in real life, but since it's almost Halloween:
{code}
scala> class C { def c: String = "" }
defined class C

scala> class D extends C { override lazy val c = ??? }
<console>:11: warning: dead code following this construct
       class D extends C { override lazy val c = ??? }
                                                 ^
defined class D

scala> class D extends C { override lazy val c: String = (??? : Unit).asInstanceOf[String] }
defined class D
{code}



