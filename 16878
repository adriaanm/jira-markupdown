```scala
class Expr[T] {
  def * (other: Expr[T]): Expr[T] = null
  def *(other: Const[_ <: CC[T]]): Const[CC[T]] = null
}

case class Const[T](value: T) extends Expr[T]
class CC[T]
case class ExtDouble(value: Double) extends CC[Double]

object Test extends App {
  implicit def double2Const[T](value : Double): Const[T] = Const(value.asInstanceOf[T])

  2.0 * Const[ExtDouble](ExtDouble(2.0))
}
```
This code compiles well. Here 2.0 is converted using 'double2Const' method (and type parameters is CC[Double]).
However if you try to use this reference explicitly you will get compilation error. It seems it's unlogical. It would be ok in situation if explicit reference works and implicit not works (however it's also not good situation, except implicit resolution ambiguity).
