There seems to be some inconsistent handling of varargs by Scala. Consider these two classes:
```scala
class X {
  def f(x: AnyRef) = x.toString
  def f(x: AnyRef, y: AnyRef*) = y.mkString(x.toString)
}

class Y {
  def f(x: Int) = x.toString
  def f(x: Int, y: Int*) = y.mkString(x.toString)
}
```

The ambiguity with `f` is resolved differently:
```scala
scala> new X
res0: X = X@442c76

scala> val x : AnyRef = "a"
x: AnyRef = a

scala> res0.f(x)
<console>:8: error: ambiguous reference to overloaded definition,
both method f in class X of type (x: AnyRef,y: AnyRef*)String
and  method f in class X of type (x: AnyRef)java.lang.String
match argument types (AnyRef)
       res0.f(x)
            ^

scala> new Y
res6: Y = Y@9ed91f

scala> res6.f(5)
res7: java.lang.String = 5
```

This problem was brought to my attention by Mockito's `org.mockito.stubbing.OngoingStubbing` interface, which overloads the method `thenReturn` to accept either an `Object`, or both an `Object` and a vararg of them.
