Here's a significantly reduced case:

{code}
trait Z { 
  trait Lower
  trait Upper {
    val result: Z
    def inverse: result.Lower
  }

  def upperObject: Upper
  def lowerPredicate: Lower => Boolean

  def thisOneWorks = {
    val upper = upperObject
    val predicate = upper.result.lowerPredicate
    predicate(upper.inverse)
  }
  
  def butThisOneDoesnt = {
    for (
      upper <- Seq(upperObject);
      predicate = upper.result.lowerPredicate
    ) yield predicate(upper.inverse)
  }
}
{code}

The error is now
{code}
type mismatch;
 found   : upper.result.Lower
 required: upper.result.Lower where val upper: Z.this.Upper
{code}
on the `predicate(upper.inverse)` call in `butThisOneDoesnt`. I included a slight variation under `thisOneWorks` because it looks like the for-loop syntax is somehow involved.
