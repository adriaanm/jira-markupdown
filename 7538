I wonder why we're using an outer namer for parameter accessors.
Commenting out these lines fixes the test case.

{code}
    def namerOf(sym: Symbol): Namer = {
      val usePrimary = sym.isTerm && (
//           (sym.isParamAccessor)
//        ||
        (sym.isParameter && sym.owner.isPrimaryConstructor)
      )

      if (usePrimary) createPrimaryConstructorParameterNamer
      else innerNamer
    }
{code}

Here's a self-contained test case that also makes sure the constructor's type parameters stay in scope.

{code}
class Global {
  class Typer[T]
}

class Reifier[T](global: Global)(typer: global.Typer[T])

object Test {
  def mkReifier[T](global: Global)(typer: global.Typer[T]) = typer
}
{code}
