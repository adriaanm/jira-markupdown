Sorry, I couldn't minimize it further:
```scala
trait InfoSpec {
  type NodeInfo
  type EdgeInfo
}

import collection.immutable.Map

class GraphFun[Spec <: InfoSpec] {
  private type NodeInfo = Spec#NodeInfo
  private type EdgeInfo = Spec#EdgeInfo

  class Node(val info : NodeInfo, val ins : List[Edge], val outs : List[Edge])

  class Edge(val info : EdgeInfo, val b : NodeInfo, val e : NodeInfo)

  private type NMap = Map[NodeInfo, Node]

  class Graph (nodes : NMap) {
    def beg(e : Edge) : Node = apply(e.b)
    def end(e : Edge) : Node = apply(e.e)
    def apply(info : NodeInfo) : Node = nodes(info)
  }
}

class CfgFun[Spec <: InfoSpec] {
  val gfun = new GraphFun[Spec]

  class Cfg(g : gfun.Graph) {
    type Node = gfun.Node
    type Edge = gfun.Edge

    def beg(e : Edge) = g.beg(e)
    def end(e : Edge) = g.end(e)
  }
}

object DFST {
  def apply[Spec <: InfoSpec](cfg : CfgFun[Spec]#Cfg) {
    type Node = cfg.Node
    type Edge = cfg.Edge

    def visit(nodes : List[Pair[Node, List[Edge]]]): Unit = nodes match {
      case Nil => ()
      case (node, Nil)::tl => {
	visit(tl)
      }
      case (node, edge::rest)::tl => {
	val nextNode = cfg.end(edge)
	visit((nextNode, nextNode.outs)::(node, rest)::tl)
      }
    }
    ()
  }
}
```

Compilation produces
```scala
graph.scala:49: error: type mismatch;
 found   : (_13.gfun.Node, List[_13.type#gfun.Edge]) where val _13: CfgFun[Spec]
 required: (Node, scala.List[Edge])
	visit((nextNode, nextNode.outs)::(node, rest)::tl)
                                       ^
one error found
```

The same code successfully compiles with 2.7.7 and rightly so, I think.
