The spec says: "3. Inaselectione.m(args)witheoftypeT,iftheselectormdenotessomemem- ber(s) of T , but none of these members is applicable to the arguments args. In this case a view v is searched which is applicable to e and whose result con- tains a method m which is applicable to args. The search proceeds as in the case of implicit parameters, where the implicit scope is the one of T . If such a view is found, the selection e.m is converted to v(e).m(args)."

As I read it, that translates to "this is a bug."

I thought it might work with an expected type of BigInt, but it does not.  Furthermore, the error message changes, implying that the expected type influences the set of applicable implicits, but not in a coherent way.
{code}
scala> def g: BigInt = 5 + BigInt(4)
<console>:7: error: overloaded method value + with alternatives:
  (x: Long)Long <and>
  (x: Int)Int <and>
  (x: Char)Int <and>
  (x: Short)Int <and>
  (x: Byte)Int
 cannot be applied to (scala.math.BigInt)
       def g: BigInt = 5 + BigInt(4)
                         ^

scala> def g = 5 + BigInt(4)
<console>:7: error: overloaded method value + with alternatives:
  (x: Double)Double <and>
  (x: Float)Float <and>
  (x: Long)Long <and>
  (x: Int)Int <and>
  (x: Char)Int <and>
  (x: Short)Int <and>
  (x: Byte)Int <and>
  (x: String)String
 cannot be applied to (scala.math.BigInt)
       def g = 5 + BigInt(4)
                 ^

{code}
