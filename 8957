Back to the example in [#comment-61651]. Here's the javap:
```
public void main(java.lang.String[]);
  Code:
   0:   new     #16; //class scala/runtime/ObjectRef
   3:   dup
   4:   iconst_4
   5:   istore_3
   6:   aconst_null
   7:   goto    12
   10:  pop
   11:  aconst_null
   12:  pop
   13:  aconst_null
   14:  invokespecial   #19; //Method scala/runtime/ObjectRef."<init>":(Ljava/lang/Object;)V
   17:  astore_2
   18:  new     #21; //class Test$$anonfun$main$1
   21:  dup
   22:  aload_2
   23:  invokespecial   #24; //Method Test$$anonfun$main$1."<init>":(Lscala/runtime/ObjectRef;)V
   26:  pop
   27:  return
  Exception table:
   from   to  target type
     6    10    10   any
```

Two blocks (B1 and B2) get merged at instruction 12. B1 comprises instructions [0 to 7] and B2 (an exception handler) [10 to 11].

On exit from B1, the stack is `[ObjectRef ObjectRef null]`
On exit from B2, the stack is `[null]`
Therefore the VerifyError `Inconsistent stack height 1 != 3`

Usually `liftTree()` in `UnCurry` avoids the situation above, by creating a local method for the try expression:
```
 *  - convert try-catch expressions in contexts where there might be values on the stack to
 *      a local method and a call to it (since an exception empties the evaluation stack):
 *
 *      meth(x_1,..., try { x_i } catch { ..}, .. x_b0) ==>
 *        {
 *          def liftedTry$1 = try { x_i } catch { .. }
 *          meth(x_1, .., liftedTry$1(), .. )
 *        }
```

That would have saved the day.
