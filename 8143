It looks like BigDecimal(a).hashCode is *not* constant for whole values of a > Long.MaxValue, which is contrary to what I had thought.  It turns out that BigDecimal(a).hashCode == 0 where !BigDecimal(a).isWhole && (a > Double.MaxValue || a < Double.MinValue).  But, determining that we need to get into that case still requires the isWhole check.

I would argue that BigInt and BigDecimal are being too aggressive with their large-value hashCodes.  Honestly, if someone has a number that large, they've pretty much given up on efficiency.  Let them deal with the hash collisions.  This is especially valid (imo) in light of the fact that hashes will *always* collide for non-whole values greater than Double.MaxValue.  Given that this avoids the call to isWhole altogether for sufficiently large-magnitude BigDecimal/BigInt values, it bypasses the performance issues with isWhole.
