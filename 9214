The sealedness doesn't prevent others from making additional singleton types.

The following should be exhaustive, but the types can't convey that.
```scala
import enum._
val B4 = (B3: Bippy)
def m(b: B) = b match {
  case _: B1.type | _: B2.type | _: B4.type =>
}
```

It seems like we would need fully blown uniqueness types for this scheme to work.
