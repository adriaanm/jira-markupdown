```scala
class A { // Will work with trait.
  def a = "super"
}
class B extends A {
  class M {
    def z = "child" + B.super[A].a // B.super[A], not super[A]
  }
  override def a = ""
}

object Test {
  def main(args: Array[String]): Unit = {
    val b = new B
    val z = new b.M
    println(z.z)
  }
}
```
```
scala3 Test
java.lang.VerifyError: (class: B$M, method: z signature: ()Ljava/lang/String;) Illegal use of nonvirtual function call
	at Test$.main(a.scala:17)
	at Test.main(a.scala)
```


Note, there are two work-arounds that solve this problem. One specific to this bug report and one more general.

The specific one is
```scala
class B extends A {
  class M {
    def z = "child" + B.super.a // B.super, not B.super[A]
 }
  override def a = ""
}
```

That works because this bug is only triggered when there is a type qualifier on a super access to an outer class. Get rid of the type qualifier and it's all good. But it's not fully general if you need to decide among several different sources for 'a'.

The more general work around is to manually do your own accessor
```scala
class B extends A {
  class M {
    def z = "child" + a_a // access using a hand-written accessor
 }
  override def a = ""
  private[this] def a_a = super[A].a
}
```
