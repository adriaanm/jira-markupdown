Hi.

To confirm in 2.7.5:

{code}
class C {
  @ann val x = [..]

  def getX = x
}
{code}

works fine, but in 2.8.0 one of the following two solutions must be used:

{code}
class C {
  val x = [..]

  @ann
  def getX = x
}
{code}

or

{code}
class C {
  @ann
  @BeanProperty val x = [..]
}
{code}

This is when using JPA and hibernate.

Regards,

 -- Ross

Replying to [comment:5 rytz]:
> To make sure I understand correctly (please confirm). Are you saying that:
> 
> {code}
> class C {
>   @ann val x = [..]
>   
>   def getX() = x
> }
> }}
> 
> In 2.7.5, the annotation {{@ann}} is added to the {{getX}} method. In 2.8.0 this is not the case, there it only happens when using {{@BeanProperty}} instead of manually adding the bean getter.
> 
> 
> Note that this behavior is likely to change so that by default none of the synthetic getters/setters will have the annotations of the field, see http://www.nabble.com/-scala--field-annotations%2C-getters-setters-and-BeanProperty-td24970781.html
> 
> 
> 
> 
> Replying to [comment:4 rossputin]:
> > Hi.
> > 
> > I have played around with different combinations and ideas, and have figured out what is occurring.
> > 
> > With 2.7.5 it is ok to define an annotation on a field, where there is no @BeanProperty annotation, and getters and setters are coded manually.
> > 
> > With 2.8.0, the annotation must either be placed on the manually coded getter method, or, it must be placed on the field, and getters and setters must be created using the @BeanProperty.
> > 
> > It is fine for me to use @BeanProperty so I am taking that approach.  What caught me out is the change in behaviour from 2.7.5 to 2.8.0.
> > 
> > I will copy this explanation across to the post on the mailing list.
> > 
> > Regards,
> > 
> >  -- Ross
