```scala
trait Foo
trait Super {
  def bar(foo: Foo): AnyRef = null
}

object Blub extends Super {
  def bar()(implicit foo: Foo): Int = throw new RuntimeException("BAM!")

  def main(args: Array[String]): Unit =
    println(bar(null))
}
```

In bytecode both methods `bar` have the same signature but for the return-type. The call to `bar(null)` is statically dispatched to the wrong method if the target method is defined in the superclass.

Discovered by [~sirthias].
