You can however work around it using implicits (once the fix for SI-2261 is in trunk -- you can get it now from my github: http://github.com/adriaanm/scala/commits/ticket/2261). Using the compiler in my working copy:

{code}
dhcp-10-9-32-075:tmp adriaan$$ /Users/adriaan/git/scala-mirror/build/quick/bin/scala
Welcome to Scala version 2.8.0.r0-b20090826112135 (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_13).
Type in expressions to have them evaluated.
Type :help for more information.

scala> trait F[I]
defined trait F

scala> class FInt extends F[Int]
defined class FInt

scala> class FString extends F[String]
defined class FString

scala> class Wrapper[I, Fx](implicit val w: Fx <:< F[I])
defined class Wrapper

scala>   implicit def foo[Fx, I](t: Fx)(implicit w: Fx <:< F[I]): Wrapper[I,Fx] = null.asInstanceOf[Wrapper[I,Fx]]
foo: [Fx,I](t: Fx)(implicit w: <:<[Fx,F[I]])Wrapper[I,Fx]

scala> foo(new FInt)                                                                                              
res1: Wrapper[Int,FInt] = null
{code}

Note the inferred return type for `res1`!  

`<:<` is nothing special, BTW:

{code}
  sealed abstract class <:<[-From, +To] extends (From => To)
  implicit def conforms[A]: A <:< A = new (A <:< A) {def apply(x: A) = x}
{code}
