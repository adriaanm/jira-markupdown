So, I have a small update.

As I said in the last comment, the LAZY flag was being removed. In addition, the ACCESSOR flag was also being removed. Once I got those fixed, I moved on to the next error (I have attached a patch that fixes that issue).

At that point, the problem is that C$mcI$sp.b$mcI$sp() isn't given the same "lazy method" block that C.b() has. This causes a MatchError in the mixin phase later. Compare:

{code}
// generic b() is fine
class C ... {
    <method> <stable> <accessor> lazy <triedcooking> def b(): scala.this.Tuple2[A,A] = {
      C.this.b = new scala.this.Tuple2[A,A].<init>(C.this.a, C.this.a);
      C.this.b
    };
}

// specialized b$mcI$sp() is broken
class C$mcI$sp ... {
    <method> <stable> <accessor> lazy <specialized> <triedcooking> def b$mcI$sp(): scala.this.Tuple2[scala.this.Int,scala.this.Int] = C$mcI$sp.this.b$mcI$sp;
}
{code}

I think that if we can get the body of b$mcI$sp() to look more like the body of b(), which really just means assigning a tuple to the b$mcI$sp field, then things might work.

Looking into this further.
