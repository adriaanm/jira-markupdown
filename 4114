>  In addition to making little sense, this intersection type is transformed in different ways - erased to the most specific type of the two (LockingTypeCompleter), which looks good; instead the generic signature contains simply the first component of the intersection; i.e., A with B becomes A in the generic signature even if B <: A).

No, I don't think this quite captures the problem.  Given this situation:

abstract class A 
trait B extends A

In scala B <: A, but that relationship is only known to scala and can't be expressed in the method descriptor.  If the descriptor says "B", scala is attempting to say "some unknown class which extends A and implements B" but all java is going to hear is "B", which does not include A.  So it is not clear that B is the most specific type, at least not usefully so.
{code}
abstract class Foo

trait Bar1
trait Bar2 extends Foo
trait Bar3 { self: Foo => }

class Test {
  def f1 = new Foo { }
  def f2 = new Foo with Bar1 { }
  def f3 = new Foo with Bar2 { }
  def f4 = new Foo with Bar3 { }

  // descriptors:
  // public Foo f1();
  // public Foo f2();
  // public Bar2 f3();
  // public Foo f4();
}
{code}
