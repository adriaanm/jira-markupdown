It turns out to be even simpler than all this discussion. So simple I feel quite stupid for not seeing it the first time through. The original problem was that var x = try {...} catch {...} works fine but that var x = { blah; try{...} catch{...} does not. Well, in lambda lift there's a transformation that turns var x = try {block} catch {case blah => catchBlock} into var x = try {new Ref(block)} catch {case blah => new Ref(catchBlock)}. But that didn't catch the case where x was initialized from a block. The fix is easy. Just look at a block used for captured var assignment and do the same rewrite on the block's result expression. Do it recursively since we could have var x = {blah {blurg { try...}}.
