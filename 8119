I looked at the code. The issue seems to be that {{Vector#isEmpty}} uses {{IterableLike}}'s implementation {{!iterator.hasNext}}.

This in turn invokes `Vector#iterator`, which does a lot of work:
```scala
  @inline override def iterator: VectorIterator[A] = {
    val s = new VectorIterator[A](startIndex, endIndex)
    initIterator(s)
    s
  }
```

Using `Vector#length` to implement `Vector#isEmpty` seems to make sense, because it is only a comparison and an arithmetic operation:   def length = `def length = endIndex - startIndex`
