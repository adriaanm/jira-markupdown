Here is a patch that fixes this bug, as well as similar bugs in hash
values for collections.  I did *not* put this under -Ymurmur, since
it involves a number of changes to the library to fix other equally
bad hashing problems there.

This patch is *not* ideal for speed, since it would take me prohibitively
long to figure out how to correctly generate a synthetic method for case
classes.  For reference, case classes should generate the equivalent of
the following code:
```scala
  import scala.util.MurmurHash3._
  var h: Int = startHash( MyCaseClass.hashSeed )
  h = nextHash(h, firstParam.##, storedMagicA(0), storedMagicB(0))
  ...
  h = nextHash(h, lastParam.##, storedMagicA(n-1), storedMagicB(n-1))
  finalizeHash(h)
```

Note that the companion object should store a `hashSeed` for the case class.  It should probably hash the string of the case class name

(It might be even faster to generate the magic streams of integers in
the compiler and put the constants into the code.)

I am happy to review someone else's work in this regard.  But given that
I don't have enough spare time to learn that much about how to generate
a synthetic method with nontrivial parse trees, I've just updated the
generic method for Product.

This is still plenty fast, I think.  The collections are all faster,
and we've only lost about 30% with small tuples.  And everything is
much, much better distributed.


Benchmarks:
  1. Compiler build speed test (shorter is better)
    a. Pre-patch (24065) ant clean ; ant = 4m 33s +- 1
    a. Post-patch                        = 4m 29s +- 1
    a. Pre-patch initial build on slow scala-free machine = 57m 01s
    a. Post-patch                                         = 52m 53s

  2. Accuracy tests (lower is better)
    a. 2M 4-char strings (not replaced, could be called by user)
      i. Default collision rate = 70.44%
      i. New collision rate     =  0.03%
    a. 1M lists of lists of binary values
      i. Pre-patch collision rate = 92.43%
      i. Post-patch               =  0.01%
    a. 1M sets which are subsets of the numbers 1 to 20
      i. Pre-patch collision rate = 99.98%
      i. Post-patch               =  6.88%
    a. 2M nested tuples
      i. Pre-patch collision rate = 60.27%
      i. Post-patch               =  0.03%

  3. Speed tests (higher is better)
     a. Lists of lists of binary values
       i. Pre-patch hash rate = 3.6 M/s  +- 0.1
       i. Post-patch          = 4.8 M/s  +- 0.2
     a. Subsets of {1,...,20}
       i. Pre-patch hash rate = 2.0 M/s  +- 0.1
       i. Post-patch          = 2.6 M/s  +- 0.3
     a. Random small nested tuples
       i. Pre-patch hash rate = 3.5 M/s  +- 0.1
       i. Post-patch          = 2.8 M/s  +- 0.2

Two files are attached.

mm3_patch_24071.diff can be used to patch the code.  It's made against 24071 (which doesn't actually build on my system; I built against 24065, but that shouldn't matter since the relevant code hasn't been changed since).

HashSpeedTest.scala can be used to look at the hashing performance of different implementations.  It is memory-hungry, as it builds large sets of objects to hash before hashing them (object creation is generally slower than hashing, so I wanted to separate the two); I ran it with -Xmx6G.
