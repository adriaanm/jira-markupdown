Replying to [comment:3 odersky]:
> It's a potential implicit tuple conversion which makes the difference here. A single AnyRef can take all the other arguments as a tuple.

I ask this to be reviewed, please, as this doesn't match what is happening. For example:
```scala
scala> class X {
     |   def f(x: AnyRef) = x.toString
     |   def f(x: AnyRef, y: AnyRef*) = y.mkString(x.toString)
     | }
defined class X

scala>

scala> new X
res0: X = X@1cdc190

scala> val x : AnyRef = "a"
x: AnyRef = a

scala> res0.f(x, x)
res1: String = a
```

If `(x, x)` being converted into a tuple caused problems, then the above wouldn't have worked. However, not only it worked, but it choose the vargargs definition, indicating no tuple conversion happened.

The problem only happens when a **single** parameter is passed, so I fail to see why would any conversion to tuple come into play, or why would it matter in selecting the function even if it did.
