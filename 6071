I think I've found the problem: ByteCodecs expects bytes in modified UTF-8 encoding, used in Java class files. Annotation string is encoded in pure UTF-8 (not modified). The only interesting difference between this formats is encoding of 0x00, but since it doesn't appear so often, this difference is easily overlooked.

I think it is a good idea to add decodeUTF8(bytes: Array[Byte]) to ByteCodecs and document the difference with decode(..). Implementation might look like this:
```scala
def min1(src: Array[Byte]) {
  var i = 0
  val srclen = src.length
  while (i < srclen) {
    val in: Int = src(i) & 0xff
    if (in == 0x00) {
      src(i) = 0x7f
    } else {
      src(i) = (in - 1).toByte
    }
    i += 1
  }
}

def decodeUTF8(xs: Array[Byte]): Int = {
  min1(xs)
  decode7to8(xs, xs.length)
}
```
