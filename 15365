Types and objects allow different case constructs in match expressions. In particular a type can be used in a so called "typed pattern" (case x: B => ...) whereas an object can not. It would be good, if an object could be used in a similar way. Otherwise, if an object is changed into being a class, all corresponding match expressions have to be adjusted.

Example:


{code}
trait Trait
object A extends Trait
class B(b: Int) extends Trait

object Test {

  def test = {
    val t: Trait = null
    t match {
      case A => println("A")
      //case x: A => println("A") // error
      case x: B => println("B")
    }
  }

}
{code}
