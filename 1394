Can you elaborate on why you would expect a warning here? isInstanceOf issues warnings about erasure because you're asking the type system for information it may not have.  There's no symmetry with asInstanceOf, where you are telling the type system rather than asking.

You get a ClassCastException in this example because you casted it to something it isn't.  I think a more applicable example is:
```scala
class A
class B extends A

object Up extends Application {
  val l:HashSet[A]=new HashSet[A]
  l+=new B
  val l2=l.asInstanceOf[HashSet[B]]

  for (x <- l2) println(x)
}
```
This works fine, as expected, and would surely not benefit from a warning.
