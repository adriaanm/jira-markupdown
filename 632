Replying to [comment:8 harrah]:
> The patch I added for scala/bug#3887 causes 1) and 2) in the first comment to behave as specified ( == called on the pattern).  The dependent case analysis presented in this bug appears to no longer work.  That is, the first example gives the same compile error as the second.

Can you clarify what is no longer working? I can't tell what you are referring to.  I find about the same behavior for everything I tried.
```scala

scala> trait T[X]
defined trait T

scala> object O extends T[Int]
defined module O

scala> def f[X] : T[X] => X = { case O => 42 }
f: [X](T[X]) => X

scala> val V = new T[Int] { }
V: java.lang.Object with T[Int] = $$anon$$1@50ec2522

scala> def g[X] : T[X] => X = { case V => 42 }
<console>:7: error: type mismatch;
 found   : Int(42)
 required: X
       def g[X] : T[X] => X = { case V => 42 }
                                          ^

scala> def g[X] : T[X] => X = { case _ : V.type => 42 }
g: [X](T[X]) => X

scala> g(V)
res0: Int = 42
```
