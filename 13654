The following fails with a type mismatch:
{code}
object Foo
val f: Option[Foo.type] = Some(Foo)
{code}

but succeeds with extra type annotation:
{code}
val f: Option[Foo.type] = Some[Foo.type](Foo)
{code}

This is annoying and I wish it were different :) Especially for the case with multiple type parameters, all of which can be inferred except for the singleton...

