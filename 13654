The following fails with a type mismatch:
```scala
object Foo
val f: Option[Foo.type] = Some(Foo)
```

but succeeds with extra type annotation:
```scala
val f: Option[Foo.type] = Some[Foo.type](Foo)
```

This is annoying and I wish it were different :) Especially for the case with multiple type parameters, all of which can be inferred except for the singleton...
