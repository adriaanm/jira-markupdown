I thought I understood until I heard the sound of cosmic snickering.

The reporter says it works in Java, but does that mean 1 or 2?  I can't tell from Paul's comment or the bug report. The answer is 1 for both calls.  The reason is that, for backward compatibility, Java does fixed-arity first, and vari-arity third (JLS 15.12.2.4).  It never gets around to looking at specificity.

Here is the sample. JPA is already a PITA without the extra ambiguity.
```scala
/*
 * AbstractQuery<T> where(Expression<Boolean> restriction)
 * AbstractQuery<T> where(Predicate... restrictions)
 *
def f(x: X) = ???
def f(ys: Y*) = ???
 */
object Test {
  type Result = String
  def main(args: Array[String]) {
    import javax.persistence.criteria.{AbstractQuery, Expression, Predicate}
    val p: Predicate = null
    val q: AbstractQuery[Result] = null
    q.where(p)
  }
}
```

The Java spec takes 25 pages to cover what the Scala spec does in a page or two, less if you leave out the example.  It really is the phone book versus T. S. Eliot.

Here is an interpretation: picture the domains of the two functions as a Venn diagram (if you will). f1 is as specific as f2 means that domain of f1 is a subset of domain of f2, i.e., f2 can be applied to anything f1 can.  For B <: A, it's easy to see that f1(B) isAsSpecific as f2(A), but not conversely.

What about f1(B*)?  Although you can apply f2(b: B), you can't f2(b, b) [etc].  For specificity, it doesn't matter that all we're asking to do is f(b: B).  You should be able to tell which of two methods is more specific just by looking at them.  We can do that, right?

The subtyping in the example shows why this is simple and good, and that the Book is rich with wisdom. It's easy to think that f1(B*) is the intended target; but in the JPA API, they intend to distinguish a single restriction from multiple.  This is more exactly expressed as is required in Scala:
```scala
def f1(b1: B, b2: B, bs: B*)  // supply two or more bees

// is there any momentum to introduce syntax?
def f1(bs: B{2,})  // two or more!  enuf said
```

The temptation is to say: if the applicable alternatives are f1(B*) and f2(A), then the fixed-arity of f2 suggests we should compare f1(B) with f2(A). "Come on, I'm passing you a B!  One B!"  But it's actually simpler just to remember that vari-arity is never as specific as fixed-arity.

Duh, says the universe.

An alternative solution, of course, is to reject programs which are remotely confusing.
```scala
$ scalac -Yask-why t4728.scala
t4728.scala:16: error: why would you even do that?
```


