Eugene brought up "why not make implicitly a macro" mentioning
```scala
  @inline def implicitly[T](implicit e: T) = e
  @inline def locally[T](x: T): T  = x
```
I threw in some more
```scala
  def manifest[T](implicit m: Manifest[T])           = m
  def classManifest[T](implicit m: ClassManifest[T]) = m
  def optManifest[T](implicit m: OptManifest[T])     = m
  def identity[A](x: A): A         = x    // @see `conforms` for the implicit version

  private[this] final val singleton_<:< = new <:<[Any,Any] { def apply(x: Any): Any = x }
  private[this] final val singleton_=:= = new =:=[Any,Any] { def apply(x: Any): Any = x }

As well as every method of the form

  def foo(implicit x: Bar) = x

such as classTag, Ordering#apply, etc.
```
And I continued to blather in https://groups.google.com/d/topic/scala-internals/iltzDFqS_ZE/discussion 
```
"Anytime the runtime residue of source code is nothing but a call to one
of our many choices of identity function, it is semantically a compile-time
 construct. The existence  of runtime artifacts is an accident of
implementation and history. Given the power to do so in a principled
way - something we have with macros - we should eliminate all of them."
```
