Okay, I've looked at the code and it appears to be assuming that importing the implicit `Integral[Double]` methods in `DoubleAsIfIntegral`:
```scala
  trait DoubleAsIfIntegral extends DoubleIsConflicted with Integral[Double] {
    def quot(x: Double, y: Double): Double = (BigDecimal(x) / BigDecimal(y)).doubleValue
    def rem(x: Double, y: Double): Double = (BigDecimal(x) remainder BigDecimal(y)).doubleValue
  }
```

 will enable `BigDecimal` precision on the `NumericRange` `foreach` definition:
```scala
  override def foreach[U](f: T => U) {
    var count = 0
    var current = start
    while (count < length) {
      f(current)
      current += step
      count += 1
    }
  }
```

But Integral does not have any impact on addition and therefore does nothing here.

I hope this is helpful to someone as I'm mostly guessing now!
