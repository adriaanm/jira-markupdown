Calling the same compiled Scala code with {{"scala CLASSNAME"}} and from
the REPL results in different runtime performance.  

The the following simple loop speed test was used.

{{ForLoopScala.scala}}:

{code}
object ForLoopScala {
  def run(): Unit = {
    val t1 = java.lang.System.nanoTime()
    var x:Int = 0
    for (i <- 1 to 1000000000) x = x/2+5
    val t2 = java.lang.System.nanoTime()
    val totalTime = (t2 - t1) * 1E-9d
    println("result = " + x + ", time = " + totalTime)
  }

  def main(args: Array[String]) {
    while (true) {
      run()
      Thread.sleep(1000)
    }
  }
}
{code}

Compiling the class with scalac and executing from console yield the following
runtime behaviour:

{code}
$$ scalac ForLoopScala.scala && scala ForLoopScala

result = 9, time = 2.891358464
result = 9, time = 2.8058508900000003
result = 9, time = 2.797509938
result = 9, time = 2.798401755
result = 9, time = 2.797242445
{code}


Calling the same compiled class from the REPL is significantly slower:

{code}
$$ scala
Welcome to Scala version 2.8.0.final (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_20).

scala> ForLoopScala.main(Array.ofDim[String](0))
result = 9, time = 9.13641963
result = 9, time = 7.214275783000001
result = 9, time = 7.212255825000001
result = 9, time = 7.213397081
result = 9, time = 7.210866085
{code}

Does the REPL re-tune the JVM differently?

I'm not quite sure what's the correct category for this, so I'm putting it as a defect under "Interpreter and scripts". Is it even a defect? :-)


As a side note, a simple translation to Java also produces
interesting results:

{{ForLoopJava.java:}}

{code}
class ForLoopJava {
	static void run() {
		long t1 = java.lang.System.nanoTime();
		int x = 0;
		for (int i = 0; i < 1000000000; ++i) x = x/2+5;
		long t2 = java.lang.System.nanoTime();
		double totalTime = (t2 - t1) * 1E-9d;
		System.out.println(x);
		System.out.println("result = " + x + ", time = " + totalTime);
	}

	public static void main(String[] args) {
		while (true) {
			run();
			try {Thread.sleep(1000);}
			catch(Exception e) {}
		}
	}
}
{code}

{code}
$$ javac ForLoopJava.java && java ForLoopJava

result = 9, time = 2.7969517120000003
result = 9, time = 4.452042181
result = 9, time = 9.400000000000001E-8
result = 9, time = 9.400000000000001E-8
result = 9, time = 1.08E-7
{code}

Obviously, in the Java case, Hotspot is able to pull some trick after the
second iteration it can't do with the scala-generated bytecode.


System information:
{code}
$$ scala -version
Scala code runner version 2.8.0.final -- Copyright 2002-2010, LAMP/EPFL

$$ java -version
java version "1.6.0_20"
Java(TM) SE Runtime Environment (build 1.6.0_20-b02)
Java HotSpot(TM) 64-Bit Server VM (build 16.3-b01, mixed mode)

$$ uname -a
Linux host 2.6.31-22-generic SI-63-Ubuntu SMP Thu Aug 19 00:23:50 UTC 2010 x86_64 GNU/Linux
{code}

This is a side effect of the way the repl constructs objects, which inhibits methods from being jitted under some circumstances.  I feel safe in saying this based on the following.  It's the same code as above, but only 10000000 in the for loop so it would finish before I died.
{code}
% JAVA_OPTS="-Xint" scala ForLoopScala
result = 9, time = 3.3298810000000003
result = 9, time = 3.2232250000000002
result = 9, time = 3.208788
result = 9, time = 3.200161  
{code}
{code}
% JAVA_OPTS="-Xint" scala 
Welcome to Scala version 2.8.0.r22873-b20100901025938 (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_20).
Type in expressions to have them evaluated.
Type :help for more information.

scala> ForLoopScala.main(null)
result = 9, time = 3.319741
result = 9, time = 3.3183130000000003
result = 9, time = 3.3227290000000003
result = 9, time = 3.3129000000000004  
{code}
So this is not a bug per se.  It would be nice to avoid if we can, but patches will speak a lot more loudly than anything else: I don't have any personal ambition to soothe hotspot here.  Classifying as enhancement.
Yes, sounds more like an enhancement. Just for completeness, it did a
test with both console and REPL execution with and without JIT
(with a loop count of 1000000000):

{code}
$$ JAVA_OPTS="-Xint" scala ForLoopScala
result = 9, time = 65.265610952
result = 9, time = 55.893074631000005
{code}

{code}
$$ scala ForLoopScala
result = 9, time = 2.9020234250000003
result = 9, time = 2.79929184
{code}

{code}
$$ JAVA_OPTS="-Xint" scala
Welcome to Scala version 2.8.0.final (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_20).
scala> ForLoopScala.main(null)                                         
result = 9, time = 66.21106567300001
result = 9, time = 55.831634802
{code}

{code}
$$ scala
Welcome to Scala version 2.8.0.final (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_20).
scala> ForLoopScala.main(null)
result = 9, time = 7.293394846000001
result = 9, time = 7.212990617000001
{code}

So the method is jitted under the REPL, too, just not as effective?
Will this affect only objects constructed directly by the REPL, or
also objects constructed further down the line?

Sorry, I'm not an expert in the area - so I hope someone with a lot more
low-level JVM knowledge than I have will provide a patch some day. :-)

Just for fun:

{code}
apm@mara:~/tmp$ scalam rawj.ForLoopScala
result = 9, time = 3.8048057450000003
result = 9, time = 3.808091799
result = 9, time = 3.7814994810000004

apm@mara:~/tmp$ scalam
Welcome to Scala version 2.11.0-M8 (OpenJDK 64-Bit Server VM, Java 1.7.0_25).
Type in expressions to have them evaluated.
Type :help for more information.

scala> rawj.ForLoopScala main null
result = 9, time = 3.8105778540000004
result = 9, time = 3.810002089
result = 9, time = 1.036180522
result = 9, time = 1.037156672

// edit foreach to while loop

scala> rawj.ForLoopScala main null
result = 9, time = 2.488696908
result = 9, time = 2.415306831
result = 9, time = 1.48E-7
{code}

This ticket duplicates either foreach optimization or custom REPL wrapping.
