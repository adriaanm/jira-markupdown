But

{code}
scala> val a= Float.NaN
a: Float = NaN

scala> val b = Float.NaN
b: Float = NaN

scala> a.equals(b)
res0: Boolean = true

scala> Float.NaN equals Float.NaN
res1: Boolean = true
{code}

And, at least, Float.NaN can be put in HashMap in Java.

Float.NaN/Double.NaN is used a lot in scientific computing, since it's the only number that keeps same value (NaN) upon any operations. 

The problem I see is that when any class/object contains or deeply contains some fields which can be filled with Float.NaN, may suffer from it.
