The problem here is exacerbated because someone believed javadoc that said you should use `BigDecimal.valueOf` to create `BigDecimal`s.  (Unfortunately the justification given in javadocs is that it goes through the string representation!)

This keeps you consistent with the printed-out version of your doubles, but it doesn't keep you consistent in any other way.  All your internal numbers may be randomly different from each other (after a bit of math).

I recommend switching to purely non-string-based conversions wherever possible.

Here's an example of the problem as it currently exists:
```scala
val l = (1L << 62L)
val d = l.toDouble
l == d // true
BigDecimal(l) == BigDecimal(d)  // false?!
l == BigDecimal(l)  // true
d == BigDecimal(d)  // false?!
```

To recover transitivity of equals, it is necessary to switch away from taking the `doubleValue.toString` representation as the canonical one for initializing `BigDecimal`.

Unfortunately, if people are relying upon this strange string conversion thing for BigDecimal, changing it could break e.g. financial software.  That's generally something you don't want broken.
