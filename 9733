A workaround is to also inspect the annotations of the underlying field. You must try both the accessor *and* the underlying field.

{code}
  /code/gist/5724506-SI-7561 tail -n 1000 *.scala
==> Consumer.scala <==
package cons

import mac._

class Bar {
  @fancy val k: Int = 5
  def k$fancy: Int = ???
}


class Consumer {
  val f: Foo = new Foo
  val b: Bar = new Bar
  Rewrite.rewrite(f.k)
  Rewrite.rewrite(b.k)
}

class Foo {
  @fancy val k: Int = 5
  def k$fancy: Int = ???
}

==> Rewrite.scala <==
package mac

@scala.annotation.meta.getter
class fancy extends scala.annotation.StaticAnnotation

object Rewrite {
  import scala.language.experimental.macros
  import scala.reflect.macros.Context

  def rewrite[A](a: A) = macro rewriteImpl[A]
  def rewriteImpl[A: c.WeakTypeTag](c: Context)(a: c.Expr[A]): c.Expr[A] = {
    import c.universe._


    def accessedOrSelf(s: Symbol) = if (s.isTerm) s.asTerm.accessed orElse s else s

    // workaround for SI-7561. The namer phase in Scalac creates a getter symbol
    // derived from the primary symbol (the field) of a ValDef tree. Only the primary
    // symbol reads annotations in its type completer.
    //
    // When typechecking the enclosing template, the annotations from the primary
    // symbol are copied or moved to the derived symbols, based on meta-annotations
    // like @getter. But a macro could easily observe the symbols before this stage
    // and see a getter without annotations.
    //
    // This method searchs all annotations on the given symbol (perhaps an accessor)
    // and its underlying field for one that matches `f`
    def isAnnotated(s: Symbol)(f: AnnotationApi => Boolean) = {
      def check(s: Symbol) = s.annotations.exists(f)
      Set(s, accessedOrSelf(s)).exists(s => check(s))
    }

    val fancySym = weakTypeOf[fancy].typeSymbol

    def isFancy(a: AnnotationApi) = a.tpe.typeSymbol == fancySym

    val t = a.tree match {
      case sel @ Select(qual, name) if isAnnotated(sel.symbol)(isFancy) =>
        val result = Select(qual, newTermName(name + "$fancy"))
        println(s"rewriting $sel to $result")
        result
      case s => s
    }

    c.Expr[A](t)
  }
}
{code}

{noformat}
% scalac -version
Scala compiler version 2.10.3 -- Copyright 2002-2013, LAMP/EPFL

% scalac ./Rewrite.scala && scalac -Xprint:parser,typer Consumer.scala
[[syntax trees at end of                    parser]] // Consumer.scala
package cons {
  import mac._;
  class Bar extends scala.AnyRef {
    def <init>() = {
      super.<init>();
      ()
    };
    @new fancy() val k: Int = 5;
    def k$fancy: Int = $qmark$qmark$qmark
  };
  class Consumer extends scala.AnyRef {
    def <init>() = {
      super.<init>();
      ()
    };
    val f: Foo = new Foo();
    val b: Bar = new Bar();
    Rewrite.rewrite(f.k);
    Rewrite.rewrite(b.k)
  };
  class Foo extends scala.AnyRef {
    def <init>() = {
      super.<init>();
      ()
    };
    @new fancy() val k: Int = 5;
    def k$fancy: Int = $qmark$qmark$qmark
  }
}

rewriting Consumer.this.f.k to Consumer.this.f.k$fancy
rewriting Consumer.this.b.k to Consumer.this.b.k$fancy
[[syntax trees at end of                     typer]] // Consumer.scala
package cons {
  import mac._;
  class Bar extends scala.AnyRef {
    def <init>(): cons.Bar = {
      Bar.super.<init>();
      ()
    };
    private[this] val k: Int = 5;
    @mac.fancy <stable> <accessor> def k: Int = Bar.this.k;
    def k$fancy: Int = scala.this.Predef.???
  };
  class Consumer extends scala.AnyRef {
    def <init>(): cons.Consumer = {
      Consumer.super.<init>();
      ()
    };
    private[this] val f: cons.Foo = new Foo();
    <stable> <accessor> def f: cons.Foo = Consumer.this.f;
    private[this] val b: cons.Bar = new Bar();
    <stable> <accessor> def b: cons.Bar = Consumer.this.b;
    Consumer.this.f.k$fancy;
    Consumer.this.b.k$fancy
  };
  class Foo extends scala.AnyRef {
    def <init>(): cons.Foo = {
      Foo.super.<init>();
      ()
    };
    private[this] val k: Int = 5;
    @mac.fancy <stable> <accessor> def k: Int = Foo.this.k;
    def k$fancy: Int = scala.this.Predef.???
  }
}
{noformat}
