This takes quite long time to compute:
val l = (1 to 1000).toList
l.combinations(2).size

A faster algorithm:
{code}
  def combinations[A](l: List[A], n: Int): Iterator[List[A]] = {
    def go(l: List[A], n: Int): Iterator[List[A]] = n match {
      case _ if n < 0 || l.lengthCompare(n) < 0 => Iterator.empty
      case 0 => Iterator(List.empty)
      case 1 => l.iterator.map(a => (a :: Nil)) // optional optimization step
      case n => l.tails.map({
        case Nil => Nil
        case x :: xs => go(xs, n - 1).map(ys => x :: ys)
      }).flatten
    }
    go(l.distinct, n)
  }
{code}
Only downside is that it uses stack proportional to n.
