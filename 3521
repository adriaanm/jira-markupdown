OK, here's the deal, and I need some help to fix this.
{code}
// Traits.scala
sealed trait T

trait A extends T
trait B extends T
trait C extends T

// Test.scala
object Test {
  def f = (null: T) match {
    case _: A => println("A")
    case _: B => println("B")
    // no C
  }
}
{code}
If these files are compiled together from source, no exhaustiveness warning is issued.  Of note is that this is only the case when A, B, and C are traits and the files are compiled together.  If they are classes or objects, the warning goes.  If the traits are compiled first and then Test compiled against the bytecode, the warning goes.

From poking around unsuccessfully it seems like the children are not being set up correctly.  It also seems like the traits may still look like classes when the children are read, and then become traits later, and this somehow knocks the wheels off.  However I'm out of ideas.  I feel like a voodoo shaman trying to understand the various gambits being played with a symbol's info at different phases.  There's only so far I can go with no real idea what the big picture is.
