{code}
Welcome to Scala version 2.10.3 (Java HotSpot(TM) 64-Bit Server VM, Java 1.7.0_45).
Type in expressions to have them evaluated.
Type :help for more information.

scala> class C { trait T }
defined class C

scala> val c = new C
c: C = C@1130ed80

scala> val t1: c.T = (new { def apply(c: C) = new c.T {} })(c)
t1: c.T = $anon$2$$anon$1@23309add

scala> val t2: c.T = ({c: C => new c.T {} })(c)
<console>:9: error: type mismatch;
 found   : $anon where type $anon <: c.T
 required: c.T
       val t2: c.T = ({c: C => new c.T {} })(c)
                                            ^

scala> val f1: { def apply(c: C): c.T } = {c: C => new c.T {} }
<console>:9: error: type mismatch;
 found   : C => $anon forSome { type $anon <: c.T; val c: C }
 required: AnyRef{def apply(c: C): c.T}
       val f1: { def apply(c: C): c.T } = {c: C => new c.T {} }
                                                ^
{code}

The function literal is inferred to existential type {code} C => $anon forSome { type $anon <: c.T; val c: C } {code}, which looks complex, but it is no more special than simple {{C => C#T}}.

Could you infer the function literal to {code} (C => C#T) with { def apply(c: C): c.T } {code}
