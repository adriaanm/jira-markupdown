Minimized:

{code}
trait Foo[A] {
  def minBy[B](b: B): A = ???
}

class Bar extends Foo[Int]
{code}

The generic signature of {{minBy}} in {{Bar}} is {{<B:Ljava/lang/Object;>(TB;)I;}}. However, the regular signature is {{public java.lang.Object minBy(java.lang.Object);}}. The problem is that we have a primitive type in position where erased type is Object.

It's interesting to observe what happens when we manually move implementation to {{Bar}}:
{code}
trait Foo[A] {
  def minBy[B](b: B): A
}

class Bar extends Foo[Int] {
  def minBy[B](b: B): Int = ???
}
{code}

In that case we get two {{minBy}} methods generated (bridge, and regular method) and only the regular method gets generic signature that is identical to the example above. However, regular method will have {{int}} as erased return type so generic signature and erased signature agree. It's also interesting to note that we don't generate generic signatures for bridge methods whereas Java does.
