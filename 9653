There's an alternative version of interpolation matching where the interpolated text will always match the existing capture groups. By convention, people write things like {{(\d+)$x (\d+)$y}}, but that works just like {{(\d+) (\d+)$x$y}}. Anyway, such code was recently used by Adriaan Moors on a presentation (iirc), and can also be seen in [this blog|http://hacking-scala.tumblr.com/post/50360896036/regular-expressions-interpolation-in-pattern-matching].

Personally, I think that style is error prone, since the order in which things get assigned is not related to their position, but to the number of capturing groups. Add a capture group by mistake, and the match will start failing.

Of _these_ two, I do prefer my own version (as described in my blog post already mentioned), and I do like {{.*}} over any of the alternatives, but that does decrease the usefulness of matching quite a bit, since one often wants whatever is being capture to follow a pattern of its own.

What I'd *really* rather do is go with macros and use named patterns. Java 7 supports {{(?<NAME>X)}} to specify named capture groups. A Scala macro could check the string for named capture groups and assign them (with or without Java 7 support), *and* translate a string with them into one with normal interpolation, such as the one in the blog I mention. Since the macro will check the regex for named groups, it can ensure that the names are properly assigned, and give compile time errors when matching if there are unnamed capture groups.
