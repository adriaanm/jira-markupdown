So, one just needs an explicit form of computing the hashcode of a sequence of consecutive numbers. As far as I can see the formula for (min to max).hashCode is:
```scala
(...((Seq.hashCode * 41 + min.hashCode) * 41 + (min + 1).hashCode) * 41 + ...) * 41 + max.hashCode
```
which is
```scala
Seq.hashCode * Math.pow(41, max - min + 1) + (min to max).map(i => i * Math.pow(41, max - min - i)).sum
```
Which essentially boils down to the problem, if there is a form of
```scala
(1 to n).map(i => i * Math.pow(41, n - i)).sum
```
without any form of loop like map, fold, or sum.
But my math ends here.

I did a quick test. A simple imperative style loop
```scala
{ var x = 0; for (i <- 1 to 100000000) x = x * 41 + i; x}
```
is much faster, but still takes about one second to compute.
