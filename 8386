Going to revert the implementation restriction, because I thought of this, which does work given explicit type application:
{code}
import scala.language.dynamics

class A extends Dynamic {
  def applyDynamic[T1](method: String)(x1: T1): Any = 1
  def applyDynamic[T1, T2](method: String)(x: T1, y: T2): Any = 2
}

object Test {
  def main(args: Array[String]): Unit = {
    val x = new A
    println(x[Int](5))
    println(x[Int, String](5, "a"))
  }
}
{code}
However, I hope this causes people reconsider whether the overloading-hostile structure of applyDynamic makes sense. I think this shows that it does not. With no way to express a variable-length type parameter list, we have again, following in the footsteps of structural types, created a pseudo-general mechanism which is incapable by design of being used in common situations for which it would otherwise be useful, creating unnecessary surprises and friction. There is no way to write a dynamic method which can receive every application of a method name. You could push the above out to N type parameters, but then there's no way to avoid explicit type application.
