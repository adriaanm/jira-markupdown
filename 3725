no more compile-errors with following reworked code:
```scala
package test

import scala.util.continuations._

import java.net.InetSocketAddress
import java.nio.ByteBuffer
import java.nio.channels.{SelectionKey, Selector, ServerSocketChannel, SocketChannel}

class NIO {
	
	val selector = Selector.open()

	def asRunnable(body: => Unit) = new Runnable { def run() { body } }

	def accept(s: ServerSocketChannel): SocketChannel @cps[Unit] =
    shift { cont =>
        s.register(selector, SelectionKey.OP_ACCEPT, asRunnable {
            val c = s.accept()
            c.configureBlocking(false)
            cont(c)
        })
    }

	def read(s: SocketChannel, b: ByteBuffer): Int @cps[Unit] =
    shift { cont =>
        s.register(selector, SelectionKey.OP_READ, asRunnable {
        	cont( s.read(b) )
        })
    }

	def write(s: SocketChannel, b: ByteBuffer): Int @cps[Unit] =
    shift { cont =>
        s.register(selector, SelectionKey.OP_WRITE, asRunnable {
        	cont( s.write(b) )
        })
    }

	
	def processReq(s: SocketChannel, b: ByteBuffer): Unit @cps[Unit] = {
			
		  b.clear()
		  val cnt = read(s, b)
      
		  println(b.toString)
		  
      if (cnt > 0) {
        b.flip()
        write(s, b)
        processReq(s, b)
      } else {
      	s.close()
      	//cpsUnit
      	//shiftUnit[Unit,Unit,Unit]( () )
      	shiftUnit0[Unit,Unit]( () )
      	
      	// R = Right = Exception
      	//shiftUnitR[Unit,Unit]( () )
      }
	}
	
	def cpsUnit: Unit @cps[Unit] = ()
	
	def serve() = {
		
		val server = ServerSocketChannel.open()
		server.socket().bind(new InetSocketAddress(12345))
		server.configureBlocking(false)

		reset {
			while (true) {
				val socket = accept(server)
				println("accepted: " + socket)
				
				
				reset {
					processReq(socket, ByteBuffer.allocateDirect(1))
				}
			}
		}

		()
	}

	// The NIO event pump
	def pump() = {
		while (true) {
			selector.select()
			val l = selector.selectedKeys().toArray.toList.asInstanceOf[List[SelectionKey]]
			selector.selectedKeys().clear()
			for (k <- l) {
        k.interestOps(0)
        k.attachment().asInstanceOf[Runnable].run()
			}
		}
		()
	}
}

object NIOtest {
	
	def main(args: Array[String]) = {
		val nio = new NIO
		println("serving")
		nio.serve()
		println("pumping")
		nio.pump()
		println("exiting")
	}
}
```
