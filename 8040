More generally, even though we can write a case class with one tuple-valued argument,
we can't express the corresponding extractor.

This finally gives us a use case for Product1:

{code}
scala> case class Holder[T](_1: T) extends Product1[T]
defined class Holder

scala> object Foo { def unapply(x: Any): Some[Holder[(Int, Int)]] = Some(Holder((1, 2))) }
defined module Foo

scala> 1 match { case Foo(t) => t }
res0: Holder[(Int, Int)] = Holder((1,2))
// expected (1, 2) as result type, by analogy to the Product2 extractor:

scala> object Foo { def unapply(x: Any): Some[((Int, Int), Any)] = Some(((1, 2), "foo")) }
defined module Foo

scala> 1 match { case Foo(t, _) => t }
res1: (Int, Int) = (1,2)
{code}

The spec has to be changed, since now it says (specialized to the case for n = 1)

> An unapply method in an object x matches the pattern x(p1) if it takes exactly one argument and unapplyâ€™s result type is Option[T], for some type T.
> In this case, the (only) argument pattern p1 is typed in turn with expected type T.
> The extractor pattern matches then all values v for which x.unapply(v) yields a value of form Some(v1), and p1 matches v1.
