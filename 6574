Cool.

Yeah, I agree, the majority of the cases that the lub check cuts out are likely to be false positives. I think the description in terms of a once-valid comparison followed by inheritance refining one of the types is narrower than the full set of bugs that the lub check would hide in practice, though. For example, the one place where the warning with the lub check fires in scalac is here:

src/compiler/scala/tools/nsc/backend/msil/GenMSIL.scala:1266:
warning: GenMSIL.this.global.icodes.BasicBlock and
ch.epfl.lamp.compiler.msil.emit.Label are unrelated: probably always
compare unequal
           if (next != defaultTarget)

This is a real bug. As it happens, these two classes come from fairly separate parts of the codebase, so their lub is ScalaObject. But the authors of this code clearly think of them as related classes, or they wouldn't make this mistake; they both belong to the MSIL subsystem and are things that describe chunks of MSIL code; so it could have happened that the two classes shared some generic utility class like "MSILItem" that was used by that subsystem generally. In that case, the lub check would have suppressed this warning.

Perhaps an option to issue this warning without the lub check would fit under -Ywarn-all; the SNR (excluding what the lub check does let through) is probably too low for -Xlint.
