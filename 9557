=> is underspecified so I'm guessing, but to use (=> A) => B where A => B is expected would imply either that A <:< (=> A), which can't be the case, or that there is something which automatically converts values of type (=> A) => B to values of type A => B, which there isn't unless you make one.

But you can make one.
```scala
scala> implicit def upgradeByName[A, B](x: (=> A) => B): A => B = (p: A) => x(p)
upgradeByName: [A, B](x: (=> A) => B)A => B

scala> apply("hello")(log)
hello
```

The other way is buggy as is clear from the CCE.
