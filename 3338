Off the top of my head, the easiest way to see this is to make a new Scala/Java project, and setup this annotation processor:

http://repo.joist.ws/org/interfacegen/interfacegen/0.1/

(See http://bindgen.org/setup.html for Eclipse annotation processor setup, replacing bindgen with this interfacegen--this interfacegen is just simpler hence using it to reproduce this instead of bindgen.)

Now make a class:

{code}
package bar;
@GenInterface
public Foo implements IFoo {
  public void foo() {
  }
}
{code}

The `@GenInterface` just copies all of the public methods of `Foo` into `IFoo` for mock testing.

So, now if you add a Scala file:

{code}
package bar

class A {
  val f: IFoo = new Foo
}
{code}

You'll get a compile error and the output for `IFoo` will never get generated. You can check the annotation processor output folder (.apt_generated by default).

If for some reason you happen to still have an `IFoo` left over from when you had an A.scala (though this did not happen to me), if you run clean, it will delete all the .apt_generated classes and then fail to make `IFoo`.

I admit I have not tried the command-line compiler so this may affect more than just the eclipse plugin.
