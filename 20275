I have some code like this:
{code}
     if (ccy != null && rate != null) {
        ltub.settlement(ccy, rate.bigDecimal)                   //non-deterministic strangeness
        if (ltub.getDescriptor.getSettlementFxRate.isSet && ltub.getDescriptor.getSettlementFxRate.getValue == null) {
          if (rate.bigDecimal == null) println("NULL NOOOO!!!") //NPE WAT?
          a += 1
          println(a)
        }
      }
{code}
Within this block we are seeing a {{NullPointerException}} thrown at runtime on the indicated line. *This should obviously be impossible* because that can only happen if {{rate}} is {{null}} and yet the code is inside an if-block protected against that condition. I have the following observations:

 # Failures are non-deterministic running from the same class files (sometimes the NPE is thrown, sometimes it  isn't)
 # The block is being invoked hundreds of thousands of times. Investigations have revealed sometimes there are no failures, sometimes a few thousand and sometimes many hundreds of thousands
 # The code has been in existence and running against scala 2.11 with no issues for over 6 months
 # The code is single threaded - this is not a concurrency issue
 # I think the issue might be connected to JIT because of the above (i.e. sometimes the bytecode works, sometimes it doesn't). Having said that, successes happen after failures, so it is not as simple as "the code gets compiled by JIT and then starts failing". Having said that, I cannot reproduce the issue with {{-Djava.compiler=NONE}} and @oxntr (on Twitter) said this description "screams JIT"
 # The slightest change to the code (adding a different print statement in the block) can cause the issue to go away
 # In investigating this, I've observed other horrendous behaviour - for example, the line {{ltub.settlement(ccy, rate.bigDecimal)}} is supposed to set _update descriptor_ fields for _currency_ and _rate_; I have seen the currency field get set to the rate (the field is a generic class and hence the type it is holding is erased)

I have tried to put together a minimal example but have been unable to do so (i.e. I cannot reproduce the problem), hence I'm supplying the disassembled bytecode (using javap), assuming that people who can read bytecode might be able to find some obvious issue in what has been generated (although this may be tricky, if the issue is connected to how JIT is compiling that bytecode).

I have supplied some minimal source code; this depends on our projects and scalaz - you will not be able to compile or run it. I hope, however, that you will be able to see how the problematic lines (13-19 in the attached file) relate to the generated bytecode (for example, I'm pretty sure that line 14 in the scala file relates to line 185 in the bytecode).
