Basically, we kill ourselves by using the same type for wrapping up multiple values as we do for encoding information about an extractor. If you want to say "extractor is arity 1, here is an ((Int, Int))" you are screwed. Possibly enhancements include
{code}
def unapplyArity: Int
{code}
for those cases where you want them to differ. But the worst scenario is the present one, where the pattern matcher is "flexible" in regards to the arity - maybe it's 1, maybe it's 3, let's see what works. We should be looking for more type safety in the matcher, not less.
