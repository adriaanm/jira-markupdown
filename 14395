I'm not quite sure of the intended behaviour here. I've been trying to serialise an Enumeration (in 2.7 and 2.8), but it doesn't seem to work as I expected.
```scala
Welcome to Scala version 2.8.0.r18405-b20090730020155 (Java HotSpot(TM) Client VM, Java 1.6.0_13).
Type in expressions to have them evaluated.
Type :help for more information.

scala> def serialise[T](t: T): T = {
     |   val buf = new java.io.ByteArrayOutputStream
     |   val out = new java.io.ObjectOutputStream(buf)
     |   out.writeObject(t)
     |   out.close
     |   val is = new java.io.ByteArrayInputStream(buf.toByteArray)
     |   val in = new java.io.ObjectInputStream(is)
     |   in.readObject.asInstanceOf[T]
     | }
serialise: [T](t: T)T

scala> object MyEnum extends Enumeration {
     |   val ONE = Value("1")
     |   val TWO = Value("2")
     | }
defined module MyEnum

scala> val a = MyEnum.ONE
a: MyEnum.Value = 1

scala> val b = serialise(a)
b: MyEnum.Value = 1

scala> println(a == b)
false

scala> println(System.identityHashCode(a))
1510253

scala> println(System.identityHashCode(b))
21353508

scala> println(System.identityHashCode(MyEnum))
15675004

scala> println(System.identityHashCode(serialise(MyEnum)))
8713829
```

After poking around in the (2.7) source a little, it seems that Value is being "resolved", but the actual Enumeration "MyEnum" object isn't (and why values end up non-equal too). I have a work-around - inserting `def readResolve(): AnyRef = MyEnum` method in MyEnum fixes it.

Should it be necessary that I provide my own readResolve method on each of my Enumeration objects? It's not really an issue, I just have quite a few in my object model, and I want to serialise the whole thing.

I just thought this was slightly unexpected behaviour, especially if you are used to Enum serialisation in Java. It is also something easily forgotten, and then enum values just end up unequal when you would probably expect they should be.
