The behavior is as specified, and I would not know how to change the spec.
That said there's one sore point: The behavior of f _: You would expect that
{code}
   f _ == f(_) == (x => f(x))
{code}
But only the second equality holds. The reason lies i the parser. It eta-expands
`f(_)` immediately, but expands `f _` to something like `(f: ? -> ?)`. It can't do the eta expansion for f _ because it does not know how many parameters `f` has. So that's how the code paths diverge.

What to do about it? The proper thing to do would be to force eta-expansion
of `f _` in the typer. But I have been uncompfortable with `f _` anyway for a long time. It feels redundant with all the other possibilities we have for expressing
function values. So how about deprecating `f _` altogether?








