h3. On Jason Zaugg's variant

I'm slightly confused on the need for an extractor. On Scala 2.10.3 and 2.11.0, you don't need any extractor to reproduce the bug â€” a typed match does not use it. (The use of a typed extractor is a slight difference with the example I mentioned before in SI-6944, but it appears immaterial). To wit:

{code}
object Test {
  sealed trait Node[+A]
 
  // case class L[C,D](f: C => D) extends Node[C => D]
 
  class L[C, D](val f: C => D) extends Node[C => D]
 
  def test[A,B](n: Node[A => B]): A => B = n match {
    case l: L[c,d] => l.f
  }
 
  def main(args: Array[String]) {
    println {
      test(new L[Int,Int](identity) with Node[Nothing]: Node[Int => String])(3): String
    }
  }
}
{code}

[~ellbur], I think your example is interesting. Technically speaking, that's not at all the desugaring used: a typed match, that is {{e match \{case v: SomeType => ...\};}}, must be desugared (conceptually) using {{if (e.isInstanceOf\[SomeType\]) \{val v = e.asInstanceOf\[SomeType\]; ...\};}}.

However, it's true that pattern matching on sum types can usually be understood using elimination forms (your {{extract}} method), even for GADTs. (But your translation is equivalent to requiring that Node has a member of type A). In fact, desugaring to elimination forms can be an implementation strategy.

For Scala, I'd be happier with explicit witnesses of type equality, like in GHC's core language. GADT translation just inserts a checkcast after typechecking, but this typechecking produces no certificate that the type is right, unlike GHC does.

IMHO, if GHC hackers feel the need to use such high-assurance technology, one cannot hope that Scalac magically gets this right. But getting this right will take no less than one PhD student, and right now I'm not sure there are the technical foundations to get this started.
