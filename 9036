One does not need an invariant class to trigger this, nor arrays. Here's a reduced version, inspired to what happens in Lightweight Modular Staging:
```scala
object MinimalUnsoundness {
  trait Exp[+T]
  case class Const[+T](t: T) extends Exp[T] //Making Const invariant makes no difference.
  def interp[T](term: Exp[T]): T =
    term match {
      case Const(t) => t //This should be rejected...
    }

  //Because classes like this can be declared:
  class MyConst(t: String) extends Const[Any](t) with Exp[Boolean]
}
//At the REPL:
scala> import MinimalUnsoundness._
import MinimalUnsoundness._

scala> :type interp(new MyConst(""))
Boolean

scala> interp(new MyConst(""))
java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Boolean
```
In the actual code, I want to prevent declaring classes like `MyConst`, so that `interp` is actually accepted, and making `Const` final is often not an option, but that's another story.

A more complete example - an interpreter for embedded simply-typed lambda-calculus with subtyping:
```scala
trait Lambda {
  trait Exp[+T]
  case class Const[T](t: T) extends Exp[T]
  case class App[S, T](fun: Exp[S => T], arg: Exp[S]) extends Exp[T]
  case class Fun[S, T](body: Exp[S] => Exp[T]) extends Exp[S => T]
}

trait Interp extends Lambda {
  def interp[T](term: Exp[T]): T =
    term match {
      case Const(t) => t //Unsound!
      case App(fun, arg) =>
        interp(fun) apply interp(arg) //Unsound!
      case f: Fun[s, t] =>
        //(x: s) => interp(f.body(Const(x)))
        (((x: s) => interp(f.body(Const(x)))): (s => t)).asInstanceOf[T] //What I have to write
      //case Fun(body) =>
        //x => interp(body(Const(x)))
    }
}

object Language extends Lambda with Interp {
  //Demonstrate why all the above branches can trigger an error.
  class MyFun[T]() extends Fun[T, T](x => x) with Exp[runtime.AbstractFunction1[T, T]]
  class MyApp[T](t: T) extends App[Int, List[T]](Fun(x => Const(List(t))), Const(1)) with Exp[Nil.type]
  class MyConst(t: String) extends Const[Any](t) with Exp[Boolean]

  println(interp(new MyApp(1))) //This works thanks to heap pollution
  println("""Executing 'interp(new MyApp(1))' in the REPL won't work -
    |you'll get a ClassCastException""".stripMargin)
  println("""Same for 'interp(new MyConst(""))'""")
}
```
