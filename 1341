Mucking with sessions while the actor might be executing on another thread isn't a good idea.
```scala
  def send(msg: Any, replyTo: OutputChannel[Any]) = synchronized {
    tick()
    if (waitingFor ne waitingForNone) {  // check to make sure the actor is actually waiting
      sessions = replyTo :: sessions // if partial function uses sender to calculate
                                     // isDefinedAt, then the sender needs to have a session
      if (waitingFor(msg)) {
        received = Some(msg)

  //      if (isSuspended)
  //        sessions = replyTo :: sessions
  //      else
  //        sessions = List(replyTo)

        waitingFor = waitingForNone

        if (!onTimeout.isEmpty) {
          onTimeout.get.cancel()
          onTimeout = None
        }

        if (waitingInReceive)
          resumeActor()
        else // assert continuation != null
          scheduler.execute(new Reaction(this, continuation, msg))
      } else {
        sessions = sessions.tail // remove the session
        mailbox.append(msg, replyTo)
      }
    } else {
      mailbox.append(msg, replyTo)
    }
  }
```
