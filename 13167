Found by findbugs 1.3.2 in code generated by 2.7.0-RC2.

The following code generates a call to equals(Object) passing
in a null argument, which should always return false, so there's
no point in having this call in the bytecode.
```scala
class Reflection {
  def foo(clazz : Class[_]) : Unit = {
    val superclass = clazz.getSuperclass()
    if (superclass != null) {
      foo(superclass)
    }
  }
}
```

Here's the bytecode showing the call to equals with a null argument
```scala
public void foo(java.lang.Class);
  Code:
   0:   aload_1
   1:   invokevirtual   SI-18; //Method java/lang/Class.getSuperclass:()Ljava/lang/Class;
   4:   astore_2
   5:   aload_2
   6:   dup
   7:   astore_3
   8:   ifnull  24
   11:  aload_3
   12:  aconst_null
   13:  invokevirtual   SI-22; //Method java/lang/Object.equals:(Ljava/lang/Object;)Z
   16:  ifne    24
   19:  aload_0
   20:  aload_2
   21:  invokevirtual   SI-26; //Method foo:(Ljava/lang/Class;)V
   24:  return
```

Changing the code to use
```scala
    if (!(superclass == null)) {
```

generates the same bytecode.

Using the 'eq' or 'ne' operator generates smaller bytecode that
doesn't have this issue.  Could comparisons using == or !=
against explicit be mapped to the equavalent of the eq or ne
bytecode?
