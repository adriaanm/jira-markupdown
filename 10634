Indeed, this changed:

{code}
package p {
  class Foo
  object `package` {
    implicit val foo: Foo = new Foo
  }

  object Test {
    def bar(implicit f: Foo): Any = implicitly[Foo]
  }
}
{code}

I think I remember why:

{noformat}
% git show 9aa6ded8e01179e7d55144de273b39f3a0b2d3ec --statcommit 9aa6ded8e01179e7d55144de273b39f3a0b2d3ec
Author: Jason Zaugg <jzaugg@gmail.com>
Date:   Thu Nov 22 14:20:18 2012 +0100

    SI-6667 Abort after any ambiguous in-scope implicit

    Rather than continuing on to a search of implicits
    of the expected type.

    Previously, the companion implicits were searched if the
    the caller was running the implicit search in silent
    mode, for example if searching for an implicit parameter
    in an application which has an expected type.

    After this commit, the behaviour is consistent, regardless
    on silent/non-silent typing.

 src/compiler/scala/tools/nsc/typechecker/Implicits.scala |  3 ++-
 test/files/neg/t6667.check                               | 13 +++++++++++++
 test/files/neg/t6667.scala                               | 10 ++++++++++
 test/files/neg/t6667b.check                              | 13 +++++++++++++
 test/files/neg/t6667b.scala                              | 25 +++++++++++++++++++++++++
 5 files changed, 63 insertions(+), 1 deletion(-)

% scalac-hash 9aa6ded8e01179e7d55144de273b39f3a0b2d3ec sandbox/test.scala
sandbox/test.scala:8: error: ambiguous implicit values:
 both value foo in package p of type => p.Foo
 and value f of type p.Foo
 match expected type p.Foo
    def bar(implicit f: Foo): Any = implicitly[Foo]
                                              ^
one error found

% scalac-hash 9aa6ded8e01179e7d55144de273b39f3a0b2d3ec~1 -Xprint:typer sandbox/test.scala
[[syntax trees at end of                     typer]] // test.scala
package p {
  class Foo extends scala.AnyRef {
    def <init>(): p.Foo = {
      Foo.super.<init>();
      ()
    }
  };
  object `package` extends scala.AnyRef {
    def <init>(): p.package.type = {
      `package`.super.<init>();
      ()
    };
    private[this] val foo: p.Foo = new Foo();
    implicit <stable> <accessor> def foo: p.Foo = `package`.this.foo
  };
  object Test extends scala.AnyRef {
    def <init>(): p.Test.type = {
      Test.super.<init>();
      ()
    };
    def bar(implicit f: p.Foo): Any = scala.this.Predef.implicitly[p.Foo](p.`package`.foo)
  }
}

{noformat}

Failing is a lesser WTF than 2.10.3 which fell back to the implicit in the companion-scope (which includes package objects of the prefixes of the sought type, unfortunately!)

Package object implicits: just say no!
