Here's an design that would be backwards compatible.

{code}
  sealed abstract class <:<[-From, +To] extends (From => To)
  object <:< {
    implicit def conforms[A]: A <:< A = new (A <:< A) {
      def apply(x: A) = x
    }
  }

  object Predef {    
    implicit def identity[A](a: A) = a
  }

{code}

According the the comments, the new design should have less scope for ambiguity. I need an example to understand this and weigh against this problem.

r18537
r19204
