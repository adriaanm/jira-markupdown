Minimized:

{code}
package p1

object O {
  private case class N(a: Any)
  lazy val x: Unit = N
  lazy val y: Unit = new { N }
}
{code}

The analysis in `SingleUseTraverser` that figures out what fields can be nulled out after a lazy val is computed used to be run in `mixin`.  It now runs early, in `fields`. It assumes that a private member cannot be accessed from outside of the template body, which isn't a correct assumption until explicitouter has publicised symbols referred to by inner classes of companions. 

Here'a a related regression:

{code}
class Test(private val x: String) {
  lazy val y = x.reverse
}
object Test {
  def main(args: Array[String]): Unit = {
    val t = new Test("foo")
    assert(t.y == "oof", t.y)
    assert(t.x == "foo", t.x) // fails in 2.12.0-RC
  }
}
{code}

There might be additional incorrect assumptions in play in the compiler crash, i haven't quite pinned it down.
