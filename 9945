The bug stems from this in `typedIdent`:
```scala
          // ignore current variable scope in patterns to enforce linearity
        val startContext = if (mode.typingPatternOrTypePat) context.outer else context
        val nameLookup   = tree.symbol match {
          case NoSymbol   => startContext.lookupSymbol(name, qualifies)
          case sym        => LookupSucceeded(EmptyTree, sym)
        }
```


Which the any self-respecting deviant would exploit with:
```scala
  def f(x: Any) = x match { case (a: AnyRef, x: (a.type forSome { type T })) => x } // !!! compiles
```

Type patterns are not explicitly specced to allow the `forSome` syntax: http://www.scala-lang.org/files/archive/spec/2.11/08-pattern-matching.html#type-patterns in the 

So one most straight forward fix for the directly reported bug would be to prohibit this.

But we have to be nuanced enough to allow:
```scala
def f(x: Any) = x match { case x: Array[(T forSome { type T })] => x }
```

and to outlaw things like:
```scala
def f(x: Any) = x match { case (y: AnyRef, x: Array[({type X = y.type})#X]) => x }
```
