making the types more explicit to show where it all goes wrong:

{code}
class A {
  object b {
    object c
  }
  def m = b.c
}

object Test {
  var a: A = new A // mutable
  val c /*: object _1.b.c forSome { val _1: A } */ = a.m // widening using existential
  
  def mani[T: Manifest](x: T) = ()
  mani/*[object _1.b.c]*/(c) // kaboom in manifestOfType / TreeGen.mkAttributedQualifier
  // --> _1 is not in scope here...
}
{code}

Sorry, Martin, I have to re-assign this one to you.
I [http://github.com/adriaanm/scala/commit/f1997169a504f877dcef1827a56001ce79865410 tried] to add some "deskolemization" logic to `solve` in Types so that we get `Test.this.mani[object _1.b.c forSome { val _1: A }](Test.this.c)`
but that doesn't seem to solve the problem...
