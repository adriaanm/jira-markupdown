Another way to be able to connect the in and out is:
```scala
class X[T](var value: T) {
  def out(): T = value
  def in(t: T) = value = t
}
 
object Test {
  def inout[A](xa: X[A]) = {
    val a: A = xa.out()
    xa.in(xa.out())
  }
  val x: X[_] = new X(???)
  inout(x)
}
```

In your example, the existential `_` is separately skolemized in the two places it occurs in expression `x.in(x.out)`.
```
% scalac -Dscala.color -uniqid -Ytyper-debug test/files/pos/t9242.scala
...
|    |-- x.in(x.out()) BYVALmode-EXPRmode (site: value <local Test> in Test)
|    |    |-- x.in BYVALmode-EXPRmode-FUNmode-POLYmode (silent: value <local Test> in Test)
|    |    |    |-- x EXPRmode-POLYmode-QUALmode (silent: value <local Test> in Test)
|    |    |    |    \-> Test#8376.x#16657.type (with underlying type X#8380[_])
|    |    |    \-> (t#16678: _$1#16677)Unit#2783
|    |    |-- x.out() : pt=_$1#16677 BYVALmode-EXPRmode (silent: value <local Test> in Test)
|    |    |    |-- x.out BYVALmode-EXPRmode-FUNmode-POLYmode (silent: value <local Test> in Test)
|    |    |    |    |-- x EXPRmode-POLYmode-QUALmode (silent: value <local Test> in Test)
|    |    |    |    |    \-> Test#8376.x#16657.type (with underlying type X#8380[_])
|    |    |    |    \-> ()_$1#16679
|    |    |    \-> <error>
```

I'm pretty sure this is somewhere between "not a bug" and "limitation", but I'll assign it to @adriaanm for an opinion.

The research compiler dotty uses your syntax for exporting type parameters as members. It actually accepts your program unchanged, although I haven't dug into this.
