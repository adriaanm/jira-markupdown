{code}
object Test {
  class Bippy[A]
  
  def foo[Result[_]] = new {
    private type Elem[B] = Result[B]
    
    def bar: Result[Elem[Int]] = sys.error("TODO")
  }
  
  // error: Cannot prove that Test.Bippy[Test.Bippy[Int]] =:= Test.Bippy[Result[Int]].
  check[Bippy[Bippy[Int]]](foo[Bippy].bar)
  
  def check[A] = new {
    def apply[B](b: B)(implicit ev: A =:= B) = ()
  }
}
{code}

The "check" function is simply to assert inferred type equivalence without triggering implicit conversion or subtype coercion.  If I inline "Elem", this works just fine.  Similarly, if I use a named class as the return type of "foo", rather than new {}, there is again no problem.
