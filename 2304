Gilles, i think this one is for you, it has to do with refinement types.

when compiling the following
{code}
trait T

object C { val c = List(1).map(e => new T{}) }

object A { val a = C.c }
{code}

the type of C.c is the refinement {{Object with T}}. The typeSymbol of the !RefinedType (the refinement class symbol) has as owner {{value $$anonfun}}, which in turn
has owner {{value c}} (debug {{case RefinedType}} in the {{putType}} method of the pickler).

Un-Pickling fails because in {{value c}} no member called {{$$anonfun}} can be found.


If you specify the type of c manually, i.e.
{code}
object C { val c: List[Object with T] = List(1).map(e => new T{}) }
{code}
the owner of the refinement symbol is {{object C}}, and everything works fine.


So the question is: what should be the owner of the refinement-class-symbol in the first case?
