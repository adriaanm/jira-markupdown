{code}
object Test{
  trait ZW[S]{type T}
  def ZipWith[S, M <: ZW[S]]: M#T = error("ZW")
  def meh[A] = ZipWith[A, ZW[A]{type T=Stream[A]}] // T-Def

  meh[Int]: Stream[Int]
}
{code}

scala-2.8.0-final says:

{code}
error: type mismatch;
 found   : Test.ZWSI-9200[IntSI-4392]{type TSI-11267 = StreamSI-3223[IntSI-4392]}#TSI-11016
 required: StreamSI-3223[IntSI-4392]
  meh[Int]: Stream[Int]
     ^
{code}

This should type check, though.

Rough explanation: after the prefix in the typeref `M#T` is updated to reflect the instantiation of the type arguments in `meh[Int]`, the symbol that is used to refer to `T` is stale: it's still the symbol defined in the line marked with `// T-Def`

However, it should refer to the new symbol (not visible in the source code) that has `A` instantiated to `Int`.
