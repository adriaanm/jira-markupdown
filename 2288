Okay -- leaving gratitude aside for a moment -- back to to bits.

To be clear, the latest patch I propose is http://lampsvn.epfl.ch/trac/scala/attachment/ticket/2316/no-owner.patch . It is based on: http://github.com/retronym/scala/commits/implicit-caching (not implicit-cache as I wrote above.)

The key change is
```scala
-  val implicitsCache = new LinkedHashMap[AnyRef, SearchResult]
+  val implicitsCache = new LinkedHashMap[Type, List[List[ImplicitInfo]]]
```

This cache is interrogated when looking for implicits from the implicit import scope, that is, to look for an implicit of type T in the companion object of T and the companion objects of its super-types. 

Previously, the entire !SearchResult was cached, which could contain symbols local to the scope of the search that were used as implicit parameters, and hence not safely cacheable. These tests demonstrate best the problems with this approach. r1

With the patch, the cache only stores information gleaned from the implicit import scope r2. When no in-scope implicit is found, the current context and cached implicitInfoss are used to find a search result r3, which may contain bound variables used as implicit parameters. As such, it is not cached.

I tried a more complex version that detected SearchResults that contained no bound variables and cached them, but this was complex, not driven by performance measurements and as such probably wrongheaded.

r1 http://github.com/retronym/scala/commit/f0bfbfc3234bd9c7349e740b6dff50aac5f7ca4b
r2 http://github.com/retronym/scala/blob/implicit-caching/src/compiler/scala/tools/nsc/typechecker/Implicits.scala#L578
r3 http://github.com/retronym/scala/blob/implicit-caching/src/compiler/scala/tools/nsc/typechecker/Implicits.scala#L695
Every time an implicit search occurs, this information is combined with the 

I haven't done any performance testing, but to paraphrase Joe Armstrong, an incorrect implementation can be made arbitrarily fast.
