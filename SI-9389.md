   When I compile the attached Scala program of 1232 lines of code,
   the compiler crashes with a java.lang.OutOfMemoryError (Java heap
   space) exception. The size of the file Data.scala is the
   culprit. If I shorten Data.scala substantially, e.g. to 500 LOCs,
   the problem disappears. A 16 GB machine should not run out of
   memory on such a small source program.

The error message can be found in the attached file error-report.txt.
The files causing the crash are Data.scala,  Event.scala and should
be compiled together.
I can reproduce the OOME with JVM heap sizes up to 1G. (The default is typically less, it depends on your platform).

Increasing this to 2GB gets past the OOME, although it just gets as far as running into a JVM limitation about the size of a class:

```
% scalac -version
Scala compiler version 2.11.2 -- Copyright 2002-2013, LAMP/EPFL
% scala -J-Xmx2G sandbox/test.scala
sandbox/test.scala:79: error: Could not write class All$ because it exceeds JVM code size limits. Method Start$'s code too large!
object All {
       ^
one error found
```

There is nothing the compiler can to to help out here. You might have more luck in writing code to read the parse the data from a CSV file, or otherwise you would need to artificially chunk the generated code.

Alternatively, you could provide the arguments in the parameter declaration order, which is a lot more efficient in the generated bytecode.

For instance, this compiles without heap exhaustion or exceeding classfile limitations with default settings:

```
```scala
object All {
  def newEvent(year: Int, month: Month, weekday: Weekday, day: Int, hour: Int, minute: Int, second: Int, timezone: Timezone, action: Action)
     = new Event (second, minute, hour, weekday, day, month, year, timezone, action);

newEvent ( year = 2014, month = Jul, weekday = Sun, day = 6, hour = 11, minute = 40, second = 55, timezone = BST, action = Start );
newEvent ( year = 2014, month = Jul, weekday = Sun, day = 6, hour = 11, minute = 41, second = 13, timezone = BST, action = Paperwriting );
newEvent ( year = 2014, month = Jul, weekday = Sun, day = 6, hour = 11, minute = 53, second = 35, timezone = BST, action = Break );
...
```
I'm surprised that the order of named constants does matter for the generated code. The arguments and their target order are known at compile-time, so why does that lead to more code? I guess maybe that's because argument evaluation has side effects and they should not be changed by the reordering? But that amounts to translating 


```java
       new Event (  day = M1, month = M2, year = M3, weekday = M4, ... )

```

to something like


```java
   val d = M1
   val m = M2
   val y = M3
   val w = M4 
   ...
   new Event ( y, m, w, d )
```


and should not generate that much new code.

----

I also don't think a 1K LoC file should force a compiler out of memory. What's the root cause of this exceptional memory usage? An unprotected simple recursion instead of tail recursion?

I just tried to compile the test program with scalac with 128 GB of heap:

```java
$ scalac -J-Xmx128G  Event.scala Data.scala 
Data.scala:1: error: Could not write class All$ because it exceeds JVM code size limits. Method Start$'s code too large!
object All {
       ^
one error found
```

I don't think that a compiler should run out of that much of memory for such a small program. 

Note that using scala instead of scalac works fine with 2GB of memory as Jason writes above. Why this discrepancy?



 
