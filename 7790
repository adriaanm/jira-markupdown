Nice example which illustrates once again why reify isn't always applicable:
```scala
 def pack[A](a: A): Array[Byte] = macro pack_impl[A]

   def pack_impl[A: c.TypeTag](c: Context)(a: c.Expr[A]): c.Expr[Array[Byte]] = {
     import c.universe._
     c.reify {
       val baos = new ByteArrayOutputStream
       packto_impl(c)(c.reify[OutputStream]{ baos }, a).splice
       // works: packto_impl(c)(c.Expr[OutputStream](Ident("baos")), a).splice
       // doesn't work: packto_impl(c)(c.reify[OutputStream]{ baos }, a).splice
       baos.toByteArray
     }
   }

   def packto[A](output: OutputStream, value: A): Unit = macro packto_impl[A]

   def packto_impl[A: c.TypeTag](c: Context)(output: c.Expr[OutputStream], value: c.Expr[A]): c.Expr[Unit] = { .... }
```

Compiling this code will signalize about cross-stage evaluation. This is justified, because the value of baos (as a free variable) will be captured by reification. But this value is only available at runtime, while splice in question needs to work at compile-time.

This is all reasonable and stuff from the staging point of view, but it doesn't really matter for the programmer who just wants to quasiquote.
