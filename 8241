Quoting from https://groups.google.com/d/topic/scala-internals/5oRYBYBUqMY/discussion

The cases of particular interest to me are List and Array.

- List(1, 2, 3) leads to approximately this:
{noformat}  val arr = new Array[Int](3)
  arr(0) = 1
  arr(1) = 2
  arr(2) = 3
  val wrapped = new WrappedArray(arr)
  List.apply(wrapped) 
  val cbf = implicitly[CanBuildFrom[...]]
  val builder = cbf() // new ListBuffer[Int]
  builder ++= wrapped
  builder.result
{noformat}
When it could be done like this:
{noformat}
  new ::(1, new ::(2, new ::(3, Nil)))
{noformat}

- Array(1, 2, 3) leads to approximately this:
{noformat}
  val arr = new Array[Int](3)
  arr(0) = 1
  arr(1) = 2
  arr(2) = 3
  // Hey, stop right there! Scala, stop! Oh no...
  val wrapped = new WrappedArray(arr)
  Array.apply(wrapped) 
  val arr2 = new Array[Int](wrapped.length)
  var i = 0
  // throw in a closure and a boxing trip through Seq#foreach
  for (x <- wrapped.iterator) { arr2(i) = x; i += 1 } 
  arr2
{noformat}
