I would like to suggest the compiler optimize the common case of for loops, that is, 
```scala
for (var <- Range [by step])
for (var <- int to int [by step])
for (var <- int until int [by step])
```

to use while loops under the covers instead of. Currently, nested for loops using ranges/iterators are sometimes an order of magnitude slower than while loops. However, while loop constructs for iterating over arrays are very cumbersome, and the functional style (foreach) is also cumbersome and introduces a lot of function call overhead as well.

The following two matrix multipication implementations
```scala
  def matMulUsingIterators (
       a : Array[Array[Double]],
       b : Array[Array[Double]],
       c : Array[Array[Double]]) : Unit = {

    val b_j = new Array[Double](b.length)

    for (j <- 0 until b(0).length) {
        for (k <- 0 until b.length) {
            b_j(k) = b(k)(j)
        }
        for (i <- 0 until a.length) {
            val c_i = c(i)
            val a_i = a(i)
            var s = 0.0d;
            for (k <- 0 until b.length) {
                s += a_i(k) * b_j(k)
            }
            c_i(j) = s
        }
    }
  }

  def matMulUsingRanges (
       a : Array[Array[Double]],
       b : Array[Array[Double]],
       c : Array[Array[Double]]) : Unit = {

    val jRange = 0 until b(0).length;
    val kRange = 0 until b.length;
    val iRange = 0 until a.length;

    val b_j = new Array[Double](b.length)

    for (j <- jRange) {
        for (k <- kRange) {
            b_j(k) = b(k)(j)
        }
        for (i <- iRange) {
            val c_i = c(i);
            val a_i = a(i);
            var s = 0.0d;
            for (k <- kRange) {
                s += a_i(k) * b_j(k)
            }
            c_i(j) = s
        }
    }
  }
```

are much slower than the same algorithm coded with while loops:
```scala
  def matMulUsingWhileLoop (
      a : Array[Array[Double]],
      b : Array[Array[Double]],
      c : Array[Array[Double]]) : Unit = {

    val m = a.length;
    val p = b(0).length;
    val n = b.length;

    val b_j = new Array[Double](b.length);

    var i = 0; var j = 0; var k = 0;
    while (j < p) {
        k = 0
        while (k < n) {
            b_j(k) = b(k)(j);
            k += 1
        }
        i = 0
        while (i < m) {
            val c_i = c(i);
            val a_i = a(i);
            var s = 0.0d;
            k = 0;
            while (k < n) {
                s += a_i(k) * b_j(k);
                k += 1
            }
            c_i(j) = s;
            i += 1
        }
        j += 1;
    }
  }
```

but the while loop code is more complex and error prone.

(Sorry, Trac appears to remove some line breaks; I
added some explicit semis but might have missed some;
I'll try attaching actual working source code)

Running this while measuring time in nanoseconds:
```scala
Iterators   2,807,815,301ns
Ranges      2,789,958,191ns
While Loop  190,778,574ns
```

MatMul by Iterators is 14 times as slow as with while loops.

It does not appear that the Hotspot runtime profiling and optimization dramatically helps this performance problem
This performance problem can hurt adoption of Scala for many types of uses/applications. 
