Minimized:

{code}
class C {
  val blob = {
    new { case class Foo() }

//  without anonymous class (same bug)
//    class Inner { case class Foo() }
//    new Inner
  }
  val foo = blob.Foo()
}
{code}


RefChecks ("toConstructor") changes the "C.this.blob.Foo.apply()" to "new Inner.this.Foo()" which is wrong:

 # class Inner is not an outer class, if something it should be "new C.this.blob.Foo()"
 # I tried various things using "asSeenFrom" and "memberType" using the class symbol "C", but was not able to get the required type, I always get "Inner.this.Foo")
 # However, "new C.this.blob.Foo()" is actually wrong, since that is not a class type (in Typers, checkStablePrefixClassType)

So we should keep the companion-apply in this case, not replace it by a "new" (this fixes the bug).

Paul figured out the condition to catch this case ([mailing list|https://groups.google.com/d/msg/scala-internals/z-gSgrfTkn4/77BHI1PH8PIJ]). When selecting "blob.Foo", the symbol for module "Foo" lives in the refinement type. Calling "companionClass" will not return the class symbol for "Foo", but the abstract type "Foo" in the refinement. That's how we conclude that the class type is not accessible.
