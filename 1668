Yes, it does look like a conscious design decision. Here's the code at the moment.

{code}
class Channel[Msg] extends InputChannel[Msg] with OutputChannel[Msg] {

  private[actors] var recv: Actor = {
    // basically Actor.self, but can be null
    Actor.tl.get.asInstanceOf[Actor]
  }

  def receiver: Actor = recv

  def this(recv: Actor) = {
    this()
    this.recv = recv
  }
{code}

The "obvious" alternative (to me) would be to use {{Actor.self}} instead of accessing the {{ThreadLocal}} directly.

{code}
class Channel[Msg] extends InputChannel[Msg] with OutputChannel[Msg] {

  private[actors] var recv: Actor = Actor.self

  def receiver: Actor = recv

  def this(recv: Actor) = {
    this()
    this.recv = recv
  }
{code}

This would solve my problem. _However_, it would also mean that {{Actor.self}} is initialised - even when we don't need it. i.e. Even when an actor is explicitly passed in the constructor: {{new Channel(anotherActor)}}. I can see why this might be undesirable, because it could cause an {{ActorProxy}} to be created unnecessarily.

A way to avoid that problem would be to switch the constructors around like so.

{code}
class Channel[Msg](recv: Actor) extends InputChannel[Msg] with OutputChannel[Msg] {

  def receiver: Actor = recv

  def this() = this(Actor.self)
{code}

This means that {{Actor.self}} is no longer called by default.

Of course you can tidy it up a bit more: making {{receiver}} into a val, etc.

{code}
class Channel[Msg](val receiver: Actor) extends InputChannel[Msg] with OutputChannel[Msg] {

  def this() = this(Actor.self)
{code}

What do you think? It might still be a good idea to get Philipp's opinion on this one.
