Yes, it does look like a conscious design decision. Here's the code at the moment.
```scala
class Channel[Msg] extends InputChannel[Msg] with OutputChannel[Msg] {

  private[actors] var recv: Actor = {
    // basically Actor.self, but can be null
    Actor.tl.get.asInstanceOf[Actor]
  }

  def receiver: Actor = recv

  def this(recv: Actor) = {
    this()
    this.recv = recv
  }
```

The "obvious" alternative (to me) would be to use `Actor.self` instead of accessing the `ThreadLocal` directly.
```scala
class Channel[Msg] extends InputChannel[Msg] with OutputChannel[Msg] {

  private[actors] var recv: Actor = Actor.self

  def receiver: Actor = recv

  def this(recv: Actor) = {
    this()
    this.recv = recv
  }
```

This would solve my problem. *However*, it would also mean that `Actor.self` is initialised - even when we don't need it. i.e. Even when an actor is explicitly passed in the constructor: `new Channel(anotherActor)`. I can see why this might be undesirable, because it could cause an `ActorProxy` to be created unnecessarily.

A way to avoid that problem would be to switch the constructors around like so.
```scala
class Channel[Msg](recv: Actor) extends InputChannel[Msg] with OutputChannel[Msg] {

  def receiver: Actor = recv

  def this() = this(Actor.self)
```

This means that `Actor.self` is no longer called by default.

Of course you can tidy it up a bit more: making `receiver` into a val, etc.
```scala
class Channel[Msg](val receiver: Actor) extends InputChannel[Msg] with OutputChannel[Msg] {

  def this() = this(Actor.self)
```

What do you think? It might still be a good idea to get Philipp's opinion on this one.
