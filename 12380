Here's a minimized repro

{code}
abstract class MyFunction1[T, U] extends Function1[T, U]

object Test {
  def foo(x: Function1[Int, Int]) = ???
  def foo(x: MyFunction1[Int, Int]) = ???

  val myf: MyFunction1[Int, Int] = ???
  foo(myf)
}
{code}

{code}
16:14 ~/Projects/2121/sandbox (2.12.x)$ s
Test.scala:8: error: ambiguous reference to overloaded definition,
both method foo in object Test of type (x: MyFunction1[Int,Int])Nothing
and  method foo in object Test of type (x: Int => Int)Nothing
match argument types (MyFunction1[Int,Int])
  foo(myf)
  ^
{code}
