Briefly, I believe that scala.util.parsing.combinator.Parsers.Failure.append should be changed to:

{code}
	  def append[U >: Nothing](a: => ParseResult[U]): ParseResult[U] = { val alt = a; alt match {
	    case _: Success => alt
	    case _: Error => alt
	    case _: Failure => if (alt.next.pos < next.pos) this else alt
	  }}
{code}

…rather than treating ‘Error’ and ‘Failure’ as the same case as it does currently.

In the current implementation, if a parser returns a Parsers.Failure and attempts to back-track, a Parsers.Error discovered during back-tracking will be ignored (unless it is later in the input). In other words, in the current implementation, a Parsers.Error does not stop back-tracking if it is itself discovered while back-tracking from a Parsers.Failure.

However, the documentation for Parsers.Error states that NO back-tracking should be performed after a Parsers.Error.

This fault can be observed in a modified version of "scala.util.parsing.combinator.lexical.StdLexical". Assuming:

{code}
	def token: Parser[Token] = 
	  ( letter ~ rep( letter | digit ) ^^ { case first ~ rest => processIdent(first :: rest mkString "") }
	  | digit ~ rep( digit ) ^^ { case first ~ rest => NumericLit(first :: rest mkString "") }
	  | '\_ ~ rep( chrExcept('\_, '\n', EofCh) ) ~ '\_ ^^ { case '\_ ~ chars ~ '\_ => StringLit(chars mkString "") }
	  | '\"' ~ rep( chrExcept('\"', '\n', EofCh) ) ~ '\"' ^^ { case '\"' ~ chars ~ '\"' => StringLit(chars mkString "") }
	  | EofCh ^^^ EOF
	  | '\_ ~> err("unclosed string literal")
	  | '\"' ~> err("unclosed string literal")
	  | delim
	  | failure("illegal character")
	  )
{code}

(I’ve modified the two "unclosed string literal" lines to call 'err' rather than 'failure'. Which I believe is a mistake in StdLexical.)

Attempting to parse a stream containing an unclosed string literal, gives:
{code}
`"' expected but X found
{code}
(where X is a newline or the end-of-file character)

That is, the Parsers.Error object generated by 'err' is ignored (because it is earlier in the input) by the Parsers.Failure when it attempts to backtrack from the end of the line.

A work-around I discovered in this case is to 'succeed' with an explicit ErrorToken:
{code}
	def token: Parser[Token] = 
	  ( letter ~ rep( letter | digit ) ^^ { case first ~ rest => processIdent(first :: rest mkString "") }
	  | digit ~ rep( digit ) ^^ { case first ~ rest => NumericLit(first :: rest mkString "") }
	  | '\_ ~ rep( chrExcept('\_, '\n', EofCh) ) ~ '\_ ^^ { case '\_ ~ chars ~ '\_ => StringLit(chars mkString "") }
	  | '\"' ~ rep( chrExcept('\"', '\n', EofCh) ) ~ '\"' ^^ { case '\"' ~ chars ~ '\"' => StringLit(chars mkString "") }
	  | EofCh ^^^ EOF
	  | '\_ ^^^ErrorToken("unclosed string literal")
	  | '\"' ^^^ErrorToken("unclosed string literal")
	  | delim
	  | failure("illegal character")
	  )
{code}

This fault appears still to exist in the 2.8 branch.
