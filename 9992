Jason, I disagree with your analysis here. The reason for the soundness hole in SI-3873 is not that {{new A}} as argument for parameter {{a}} is unstable, but rather that it's not the same prefix as {{val a}}. Let's try replacing {{new A}} in the SI-3873 code fragment with a stable reference (and fixing it a little bit so we don't have bare methods and vals):
{code}
class A { 
  class B
  def b: B = new B 
}

class B {
  def f(a: A)(b: a.B): a.B = b

  val a = new A
  f(a)(a.b)
  f({ val fresh = new A; fresh: fresh.type })(a.b) // doesn't compile
}
{code}

You would find that the code still wouldn't compile, since {{a-the-val.type#B}} does not conform to {{a-the-argument.type#B}} (which is actually {{fresh.type#b}}). This is not analogous to what's going on over here in SI-7753 (at least in your example). The first way to test this is to make a similar substitution:
{code}
import scala.language.{ higherKinds, implicitConversions }
 
trait Foo { type Out }
 
trait SI {
  val instance: Foo
  type Out
}

object Test {
  def test {
    def indirect(si: SI)(v: si.instance.Out) = v
   
    val foo: Foo { type Out = Int } = ???
    def conv(i: Foo): SI { type Out = i.Out; val instance: i.type } = ???
    
    val converted = conv(foo)

    val v1: Int = indirect(converted)(23)

    val v2: Int = indirect({ val fresh = conv(foo); fresh: fresh.type })(23)  // Works now

  }
}
{code}
You will find that the code compiles now. But then, of course it does: this basically comes to the same thing as what you already had above with {{val converted}}! Anyway, I do think that there is enough constraint here to make the call soundly, and that you should reconsider your position. Oh, and something else you should try: turn {{v2}} into {{indirect(conv(foo))\_}} and you'll find that you get an {{Int => Int}}. _hmmmm_... Inconsistency in Scalac? That could never happen! Anyway, feel free to refute _my_ analysis, as I could easily be missing some other factor that leads to unsoundness here.

While I'm at it, though, I'm extremely _unconfident_ that the "stability lambdas" above ({{\{val fresh = \_; fresh: fresh.type\}}}) should work (I actually only kept them in so I could make this point). They seem to be letting part of the type (namely its stability) escape into an outer lexical scope, which definitely seems iffy. What do you think?
