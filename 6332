{{GenJVM}} has the following guard whose then-branch gets to run for both the module-symbol (because of the first or'ed expression) and also for its companion class (because of the 2nd). 

Looks like the intention was to have {{addStaticInit()}} executed (because {{GenJVM}} intializes the {{serialVersionUID}} static field in the {{<clinit>()}} added by {{addStaticInit()}} ). That gets done. However by not taking the else-branch for the companion class, {{addForwarders()}} doesn't get a chance to run.

The {{GenASM}} control-flow is different but also gets tripped by this bug. I'll try to adapt the fix from {{GenASM}} to  {{GenJVM}}. But the solutions are actually independent (ie, if you're familiar with {{GenJVM}}, your help is welcome).

{noformat}
      if (isStaticModule(c.symbol) || serialVUID != None || isParcelableClass) {
        if (isStaticModule(c.symbol))
          addModuleInstanceField
        addStaticInit(jclass, c.lookupStaticCtor)

        if (isTopLevelModule(c.symbol)) {
          if (c.symbol.companionClass == NoSymbol)
            generateMirrorClass(c.symbol, c.cunit.source)
          else
            log("No mirror class for module with linked class: " +
                c.symbol.fullName)
        }
      }
      else {
{noformat}
