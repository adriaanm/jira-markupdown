I tried something like


{code}
    def addApplyUnapply(cdef: ClassDef, namer: Namer) {
      // does not yet take into consideration an overloaded "apply" method.
      if (!(cdef.symbol hasFlag ABSTRACT) && cdef.symbol.info.member(newTermName("apply")) == NoSymbol)
        namer.enterSyntheticSym(caseModuleApplyMeth(cdef))
      namer.enterSyntheticSym(caseModuleUnapplyMeth(cdef))
    }
{code}


But still
/opt/repos/scala-trunk/testing $$ ../build/quick/bin/scalac Foo.scala
Foo.scala:7: error: method apply is defined twice
case class Foo(lx: int)
           ^
one error found


With some printlns:
{code}
    def addApplyUnapply(cdef: ClassDef, namer: Namer) {
	println("trying to add apply and unapply")
      if (!(cdef.symbol hasFlag ABSTRACT) && cdef.symbol.info.member(newTermName("apply")) == NoSymbol)	{
	println("adding apply")
        namer.enterSyntheticSym(caseModuleApplyMeth(cdef))
      }
	println("adding unapply")
      namer.enterSyntheticSym(caseModuleUnapplyMeth(cdef))
    }
{code}

/opt/repos/scala-trunk/testing $$ ../build/quick/bin/scalac Foo.scala
trying to add apply and unapply
adding apply
adding unapply
Foo.scala:7: error: method apply is defined twice
case class Foo(lx: int)
           ^
one error found
