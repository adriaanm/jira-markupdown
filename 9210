How can this possibly be right:
{code}
  pt1 match {
    // if at least one of the types in an intersection is checkable, use the checkable ones
    // this avoids problems as in run/matchonseq.scala, where the expected type is `Coll with scala.collection.SeqLike`
    // Coll is an abstract type, but SeqLike of course is not
    case RefinedType(ps, _) if ps.length > 1 && (ps exists infer.isCheckable) =>
      None

    case ptCheckable if infer isUncheckable ptCheckable =>
      val classTagExtractor = resolveClassTag(pos, ptCheckable)

      if (classTagExtractor != EmptyTree && unapplyMember(classTagExtractor.tpe) != NoSymbol)
        Some(classTagExtractor)
      else None

    case _ => None
  }
{code}
