This issue was noticed in scala/bug#5005. Basically, the problem here is that the typer runs before specialize, so the type of a val is never a specific specialized subclass. This means that all method calls on a specialized instance stored in a val end up using the unspecialized code instead. Here's an example that Vlad cooked up which shows the issue:
```scala
class C[@specialized(Int) A](val a:A) {
  @inline final def get:A = a
}

class B {
  // needs to be final, otherwise the most you can infer for c is C[Int]
  //(someone else might override it and not return C$mcI$sp)
  final val c = new C(13) 

  // not getting inlined, inter-procedural TFA necessary
  def runIndirect: Int = c.get

  // not getting inlined, but TFA should infer C$mcI@sp for the stack slot
  def runLocal: Int = {
    val cc = new C(13)
    cc.get
  }

  // getting inlined
  def runDirect:Int = new C(13).get
}
```

Looking at the bytecode, you'll notice that runDirect correctly calls (and inlines) C$mcI$sp.get$mcI$sp call, whereas runIndirect and runLocal both call C.get$mcI$sp, which cannot be final and thus is not inlined. Furthermore, even though the "c" val is defined as being a C[Int], the generated accessor method returns a C, not a C$mcI$sp.

Vlad thinks that type-flow analysis (TFA) might able to "fix" this in the case of local vals (or final vals which can't be overridden).
