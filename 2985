Aleksandar, I have been considering r20661, reviewing old stuff, and gathering some input. The solution put forth in r20661 is not the one mentioned in this ticket, but it comes close. There is one problem that the solution in this ticket solves that the one proposed would not solve: efficiency when not all matches are replaced.

Now, what was implemented corresponds to a couple of alternatives put forth in an e-mail I sent to scala-debate called "Enhancement Proposal: Regex Replace", back in december, the fourth.

At that time, the only input I got back with a preference opted for Match => Option[String], and conjured the hypothesis of something converting partial functions into this (which later became to be in the method "lift", added by Martin).

Also, Ijuma has expressed a certain discontent with replaceAllMatchDataIn, due to the excessive verbosity. Personally, I'd like the operators ~=, ~ and ~~, handling most of the present functionality through polymorphism, and something which does not exist yet (boolean matching), but that's something I only intend to put forth more to the future. It strikes me as an interesting coincidence, however, that this method corresponds to option 4, close to option 5, in that e-mail, and is also a new method, as opposed to the polymorphism of replaceAllIn.

So I'm pondering discarding this method, and coming with a different one for option five: replaceSelectively or replaceOption, (Match) => Option[String]. We avoid "all" to reinforce not everything may be replaced, and we make the name shorter by not having to state Match explicitly to avoid Function-erased clash.

It lacks symmetry, I'll grant, but replaceAllIn works for the simple cases, while this one acts as power users last resort. Besides, the current Regex library doesn't have symmetry going for it anyway.

If, on the other hand, you think this should be subjected to more discussion (I _did_ try to raise a discussion on debate...), I ask for replaceAllMatchDataIn to be removed until such a date as we feel comfortable with any decision. The function-receiving replaceAllIn ought to be kept as is, however, as it is a natural extension of replaceAllIn, and is very useful.

