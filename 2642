What is done at the bytecode level has no bearing on what the language should allow for. It is definitively a bug that f1() and f2() in the appended code are inherited by classes outside s1 and O respectively. That the methods can even be overridden makes access a sham. What is the point of a specification if it is to be discarded whenever it is inconvenient? 
```
       The modifier can be qualified with an identifier C (e.g.  private[C])
       that must denote a class or package enclosing the definition. Members
       labeled with such a modifier are accessible respectively only from
       code inside the package C or only from code inside the class C and its
       companion module (§5.4). Such members are also inherited only from
       templates inside C.
```
That it actually works as it's supposed to if the qualifier is a class name means trial-and-error is the only way to discover the behavior.
```scala
package s1 {
  object O {
    class A {
      private[s1] def f1(): Int = 1
      private[O]  def f2(): Int = 2
      private[A]  def f3(): Int = 3
    }
  }
}
package s2 {
  class B extends s1.O.A {
    override def f1() = 11  // allowed
    override def f2() = 12  // allowed
    override def f3() = 13  // disallowed
    // ./a.scala:15: error: method f3 overrides nothing
    //     override def f3() = 12
    //                  ^
    // one error found
  }
}
```
