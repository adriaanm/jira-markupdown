I can add another case in the backend to handle this code, but I fear there might be something wrong coming from the typer. The type of 'e' in the first branch is {{Throwable}} instead of {{SpecialException}}. Erasure seems to insert the right casts at each use, if needed. Why is that so? I would expect the type of {{e}} to be {{SpecialException}}. I'll leave this open for now, as my fix might hide a deeper problem. Here's a simpler example:
{code}
class MyException1 extends Exception

// Commenting out the following line and uncommenting the second line
// will cause the test to succeed.
trait SpecialException extends MyException1 {
  val x: String
}
// trait SpecialException

class MyException2 extends MyException1 with SpecialException {
  val x = "abc"
}

object Test extends Application{
    try {
      throw new Exception("abc")
    }
    catch {
      case e1 : SpecialException => {
        println(e1.x)
        assume(e1.isInstanceOf[SpecialException])
      }
      case e2 => {
        assume(e2.isInstanceOf[Throwable])
      }
    }
}
{code}

Printing types gives:
{code}
        case (e1 @ (_{SpecialException}: SpecialException){java.lang.Throwable}){java.lang.Throwable} => {
          scala.this{package scala}.Predef{object Predef}.println{(java.lang.Object)Unit}(e1{java.lang.Throwable}.$$asInstanceOf{[T0 >: ? <: ?]()T0}[SpecialException]{()SpecialException}(){SpecialException}.x{()java.lang.String}(){java.lang.String}){Unit};
          scala.this{package scala}.Predef{object Predef}.assume{(Boolean)Unit}(e1{java.lang.Throwable}.$$isInstanceOf{[T0 >: ? <: ?]()Boolean}[SpecialException]{()Boolean}(){Boolean}){Unit}
        }{Unit}
{code}

Notice how the type of e1 is {{Throwable}} and the call to 'x' is preceded by a cast.
