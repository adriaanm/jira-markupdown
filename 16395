I'm not sure if this is a bug or expected behavior.

`

 trait ApplicativeLike[F[_]] { self => 
   def pure[A](a: => A): F[A]
   def ap[A,B](fa: F[A])(f: F[A => B]): F[B]
 }

`

Now suppose I have

`
 
 val list: ApplicativeLike[List] = ...
 list.ap(list.pure(1))(list.pure(x => x+1))

`

I get missing parameter type on x. But A is known to be Int, and Scala should know that the type of the second argument to ap is therefore List[Int => ?]. So why is the annotation required on x?
