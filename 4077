While digging the source of the bug I found, what appears to be, a serious bug in Types.scala in 
{code}
2890	      case NotNullType(tp) =>
2891	        val tp1 = this(tp)
2892	        if (tp1 eq tp) tp
2893	        else NotNullType(tp1)
{code}

which should be obviously tp0 not tp. This could potentially break lots of code but I will look around what actually happens. The reason for having NotNull in the first place in explicitouter is due to lub in Types.scala (see last expression). NotNull is removed during uncurry when we explicitly give the type (and it stays if we don't) - I still need to figure out why (partially this is due to mapOver in Type).

So depending on how much stuff this might break, this will or will not go into final. 
