Story about fixing this one ([https://github.com/scala/scala/commit/23afe3c9b9ff6f1c9d31cea678909003ca8f943b])

The class

{code}
class T(val a: Array[_$1] forSome { type _$1 })
{code}

is de-sugared into

{code}
class T {
  val a: Array[_$1] forSome { type _$1 }

  def <init>(a:  Array[_$1] forSome { type _$1 }): T = {
    T.this.a = a;
    // ...
  }
}
{code}

Constructors phase generates the field initialization assignment, type-checking it crashed. The reason:
  * the type of field {{a}} was erased to Array[Object] (that's wrong)
  * the type of parameter {{a}} was erased to {{Object}} (correct)


Why was field {{a}} erased wrong? Java interop: A Java {{Array<T>}} is erased to Array[Object] ({{T}} can only be a reference type), where as a Scala Array[T] is erased to {{Object}}.

This logic in erasure was wrong about judging what is a Java array: it loks at the type argument {{T}} and checks if its owner is defined in a Java class. The problem is that for existential members such as {{T}} in (Array[T] forSome {type T}), the owner of {{T}} can be anything (e.g. when computing a lub, the compiler often uses {{<root>}} as owner of existential symbols).

In the example, the owner happened to be the enclosing package class, and every package class always has the {{JAVA}} flag set.


Why is it the enclosing package class? Because {{<paramaccessor>}} fields are type-checked in a context outside the class ({{createPrimaryConstructorParameterNamer}}). This is necessary:

{code}
class C { class D(val x: C) { class C } }
{code}

The parameter type {{C}} should refer to the outer {{class C}}, not to the nested one.

In our initial example, because the field definition is type-checked in a context outside {{class T}}, the owner of the existential symbol {{_$1}} is the enclosing package {{<empty>}}.
