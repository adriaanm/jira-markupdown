I'm afraid this is an enhancement rather than a bug. Implicit views and implicit search do not chain this way. In the version with the manifest bound, the `A("a")` must be fully adapted (i.e., the implicit value for the manifest found), before the rest of the expression is even considered. 

When you remove the manifest bound, the `T` type parameter survives as an undetermined type parameter until the `x` method call is type checked and its argument determines `T` to be `Int`. However, we don't delay the manifest search in the same way (though technically we could -- afaik, the spec is silent on the details). 

The "delayed manifest search" interpretation would be more complicated to implement, as I think it would require the context tracking undetermined manifests along with the undetermined type parameters.

The implicit search for `Manifest[T]` and `Z[T]` are different in the sense that the `qq` implicit determines the `T` type parameter, whereas the manifest cannot be determined until the `x` method call has been type checked fully.

Concretely, the version with the manifest is more precisely approximated by
```scala
 case class Z[T](t: T)
 implicit def qq[T]: Z[T] = error("")
  
 case class A[T: Z](t: String)
```

As a workaround, can you push down the manifest bound to the definition of `x` and `C`?
```scala
object Test {
 case class A[T](t: String)
 case class V[T](t: T)
 case class B[T](a: A[T]) { def x(v: V[T])(implicit mani: Manifest[T]): C[T] = C(a,v) }
 case class C[T: Manifest](a: A[T], v: V[T])

 implicit def aToB[T](a: A[T]): B[T] = B(a)

 A("a") x V(3)
}
```


ps: I don't think your covariant variant achieves what you hoped for:
```scala
Test.this.aToB[T](Test.this.A.apply[Nothing]("a")(reflect.this.Manifest.Nothing)).x[Any](Test.this.V.apply[Int](3))
```
