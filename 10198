Maybe we can discuss a smaller example. Here's a starting point:

{code}
class Global(expectedThread: Thread) {
  def checkThread() { Thread.currentThread == expectedThread }
  def set(a: Any) = {checkThread(); ...  }
  lazy val get = {checkThread(); ...  }
}

def importer(g1: Global, g2: Global) = {
  g2.set(g1.get)
}

val g1 = new Global(thread1); val g2 = new Global(thread2)
onThread(thread2) {
  import(g1, g2)
}
{code}

Here, `importer` can never satisfy the checks for the correct thread. As I understand it, you workaround this by:

{code}
onThread(thread1) { g1.get }
onThread(thread2) { importer(g1, g2) }
{code}

In practice, there are a few more layers; You get Symbols out of Global, and some methods on the Symbol are lazy and need forcing.

Brainstorming solutions, we could:
  - find all APIs in the compiler that return a Symbol and decorate them for the presentation compiler with something that calls `fullyInitialize`
  - disable this thread check for the duration of the call to `import`.
  - rewrite Importers to execute calls against `g1` and `g2` via respectively provided ExecutorServices that do things on the correct thread.
  - ???

Let's chat about this tomorrow in person.
