Simplified below. Adriaan, are forward references in type parameter lists allowed?
```scala
trait Term
case class FunctionalTerm[+T <: Term](t: T) extends Term

// ex1, ex2 compile
def ex1[T <: Term, U[T] <: Term](t: U[T]): Term = sys.error("TODO: ex1")
def ex2[T <: Term, U[T] <: Term](t: U[T]): Term = ex1(t)


// ex3 compiles, ex4 gives errors
def ex3[T <: Term, U[T] <: X, X <: Term](t: U[T]): Term = sys.error("TODO: ex3")
def ex4[T <: Term, U[T] <: X, X <: Term](t: U[T]): Term = ex3(t)
```

errors on ex4:
```
scala> def ex4[T <: Term, U[T] <: X, X <: Term](t: U[T]): Term = ex3(t)
<console>:9: error: inferred type arguments [T,U,Nothing] do not conform to method ex3's type parameter bounds [T <: Term,U[T] <: X,X <: Term]
       def ex4[T <: Term, U[T] <: X, X <: Term](t: U[T]): Term = ex3(t)
                                                                 ^
<console>:9: error: type mismatch;
 found   : U(in method ex4)[T(in method ex4)]
 required: U(in method ex3)[T(in method ex3)]
       def ex4[T <: Term, U[T] <: X, X <: Term](t: U[T]): Term = ex3(t)
                                                                     ^
```
