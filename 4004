Another possibility would be to add a simple method {{future(resp: Responder)}} to scala.actors.Futures to convert a Responder into a Future:

{code}
object Futures {
  ...

  def future[T](resp: Responder[T]): Future[T] = {
    val c = new Channel[T](Actor.self(DaemonScheduler))
    val a = new FutureActor[T](fv => resp.respond {rv => fv.set(rv)}, c)
    a.start()
    a
  }

  def future[T](body: => T): Future[T] = {
  ...
{code}

This would allow switching back from CPS to direct-style withough changing Future's API. I tried it, and this (almost) works now:

{code}
import scala.actors._, scala.actors.Actor._, scala.actors.Futures._

val a = actor { loop { react { case i:Int => Thread.sleep(2000); reply(i*2) } } }
val f = a !! (3, {case x:Int => x})
val r = f map { _ + 1 }

f() // necessary because of SI-3412

println(future(r)())
{code}

Almost, since it crashes if you take out the {{f()}}, because of SI-3412.
