The code is broken, and if you fix it, you will see that Try is actually a valid functor.
Here are two possible ways to fix it:
1. http://ideone.com/Z21SUn
{code:scala}
import scala.util._

object Main extends App {
  def divideByZero(a: Int): Int = a / 0
  def numberOrDefault(a: Int): Int =
    try a catch { case _: ArithmeticException => 42 }
    
  println(Success(1) map { numberOrDefault _ compose divideByZero _ })
  println(Success(1) map divideByZero _ map numberOrDefault _)
}
{code}
2. http://ideone.com/Z9zePL
{code:scala}
import scala.util._

object Main extends App {
  def divideByZero(a: Int): Int = a / 0
  def numberOrDefault(a: => Int): Int =
    try a catch { case _: ArithmeticException => 42 }
    
  println(Success(1) map { ((x: Int) => numberOrDefault(x)) compose divideByZero _ })
  println(Success(1) map divideByZero _ map ((x: Int) => numberOrDefault(x)))
}
{code}
You may argue this is the right example: http://ideone.com/TgkLCO
{code:scala}
import scala.util._

object Main extends App {
  def divideByZero(a: Int): Int = a / 0
  def numberOrDefault(a: => Int): Int =
    try a catch { case _: ArithmeticException => 42 }
    
  println(Success(1) map { x => numberOrDefault(divideByZero(x)) })
  println(Success(1) map divideByZero _ map ((x: Int) => numberOrDefault(x)))
}
{code}
But that's not true, because for "map (f . g)" case you use
{code}
f = numberOrDefault
g = divideByZero
{code}
and for "map g . map f" case you use another f:
{code}
f = ((x: Int) => numberOrDefault(x))
g = divideByZero
{code}
By this example you actually prove that numberOrDefault !== ((x: Int) => numberOrDefault( x )), which is quite obvious fact.
