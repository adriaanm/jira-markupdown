There is no sane way to achieve all of the following: (1) low collision rate; (2) BigInt and BigDecimal hashCode agrees with equality (w.r.t. each other); (3) BigDecimal can't explode the heap.  The problem is that BigInt *isn't* decimal, so the hash code computation of 1e1000000000 would require you to churn through the base-2 representation of the billion-digit decimal number.  Not fun.  I could given enough time perhaps invent a hashing function that had some simplifying form for lots of zeros so that powers of ten of BigInt would have easy-to-compute hash codes.  But this is way too time-consuming to get right (if it is even possible).  Instead, I've applied a simple heuristic: small numbers of digits convert BigDecimal to BigInt.  Large numbers of digits do a different calculation on BigDecimal alone.  This is part of https://github.com/scala/scala/pull/3316
