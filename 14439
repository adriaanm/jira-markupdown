This code, taken from the ICFP09 continuations paper:

-----------------------snip snip-----------------------
  type Monadic[+U, C[_]] =
  { 
    def flatMap[V](f: U => C[V]): C[V] 
  }

  class Reflective[+A, C[_]](xs: Monadic[A,C])
  { 
    def reflect[B](): A @cps[C[B], C[B]] =
    { 
	  shift { k:(A => C[B]) => xs.flatMap(k) }
	}
  } 

  implicit def reflective[A](xs:Iterable[A]) = new Reflective[A,Iterable](xs) 
-----------------------snip snip-----------------------

fails to compile on the last line (the implicit), giving the error:

type mismatch;  found   : xs.type (with underlying type Iterable[A])  required: s_hansei.Monadic[A,Iterable]
