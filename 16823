The spec states: "... Subclasses of a sealed class can be inherited anywhere."  So, for example:
```scala
// AB.scala
sealed trait A
trait B extends A
```
```scala
// CD.scala
case object C extends B
case object D extends B
```

This seems to defeat the purpose of `sealed` as a way of declaring closed algebraic types.  I can write the following:
```scala
def nonexhaustive(a: A): A = a match {
  case C => C
  // no case for D
}
```
