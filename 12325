On 2.12, after it breaks my CPU fan,
{code}
1000000
java.lang.OutOfMemoryError: GC overhead limit exceeded
	at scala.util.Success.map(Try.scala:252)
	at scala.concurrent.Future.scala$concurrent$Future$$$anonfun$8(Future.scala:264)
	at scala.concurrent.impl.Promise$KeptPromise$Successful$$Lambda$97/1100439041.apply(Unknown Source)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:29)
	at scala.concurrent.impl.Promise.scala$concurrent$impl$Promise$$$anonfun$1(Promise.scala:29)
	at scala.concurrent.impl.Promise$KeptPromise$Successful$$Lambda$98/32374789.apply(Unknown Source)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:60)
	at scala.concurrent.impl.ExecutionContextImpl$AdaptedForkJoinTask.exec(ExecutionContextImpl.scala:140)
	at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)
	at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)
	at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)
{code}
This must be slightly different, because it completes:
{code}
    def next(state: Int): Future[(String, Int)] = read().map(text => (text, text.toInt + state))

    def loop(state0: Int): Future[Unit] =
      next(state0).flatMap {
        case (text, state) => write(state.toString).flatMap(_ =>
          if (state == N) Future.successful(()) else loop(state))
      }
{code}
However, that version is 3x slower on 2.12 compared to 2.11.  OK, my break is over.
