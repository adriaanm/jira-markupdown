I think there is a misunderstanding as to what an {{Ordering}} signifies in the context of a {{TreeMap}}: its main purpose is not to arrange the keys in a particular order (use {{x.keys.toSeq.sorted(Ordering.by(\_.size))}} for that if your order is in fact only a preorder), but it is used to relate objects according to a total order for the purpose of internal organization. In particular, this comprises treating objects {{x}} and {{y}} as *equal* if {{Ordering.equiv(x, y)}} is {{true}}. Since by passing Ordering.by(_.size) you establish equality between all strings of the same length in the context of the created map, the output is in fact correct/as expected.

What you would need in this context is a canonical ordering on strings, which could be implemented like this:
{code:scala}
object CanStringOrd extends Ordering[String] {
  def compare(x: String, y: String) =
    if (x.length != y.length) x.length - y.length
    else x.compareTo(y)
}
{code}
