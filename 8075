This isn't quite quite right, but it's getting somewhere.

{code}
:power
val u = rootMirror.universe; import u._, language._, intp.deconstruct.show
def show(t: Type) {println(t); println(show(t))}
class C[T] {
  sealed trait F[A <: T]
  object X {
    object S1 extends F[T]
  }
  class S2 extends F[T]
}
object O extends C[Int] {
  def foo(f: F[Int]) = f match { case X.S1 => }

  class S3 extends F[Int]
}

def subType(base: Symbol, sub: Symbol, baseType: Type) = {
  val subTpe = sub.tpeHK
  val widenNarrow = subTpe.map(_.widen.narrow)
  val clazz = subTpe.baseType(base).typeSymbol.owner
  val pre = baseType.prefix
  val seen = widenNarrow asSeenFrom (baseType.prefix, clazz)
  val result = seen.widen

  def tpToString(t: Type) = t.toString.replaceAllLiterally("$iw.", "")
  def p(label: String)(t: Type) = println(s"$label: ${tpToString(t)}")
  println(s"subtype(base = $base, sub = $sub, baseType = ${tpToString(baseType)}")
  println(s"(${tpToString(widenNarrow)}).asSeenFrom(${tpToString(pre)}, $clazz) = ${tpToString(seen)}")
  p("result")(result)

  result
}

val S1 = typeOf[c.X.S1.type forSome { val c: C[_] }].typeSymbol.tpeHK
val S2 = typeOf[O.S2].typeSymbol.tpeHK
val S3 = typeOf[O.S3].typeSymbol.tpeHK
val F = typeOf[c.F[_] forSome { val c: C[_] }].typeSymbol.tpeHK
val fTpe = typeOf[O.type].decl(newTermName("foo")).paramss.head.head.tpe

subType(F.typeSymbol, S1.typeSymbol, fTpe)

subType(F.typeSymbol, S2.typeSymbol, fTpe)

subType(F.typeSymbol, S3.typeSymbol, fTpe)
{code}
