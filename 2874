This is an (arguably not very nice) side-effect of Scala's notion of weak conformance between numeric value types (see ï¿½3.5.3 of the [http://www.scala-lang.org/archives/downloads/distrib/files/nightly/pdfs/ScalaReference.pdf Scala reference 2.8]). Weak conformance allows (amongst other things) to pass a lesser numeric value to a method that expects a bigger one:

{code}
def f(l: Long) = ...
f(1)
{code}

Autoboxing is defined in Scala as a serie of implicit methods in `scala.Predef` such as `int2Integer(x: Int):java.lang.Integer` or `long2Long(x: Long):java.lang.Long`. But because of weak conformance, an `Int` can be autoboxed both to Integer or Long, leading to the ambiguity above.

Weak conformance is very useful in many cases, and won't go away. The current implementation of autoboxing is elegant (reuses the existing implicit infrastructure) and works in most cases. Now, Martin and I agree that the example given in this ticket is unpleasant. Unfortunately, we fear that there is not much that can be done about it. If you think this is not true, we would be very interested in hearing about your idea in the form of a [http://www.scala-lang.org/sids SID].

Note that there is a workaround for your issue:

{code}
var num1 = retrieve(int2Integer(1))
var num2 = retrieve(long2Long(1L))
{code}
