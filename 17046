{code}
object Test {
  def goo[T](x: Int => T): T = x(1)
  implicit def f(x: Int): String = ""
  def foo(x: Int): Int = x + 1
  val x: String = goo(foo _)
  def foo(x: String => String) = 1
}
{code}
Error message is quite confusing: 
error: type mismatch;
found   : <error>
required: Int => String
val x: String = goo(foo _)

First of all, in this example it's quite simple to choose right 'foo' function.
However even overload resolution fails, error should be about overload resolution, not about "<error>" type.
