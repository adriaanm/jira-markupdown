As far as I can tell, this is really related to the other ticket. Here is what happens without specialization.

Scala:

{code}
import scala.runtime.BoxedUnit

object japi {
  trait MyFunction[-T, +R] {
    def apply(t: T): R
  }
  
  @deprecated("Do not use this directly, use subclasses of this", "2.0")
  class UnitFunctionBridge[-T] extends MyFunction[T, BoxedUnit] {
    override final def apply(t: T): BoxedUnit = {
      internal(t)
      BoxedUnit.UNIT
    }
    protected def internal(result: T): Unit = ()
  }
}

abstract class Foreach[-T] extends japi.UnitFunctionBridge[T] {
  override final def internal(t: T): Unit = each(t)

  /**
   * This method will be invoked once when/if a Future that this callback is registered on
   * becomes successfully completed
   */
  @throws(classOf[Throwable])
  def each(result: T): Unit
}
{code}


Java:

{code}
public class Test {
    
    public void mustBeAbleToForeachAFuture() throws Throwable {
	new Foreach<String>() {
		public void each(String future) {
		}
	    };
    }
    
}
{code}


Result after running:

{code}

java.lang.NoSuchMethodException: Test.main([Ljava.lang.String;)
	at java.lang.Class.getMethod(Class.java:1622)
	at scala.tools.nsc.util.ScalaClassLoader$class.run(ScalaClassLoader.scala:67)
	at scala.tools.nsc.util.ScalaClassLoader$URLClassLoader.run(ScalaClassLoader.scala:139)
	at scala.tools.nsc.CommonRunner$class.run(ObjectRunner.scala:28)
	at scala.tools.nsc.ObjectRunner$.run(ObjectRunner.scala:45)
	at scala.tools.nsc.CommonRunner$class.runAndCatch(ObjectRunner.scala:35)
	at scala.tools.nsc.ObjectRunner$.runAndCatch(ObjectRunner.scala:45)
	at scala.tools.nsc.MainGenericRunner.runTarget$1(MainGenericRunner.scala:70)
	at scala.tools.nsc.MainGenericRunner.process(MainGenericRunner.scala:92)
	at scala.tools.nsc.MainGenericRunner$.main(MainGenericRunner.scala:101)
	at scala.tools.nsc.MainGenericRunner.main(MainGenericRunner.scala)
{code}

I would reassign this.
