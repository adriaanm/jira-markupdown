Replying to [comment:2 dubochet]: 
> Which looks strange (why the wrapIntArray on the second argument only?)

Turns out that's because all the scala.Array primitive applies look like this:
{code}
  def apply(x: Int, xs: Int*): Array[Int] = {
{code}
Presumably because otherwise all the overloads look the same after erasure.

I propose that the thing it's trying to do, which doesn't work in the fashion it's trying:
{code}
$$asInstanceOf[Array[java.lang.Object]]
{code}
should exist as a method on WrappedArray with a name like "toBoxed".  It would be plus or minus:
{code}
def toBoxed: Array[AnyRef] = array map (_.asInstanceOf[AnyRef])
{code}
