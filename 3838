Replying to [comment:2 dubochet]: 
> Which looks strange (why the wrapIntArray on the second argument only?)

Turns out that's because all the scala.Array primitive applies look like this:
```scala
  def apply(x: Int, xs: Int*): Array[Int] = {
```
Presumably because otherwise all the overloads look the same after erasure.

I propose that the thing it's trying to do, which doesn't work in the fashion it's trying:
```scala
$$asInstanceOf[Array[java.lang.Object]]
```
should exist as a method on WrappedArray with a name like "toBoxed".  It would be plus or minus:
```scala
def toBoxed: Array[AnyRef] = array map (_.asInstanceOf[AnyRef])
```
