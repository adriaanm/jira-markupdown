Take a good look at the typer output.  It looks like the implicit is acting on the argument to getOrElse even though the whole expression would typecheck fine if it would just evaluate the getOrElse and then consider the annotation.  Is it working backward from the :Q annotation and trying to convert that, then deciding the whole expression is Object? Anyway:

{code}
object Test1
{
  class Q
  implicit def string2q(s: String): Q = new Q

  def main(args: Array[String]): Unit = {
    val x: Option[String] = Some("abc")
    
    // -Xprint:typer says:
    // x.getOrElse[String]("") match {
    x.getOrElse("") match { case _ => () }
    
    // -Xprint:typer says:
    // (x.getOrElse[java.lang.Object](Test1.this.string2q("")): Test1.Q) match {
    (x.getOrElse(""): Q) match { case _ => () }
  }
}
{code}
Compilation failure on second variation:
{code}
b.scala:28: error: type mismatch;
 found   : java.lang.Object
 required: Test1.Q
    ((x.getOrElse("")): Q) match { case _ => () }
                 ^
{code}
