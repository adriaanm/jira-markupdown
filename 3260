ugh... minimal test case:

{code}
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter
import javax.xml.bind.annotation.adapters.XmlAdapter

// abstract class StringOptionAdapter extends XmlAdapter[String, Option[String]] // this causes XmlAdapter to be cooked, 
// so that the bound `XmlAdapter` in `XmlJavaTypeAdapter`'s field  `value` with type:
//  `Class<? extends XmlAdapter>` becomes `XmlAdapter[_, _]`

// does not type check unless above definition is uncommented
case class Link(@XmlJavaTypeAdapter(classOf[XmlAdapter[String, Option[String]]]) val title: Option[String])
{code}


I almost daren't suggest it, but here's a patch that "fixes" this bug (and probably introduces another one... like relaxing kind-checking when java and scala type constructors are mixed :-s)

in   `def isHKSubType0(tp1: Type, tp2: Type, depth: Int): Boolean = ...`
{code}
-      case (_, _) => false // @assume !tp1.isHigherKinded || !tp2.isHigherKinded 
-      // --> thus, cannot be subtypes (Any/Nothing has already been checked)
+      case (_, _) => 
+        // @assume !tp1.isHigherKinded || !tp2.isHigherKinded 
+        // --> thus, cannot be subtypes (Any/Nothing has already been checked)
+        // last chance: try cooking java types... YUCK
+        @inline def HK2Raw(tp: Type): Type = if(tp.isHigherKinded) rawToExistential(tp) else tp
+        val tp1r = HK2Raw(tp1) 
+        val tp2r = HK2Raw(tp2)
+        !(tp1r.isHigherKinded || tp2r.isHigherKinded) && (tp1r <:< tp2r)
{code}

Martin: what do you think?
