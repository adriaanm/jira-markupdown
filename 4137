Actually this is the way it is described in the SLS ï¿½7.2 as far as I understand it. Wanted.Default is an implicit value of the type Wanted.Default.type that extends Wanted (i.e. not only of type Wanted). Following the rules defined in that section it gets selected because it is the most specific argument provided. That would explain why you get the same output if you change it e.g. to
```scala
implicit lazy val Default = new Something with Wanted
```

So even if you would unify them - in this case the problem would remain unless you change the rules for providing implicit arguments.

Even more confusing is this one:
```scala
case class X(y: Int)

implicit def int2xM(i: Int) = X(i)

implicit val int2xF: Int => X = X(_)

implicit object int2xO { def apply(i: Int) = X(i) }

def action[A <% X](a: A): X = a
```

Compiles fine - but without carefully reading the SLS you have no idea what is happening here (it's object before val before def in this case).
