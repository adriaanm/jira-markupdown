I'm not sure there's anything more which can be done usefully in JavaConversions ... the following already works,

{code}
scala> import scala.collection.JavaConversions._                        
import scala.collection.JavaConversions._

scala> val m = new java.util.concurrent.ConcurrentHashMap[Int, String]  
m: java.util.concurrent.ConcurrentHashMap[Int,String] = {}

scala> m += (1 -> "1", 2 -> "2", 3 -> "3")                              
res0: scala.collection.mutable.Map[Int,String] = Map(2 -> 2, 1 -> 1, 3 -> 3)

scala> m
res1: java.util.concurrent.ConcurrentHashMap[Int,String] = {2=2, 1=1, 3=3}

scala> m(2)
res2: String = 2

scala> m.putIfAbsent(3, "23")                                           
res3: String = 3

scala> m.putIfAbsent(4, "4") 
res4: String = null

scala> m.clone              
<console>:9: error: method clone cannot be accessed in java.util.concurrent.ConcurrentHashMap[Int,String]
       m.clone
         ^
{code}

This really leaves only the improved signature for putIfAbsent (ie. returning an Option, rather than using null to indicate None) and it feels like this would be best supported by adding that method to the main Scala Map trait.
