Here is an example where catch needs  full context:
{code}
val result2 = try {
 val result1 = doThis()// can throw IOException
 doThat(result1) //can throw IOException
} catch {
 case _ => //want to rethrow with a descriptive message, but need to know which statement failed
  if (result1==null)
    throw new DescriptiveException("doThis failed")
  else
    throw new DescriptiveException("doThat failed", result1)
}
{code}
If we need to achieve the same thing with current implementation, we would have to take result1 out of try scope, and possibly enclose EVERY statement in try/catch 
{code}
val result1 = try {
 doThis()// can throw Exception
 } catch {
 case _ => 
  throw new DescriptiveException("doThis failed")
}

val result2 = try {
  doThat(result1) //can throw Exception
} catch {
 case _ =>
  throw  new DescriptiveException("doThat failed", result1)
}
{code} 
OR
{code}
var result1 = null
val result2 = 
try {
 result1 = doThis()// can throw Exception
 doThat(result1) //can throw Exception
} catch {
 case _ => //want to rethrow with a descriptive message, but need to know which statement failed
  if (result1==null)
   throw new DescriptiveException("doThis failed")
  else
   throw new DescriptiveException("doThat failed", result1)
}
{code}
In real life you may have a dozen inter-related statements in a row, each resulting in some useful context, and each can throw, so multiple try/catch and/or external variables get quite messy

Also, suppose result1 needs to be 'closed' (has a resource handle, like DB connection). It is simple with what I am proposing:
{code}
val result2 = try {
 val result1 = doThis()// can throw IOException
 doThat(result1) //can throw IOException
} catch {
 case _ => //want to rethrow with a descriptive message, but need to know which statement failed
  if (result1==null)
    throw new DescriptiveException("doThis failed")
  else
    throw new DescriptiveException("doThat failed", result1)
} finally {
  if (result1!=null) close(result1)
}
{code}
Typically objects should not be used after they have been closed.  Since both examples of current implementation have moved result1 to external scope, we need yet another try/finally to close it and ensure it is out of scope for the rest of the code:
{code}
try { 
 var result1 = null
 val result2 = 
 try {
  result1 = doThis()// can throw Exception
  doThat(result1) //can throw Exception
 } catch {
  case _ => //want to rethrow with a descriptive message, but need to know which statement failed
   if (result1==null)
    throw new DescriptiveException("doThis failed")
   else
    throw new DescriptiveException("doThat failed", result1)
 }
} finally {
 if (result1!=null) close(result1)
}
{code}
It gets messier and messier...
