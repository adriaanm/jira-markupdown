According to the spec Section 5.1.4, overriding is to be done on superclasses (or super-traits). Therefore, if C'.M' is marked "abstract override" and is overriding abstract method C.M, C' cannot be instantiated until a definition of C.M is provided.

The compiler is too lenient about where a definition of C.M comes from. The provided method should not only have name M, but should also override C.M, but the typechecker does not seem to check the second property.
```scala
trait Node { def eval: Int }

trait DebugNode extends Node {
  abstract override def eval: Int = {
    println("before")
    val res = super.eval
    println("res= "+res)
    res
  }
}

(new Var with DebugNode).eval // typechecks, correct

class Foo { def eval = 42 }

// should *not* typecheck but does!
(new Foo with DebugNode).eval // Foo.eval does not override Node.eval, but typechecker accepts this anyway
```

Proposed fix:
Check if method M exists **and also** overrides C.M (in this example, Node.eval).
