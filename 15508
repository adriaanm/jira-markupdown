Negative number literals are handled inconsistently for floating point numbers and integral numbers:
```scala
Welcome to Scala version 2.8.0.RC6 (Java HotSpot(TM) 64-Bit Server VM,
Java 1.6.0_20).
Type in expressions to have them evaluated.
Type :help for more information.

scala> -33.5f max 33
res0: Float = 33.0

scala> -33.5f.max(33)
res1: Float = -33.5

scala> -34 max 33
res2: Int = 33

scala> -34.max(33)
<console>:1: error: ';' expected but '.' found.
      -34.max(33)
         ^
```

Part of the problem is the fix for scala/bug#2378 in r19950 which replaces an floating point integer ~~5.63 by 5.63.unary_~~.

Here's my analysis which I posted on the mailing list as well:

I've done some diggin' (and moved to internals):

Originally(*), and despite of the language specification (**),
negative number literals could not appear in a select expression
(-1.max(5)). Since r19950 which 'fixed' scala/bug#2378 (***), the balance
between integer and floating point literals drifted: for with what the
parser was concerned, negative floating point literals received no
special treating any more, so -5f.max(2) was seen as
(5f.max(2)).unary_-, simple negative floating literals as 5f.unary_-
(*!*). For negative integer literals the situation stayed the way it
was the way before: -1.max(5) was simply not allowed by the parser.

IMO the least surprising behaviour would be if

-5f.max(2)
-5f max 2
-5.max(2)
-5 max 2

would all consistently return 2. Negative number literals are negative
number literals are negative number literals.

To make that work one could use a patch like that:
```scala
--- a/src/compiler/scala/tools/nsc/ast/parser/Parsers.scala
+++ b/src/compiler/scala/tools/nsc/ast/parser/Parsers.scala
@@ -1243,7 +1243,7 @@ self =>
          val name = unaryOp()
          in.token match {
            // Don't include double and float here else we lose -0.0
-            case INTLIT | LONGLIT => literal(true)
+            case INTLIT | LONGLIT | FLOATLIT | DOUBLELIT => simpleExprRest(atPos(in.offset)(literal(true)),true)
            case _ => Select(stripParens(simpleExpr()), name)
          }
        }
```

and then fix scala/bug#2378 properly by fixing fjbg. It has a small regression
risk because of the new behaviour introduced by the fix for scala/bug#2378
(which the OP was about). That's a pity because the new and
inconsistent behaviour will probably ship with 2.8.0.


 * (*) That's r3930, the commit with the unimpressive empty log message where nsc sprang to life.
 * (**) The SLS would allow both 5.unary_- and the literal -5 and does at least not specify how to resolve this ambiguity.
 * (***) The real cause of SI-2378 can be found in the backyard of the backend: FJBG generates a DCONST_0 if a double literal == 0.0, what -0.0 is.
 * (*!*) This behaviour caused SI-3486, where negative constants in annotations wouldn't be possible any more.
