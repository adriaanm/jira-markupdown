The compilation scheme given in the bug report corresponds to the mono-cache implementation, which is no longer used (it can still be forced using the `-Ystruct-dispatch` flag, but will probably be removed soon as it is slower in all cases). The current standard compilation scheme compiles a call as follows:

{code}
 var reflParams$$Cache: Array[Class[_]] = Array[JClass](classOf[A], classOf[B])
 var reflPoly$$Cache: scala.runtime.MethodCache = new EmptyMethodCache()
def reflMethod$$Method(forReceiver: JClass[_]): JMethod = {
  var method: JMethod = reflPoly$$Cache.find(forReceiver)
  if (method != null)
    return method
  else {
    method = forReceiver.getMethod("xyz", reflParams$$Cache)
    reflPoly$$Cache = reflPoly$$Cache.add(forReceiver, method)
    return method
  }
}
{code}

My analysis is that this method can run unsynchronized in a multi-threaded environment. In the worst case, a method looked-up by one thread will not be cached (it could be overwritten by another thread). However, the system still is safe as the method can always be recalculated afterwards (it is only a cache), and the caching data structure is not harmed by the threads interacting.

I cannot observe any problem in the example provided by dpp using the latest trunk. I ran it a few times on an 8-core machine, including once for almost one hour, without any exception happening. Maybe I am looking at the wrong place. dpp, if you think I closed the bug wrongfully, can you be more specific as to how to reproduce the bug (including the hardware you use, the observed behaviour and the expected behaviour).
