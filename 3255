Thanks for the answer, you are right I have not seen that message, I am compiling with maven which obscure many messages. I will compile directly next time to see if something like that comes up.

The question I have is why then overriding the method with exactly the same code works? shouldn't the method be compiled when the abstract types are resolved? 

My understanding was that when a Trait has implemented methods and is mixed in with a class, the result should be equal to inherit and interface and implement on place. From this it looks that the method gets compiled and then the compiled method is plug into the class you are mixin in, which make them (IMHO) unsafe to be used with abstract members (at least types). 

I see your point about the structural type, but again the type is later set to a concrete class. I just used because the following gives a compiler error:

{code}
trait Value {
    type T
    protected val value: T
    type Self <: Value

    def myType: String

    protected def newValue(newVal: T): Self
    override def hashCode = value.hashCode
    override def equals(other: Any): Boolean = other match {
        case that: Self =>
          println(myType)
          this.value == that.value
        case _ => false
    }
}

{code}

PS: Does erasure means that structural types should not be used with pattern matching?
