I am not sure if this is a bug. The code runs fine. Given:
```scala
case class Two[@specialized A, @specialized B](v: A, w: B);
println(Two("Hello", 12).getClass().getName());
println(Two("Hello", "World").getClass().getName());
println(Two(12,12).getClass().getName());
```
In the first two cases the non-specialized version of Two is constructed. I expect the first println to show that the choice of a specialized version, for the second parameter (it is not). I expect the generic version to be chosen for the second (it is). I expect the specialized version to be chosen for the third (it is).


It's not clear to me whether this behavior is in the spec or not -- must all type parameters annotated with @specialized be primitive, in order for a primitive to be selected? Or is the mixture of object and primitive just not covered?

Apologies if this is covered somewhere already in the spec. 
