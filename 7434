the existential in other's type in the second overload breaks type inference 
there's no way to derive T by comparing Const[ExtDouble] to Const[_ <: CC[T]]

this works:

{code}
class Expr[T] {
  def *(other: Expr[T]): Expr[T] = null
  def *[C <: CC[T]](other: Const[C]): Const[C] = null
}

case class Const[T](value: T) extends Expr[T]
class CC[T]
case class ExtDouble(value: Double) extends CC[Double]

object Test extends App {
  implicit def double2Const[T](value : Double): Const[T] = Const(value.asInstanceOf[T])

  double2Const(2.0) * Const(ExtDouble(2.0))
}
{code}
