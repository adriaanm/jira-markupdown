I am not sure what you mean above by 'type check'. It is important to add "import scalafx.Includes._" that pulls a lot of implicit that may "type check" the code above, for instance, for assignment "onAction = {ae: ActionEvent => ...}" 

new SplitMenuButton()  should get a default constructor parameter supplied (delegate = new jfxsc.SplitMenuButton()).

Sorry I an not able to provide a reduced example. In simple examples similar code with one of the constructor had a default parameter and other has a has a T* argument compiles fine. There looks to be something more involved here. I look more tomorrow. Some other way of simplifying this is below.

A thing that may help is that if I use scalafx library (build for 2.10) but 2.11.0-M8 compiler and try to instantiate `SplitMenuButton` 
```
import scalafx.scene.control.SplitMenuButton

class A { 
  val a = new SplitMenuButton()
}
```

I get similar error
```
[error] ....scala:6: ambiguous reference to overloaded definition,
[error] both constructor SplitMenuButton in class SplitMenuButton of type (items: scalafx.scene.control.MenuItem*)scalafx.scene.control.SplitMenuButton
[error] and  constructor SplitMenuButton in class SplitMenuButton of type (delegate: javafx.scene.control.SplitMenuButton)scalafx.scene.control.SplitMenuButton
[error] match argument types ()
[error]   val a = new SplitMenuButton
[error]           ^
[error] one error found
```

Just for a reference SBT setup looks like this:
```
scalaVersion := "2.11.0-M8"

libraryDependencies += "org.scalafx" % "scalafx_2.10" % "1.0.0-M7"

resolvers += "Sonatype OSS Snapshots" at "https://oss.sonatype.org/content/repositories/snapshots"

scalacOptions ++= Seq("-unchecked", "-deprecation", "–explaintypes", "–Xlint")

unmanagedJars in Compile += Attributed.blank(file(System.getenv("JAVA_HOME") + "/jre/lib/jfxrt.jar"))
```

I need to run, I will try to attach a sample project tomorrow.
