Looking at that stacktrace, it seems an exception handler in part of the compiler that reads `.class` files it itself throwing that NPE, and consequently masking the exception. Reviewing the code, this might happen due to an IO error reading the file itself.

I've prepared a patch that would make this more robust: https://github.com/retronym/scala/tree/ticket/9282. I'll submit that for 2.11.7 as it is low risk.

Until then, to try to find the root problem, you could try to adding `-Ydebug` to your `scalacOptions`, that will print the stack trace of the original exception one line before the NPE.
```scala
// ClassfileParser.scala
  private def handleError(e: Exception) = {
    if (settings.debug) e.printStackTrace()
    throw new IOException(s"class file '${in.file}' is broken\n(${e.getClass}/${e.getMessage})") // NPE on this line, almost certainly because `in` is null.
  }
```

Wild guess: Maybe one part of your build is modifying class files in place in a way that SBT doesn't know about when deciding whether it is safe to parallelize tasks. To rule that out, you might try is disabling parallelism within the SBT build, by adding this setting to your build (http://www.scala-sbt.org/0.13/docs/Parallel-Execution.html):
```scala
parallelExecution := false
```
