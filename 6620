I sort of wish someone else had drawn this straw so I didn't have to be reminded of how little respect I am given and how the specification is used like some kind of wizardly bludgeoning device for which no explanations are necessary.  So I spent another few hours going line by line over the spec looking for the part which specifies this behavior so precisely that a ticket opened by the leading contributer of compiler code could be closed without even a citation.

Not only did I not find it, I can't find anything which unambiguously states what it even means to attach an access modifier to a type; there certainly is nothing about what happens under aliasing; and I'm dying to see the language which would allow one to discover the behavior demonstrated here.

For nine possible modifiers ("public", private[pkg], private[class], private[this], private, protected[pkg], protected[class], protected[this], protected) there are a total of two distinct behaviors shown in this code.  I await the elaboration of how the "nifty" difference alluded to but not given can explain the following.

The two behavior groupings are:

  private and private[this] - these are prevented from escaping everywhere
    except in method parameter positions, where escape is allowed
  everything else - everything acts the same as if public

Here is a comment.  The code I'll attach separately.
```
// These are members of class bar.C, completely unrelated to class foo.A.
// The types shown below include types defined within foo.A which are:
//
//   - qualified private
//   - qualified protected
//   - object protected
//
// val a : foo.A = { /* compiled code */ }
// val xprot1 : java.lang.Object with foo.A.FooProt1 = { /* compiled code */ }
// val xprot2 : java.lang.Object with foo.A.FooProt2 = { /* compiled code */ }
// val xprot3 : java.lang.Object with foo.A.FooProt3 = { /* compiled code */ }
// val xprot4 : java.lang.Object with foo.A.FooProt4 = { /* compiled code */ }
// val xpriv3 : java.lang.Object with foo.A.FooPriv3 = { /* compiled code */ }
// val xpriv4 : java.lang.Object with foo.A.FooPriv4 = { /* compiled code */ }
//
// Indeed it will tell me a type which I cannot access:
//
// scala> new bar.C
// res0: bar.C = bar.C@1339a0dc
// 
// scala> res0.xpriv3
// res1: java.lang.Object with res0.a.FooPriv3 = bar.C$$anon$29@39556aec
// 
// scala> new res0.a.FooPriv3
// <console>:9: error: trait FooPriv3 in class A cannot be accessed in foo.A
//               new res0.a.FooPriv3
//                          ^
// Looking at how the compiler prints the types of those vals, one
// develops a suspicion how some of it is being allowed:
//
// val xpriv4: C.this.a.FooPriv4
// val xpriv3: C.this.a.FooPriv3
// val xprot4: C.this.a.FooProt4
// val xprot3: C.this.a.FooProt3
// val xprot2: C.this.a.FooProt2
// val xprot1: C.this.a.FooProt1
// 
// That is, "this" is in the prefix somewhere, it's just not a "this"
// which has any bearing.
```
