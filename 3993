Hi, 

I've done some information finding on this bug, first by compiling the snippet with the compiler options 
```scala
-Xprint:icode -Xprint-icode
```

which allows seeing almost-bytecode-level what gets done: 
```scala
  1: 
    26	LOAD_MODULE object Predef
    26	LOAD_MODULE object Predef
    26	CONSTANT (Constant(1))
    26	CALL_METHOD scala.Predefscala.Predef.intWrapper (dynamic)
    26	CONSTANT (Constant(100000000))
    26	CALL_METHOD scala.runtime.RichIntscala.runtime.RichInt.to (dynamic)
    26	CALL_METHOD scala.collection.immutable.Range$$Inclusivescala.collection.SeqLike.hashCode (dynamic)
    26	BOX INT
    26	CALL_METHOD scala.Predefscala.Predef.println (dynamic)
    26	RETURN (UNIT)
```

First a RichInt is built for the "1", and then method RichInt.to is invoked on it with 100000000 as argument. That returns a Range (this and other sources at 

http://lampsvn.epfl.ch/trac/scala/browser/scala/trunk/src/library/scala/runtime/RichInt.scala

) and finally the implementation of hashCode defined in SeqLike gets run, i.e. 
```scala
  /** Hashcodes for $$Coll produce a value from the hashcodes of all the
   *  elements of the $$coll.
   */
  override def hashCode() = (Seq.hashSeed /: this)(_ * 41 + _.hashCode)
```


Thus explaining why it's slow. Actually long ago there used to be a custom hashCode implementation in Range, but: 
```scala
  /* eliminated, so as to not break the hashcode/equals contract 
  override def hashCode = start + limit + step
  */
```


The short answer is, hashCode will be slow on large sequences. 

