Explanation: we think that the bridge method for `apply$mcLI$sp` is something that should be added in `mixin`, as the specialization leaves enough information for it to do so.

The trees after specialize for the Scala file example from the bug report body:
```scala
package <empty> {
  abstract trait CustomFunction1[@specialized(scala.Int) T1 >: Nothing <: Any, @specialized(scala.`package`.AnyRef) R >: Nothing <: Any] extends Object {
    def apply(v1: T1): R;
    <specialized> def apply$mcLI$sp(v1: Int): R = CustomFunction1.this.apply(v1.asInstanceOf[T1]())
  };
  class UnitFunctionBridge[T >: Nothing <: Any] extends Object with CustomFunction1[T,scala.runtime.BoxedUnit] {
    def <init>(): UnitFunctionBridge[T] = {
      UnitFunctionBridge.super.<init>();
      ()
    };
    final override def apply(t: T): scala.runtime.BoxedUnit = scala.runtime.BoxedUnit.UNIT
  };
  abstract <specialized> trait CustomFunction1$mcLI$sp[R$sp >: Nothing <: AnyRef] extends Object with CustomFunction1[Int,R$sp] {
    <specialized> def apply(v1: Int): R$sp
  }
}
```

Observe `apply$mcLI$sp` and how its return type is `R`, not `AnyRef`. Also, note that this does not happen with abstract classes.

We think that `mixin` should add a bridge method in `UnitFunctionBridge` with a more refined return type. Instead, `R` is changed into `Object` during erasure, and `mixin` does not generate a version of `apply$mcLI$sp` with the return type `BoxedUnit`.

The other bug describes how generating this bridge is not done even when there is no specialization.
