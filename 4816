This doesn't work either, type inference can't simultaneously infer `N` and `R`.
```scala
case class P()
abstract class ImplicitRepeated[CC[N, R <: List[N]]] {
  def f[N, R <: List[N]](elems: Either[N,R]*) // alternative a)
  def f[N, R <: List[N]](props: P,
                         elems: Either[N,R]*) // alternative b) 
}
class Test[CC[N, R <: List[N]]] (c : ImplicitRepeated[CC]) {
  c.f( new P, Right(List(1))) // should be directly   resolved to alternative b)
}
```

So, let's work around that:
```scala
case class P()
abstract class ImplicitRepeated[CC[N, R <: List[N]]] {
  def f[N, R <: List[_]](elems: Either[N,R]*) // alternative a)
  def f[N, R <: List[_]](props: P,
                         elems: Either[N,R]*) // alternative b) 
}
class Test[CC[N, R <: List[N]]] (c : ImplicitRepeated[CC]) {
  c.f( new P, Right(List(1))) // should be directly   resolved to alternative b)
}
```

Still works with the implicits brought into scope:
```scala
case class P()
abstract class ImplicitRepeated[CC[N, R <: List[N]]] {
  def f[N, R <: List[_]](elems: Either[N,R]*) // alternative a)
  def f[N, R <: List[_]](props: P,
                         elems: Either[N,R]*) // alternative b) 
}
object Predef {
  implicit def anyToN[N] (x: N) = Left (x)
  // the following implicit causes "cannot be applied" errors
  implicit def anyToR[R <: List[_]] (x: R) = Right(x)
}
class Test[CC[N, R <: List[N]]] (c : ImplicitRepeated[CC]) {
  import Predef._

  c.f( new P, Right(List(1))) // should be directly   resolved to alternative b)
  // c.f( new P, 1, 2)           // should be implicitly resolved to alternative b)
  // c.f( 1, 2 )                 // should be implicitly resolved to alternative a)
}
```

With this in mind, could you please produce a simpler, smaller example to demonstrate the problem?
