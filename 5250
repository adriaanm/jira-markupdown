Replying to [comment:2 dft]:
> Replying to [comment:1 extempore]:
> But why is the expression x => si(dd(x))  accepted?

Because it never has to convert a function type.

The expression "(x: Int) => si(x)" types si(x), finds an Int where a Double is needed, and converts it.

The expression "(si compose d2)" types that, finds an Int => Int where a ? => Double is needed, and there is no conversion available.

> It seems that the compiler handels  si(dd(x)) in another way
> than (si compose dd)(x)

Yes, absolutely it does.  The function "compose" takes an argument of a function type.  This changes everything.
