Maybe I misunderstand why this was given the label "error-messages" but this isn't about error messages. Perhaps an example is needed where it DOES compile but should certainly NOT compile.
{code}
package p {
  package _root_ {
    package scala {
      sealed trait Option[+T] { def isEmpty = false ; def donkey = 5 }
      final case class None[T]() extends Option[T] { def get: T = null.asInstanceOf[T] }
      final case class Some[T](x: T) extends Option[T] { }
    }
  }
}
// Meanwhile, in some other file
package p {
  object Test {
    import _root_.scala.Option
    def f[T](x: Option[T]) = x.donkey
  }
}
{code}
There is no "donkey" method on __root__ .scala.Option. If __root__ is to behave like any other relative package, then there is quite literally no reason for it to exist.

And conversely, this does NOT compile, but certainly SHOULD. __root__.scala.Option does have a "get" method.
{code}
package p {
  object Test2 {
    import _root_.scala.Option
    def f[T](x: Option[T]) = x.get
    // ./a.scala:18: error: value get is not a member of p._root_.scala.Option[T]
    //     def f[T](x: Option[T]) = x.get
    //                                ^
    // one error found
  }
}
{code}
