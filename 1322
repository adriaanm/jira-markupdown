Yes, that is indeed a disadvantage. I also thought of another approach, which is cleaner, but the worry is that it might break old code: We need to work out carefully what is known about the type of a variable in a binder. The variable certainly has the pattern's expected type. And some patterns also contribute type information. The intersection of these two types would then be the type of the variable.

For instance:

val foo: List[String]

foo match {
  case n @ Nil => ... // expected type: List[String], pattern type: ?
  case c: ::[_] =>    // expected type: List[String], pattern type: ::[?]
  ...
}

In the first case, the best type for n is List[String], the expected type.
In the first case it would be List[String] with ::[?], and by some other piece
of not yet implemented type checking inference we could infer this to be equal to
::[String].

I think this would be the most logical approach. But I am not sure how many old programs would break, because some variables would get assigned weaker types than before.

Anyway, it looks more and more like there is a paper in this. Things are far from trivial. 
