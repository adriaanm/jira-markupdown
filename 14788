The following code generates several val defs where 'arg' is given the same symbol. It only works now because they are always assigned the same thing, so the fact that only one physical location is used does not matter.

This affects the backend in another way, when it emits variable ranges for debug info. Currently it ignores such cases, keeping them in scope until the end of the method. However, for the jvm-1.6 target, type information about such locals should be emitted only when they are in scope. Unhappiness hits.
```scala
class Foo {
  def stringOf(arg : Any): String = arg match {
    case arg: List[_] => arg.toString
    case _ => arg.toString
  }
}
```

after explcit outer:
```scala
    def stringOfSI-8520(argSI-9938: AnySI-22): java.lang.StringSI-1655 = {
      var temp1SI-10756: AnySI-22 = argSI-9938;
      if (temp1SI-10756.isInstanceOfSI-3915[List[_SI-9993]]())
        {
          {
            var temp2SI-10757: List[_SI-9993] = temp1SI-10756.asInstanceOfSI-3918[List[_SI-9993]]();
            {
              {
                val argSI-9992: List[_SI-9993] = temp2SI-10757;
                if (true)
                  {
                    {
                      val argSI-9992: List[_SI-9993] = temp2SI-10757;
                      body%0SI-10764(argSI-9992){
                        argSI-9992.toStringSI-10308()
                      }
                    }
                  }
                else
                  throw new MatchErrorSI-788(temp1SI-10756.toStringSI-3914())
              }
            }
          }
        }
      else
        {
          if (true)
            {
              body%1SI-10829(){
                argSI-9938.toStringSI-3914()
              }
            }
          else
            throw new MatchErrorSI-788(temp1SI-10756.toStringSI-3914())
        }
    }
  }
```
