Maybe the missing param type exception for function literals can be extended to this case, so that a single missing type param is inferred from the type args of the candidate expected types.

Problem statement:
```scala
scala> class D[A] ; class C[A] { def f(x: C[A]): C[A] = new C[A] ; def f(x: D[A]): D[A] = new D[A] }
defined class D
defined class C

scala> def d[A]: D[A] = new D[A]
d: [A]=> D[A]

scala> new C[String]().f(d)
<console>:14: error: overloaded method value f with alternatives:
  (x: D[String])D[String] <and>
  (x: C[String])C[String]
 cannot be applied to (D[Nothing])
       new C[String]().f(d)
                       ^
```
This is not a workaround.
```scala
scala> class D[A] ; class C[A] { def f(x: A => C[A]): C[A] = new C[A] ; def f(x: A => D[A]): D[A] = new D[A] }
defined class D
defined class C

scala> def d[A]: D[A] = new D[A]
d: [A]=> D[A]

scala> new C[String]().f(x => d)
<console>:14: error: overloaded method value f with alternatives:
  (x: String => D[String])D[String] <and>
  (x: String => C[String])C[String]
 cannot be applied to (String => D[Nothing])
       new C[String]().f(x => d)
                       ^

scala> new C[String]().f(x => d[x.type])
<console>:14: error: overloaded method value f with alternatives:
  (x: String => D[String])D[String] <and>
  (x: String => C[String])C[String]
 cannot be applied to (String => D[_ <: String with Singleton])
       new C[String]().f(x => d[x.type])
                       ^
```
