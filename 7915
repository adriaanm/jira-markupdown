Paul: I get that eta-expansion never produces a function type containing a repeated parameter, but such function types are still valid value types, yes? I can still write

{code}
val f: (String*) => Int = new ((String*) => Int) {
  def apply(xs: String*) = 5
}

f("hello", "world")
{code}

Not a method type to be seen, just an anonymous class implementing a valid value type.

Jason: I agree that the conformance relation of function types with repeated parameters is underspecified. The existence of those types, however, seems less ambiguous:

Syntax:
{noformat}
Type         ::= FunctionArgs '=>' Type
FunctionArgs ::= '(' [ ParamType {',' ParamType } ] ')'
ParamType    ::= Type '*'
{noformat}

Semantics:
{quote}
Function types are shorthands for class types that define {{apply}} functions.
{quote}

(In particular, this does not say "function types are shorthands for method types".)

So since Any { def apply(xs: String*): Int } is a valid (value, not method!) type, ((String*) => Int) is as well, right?
