The compiler error is the following:

{code:text}
Error:(17, 32) overloaded method value serve with alternatives:
  (addr: String,service: com.twitter.finagle.Service[Req,Rep])com.twitter.finagle.ListeningServer <and>
  (addr: String,service: com.twitter.finagle.ServiceFactory[Req,Rep])com.twitter.finagle.ListeningServer <and>
  (addr: java.net.SocketAddress,service: com.twitter.finagle.Service[Req,Rep])com.twitter.finagle.ListeningServer <and>
  (addr: java.net.SocketAddress,service: com.twitter.finagle.ServiceFactory[Req,Rep])com.twitter.finagle.ListeningServer
 cannot be applied to (String, com.twitter.finagle.Service[fortress.net.FtReq,fortress.net.FtRep])
  val serv = Await.result(server.serve(":12345", echoService))
                               ^
{code}

Where:

{code:Scala}
type FtReq = String
type FtRep = String
{code}

The definition of server is as follows: 

{code:Scala}
package server {
  // ... omitted definitions
}

package object server extends Server[FtReq, FtRep] {
  // materialized fortress server factory with the default stack and parameters
  val factory = FtServer()

  // pass through to the underlying stack based server
  override def serve(addr: SocketAddress, service: ServiceFactory[FtReq, FtRep]): ListeningServer = {
    factory.serve(addr, service)
  }
}
{code}

It is already suspicious that the required overload is reported by the compiler as being there. There is enough room to suspect user error, but when I change {{package object server}} into {{object blam}} and call {{blam.serve}}, it compiles fine.

I'm not sure if I'm abusing package objects in some way that I'm unaware of; but even if I am, I would expect a more precise error message. 
