I just found scala/bug#1697, which sounds similar.

This code:
```scala
  def matchBroken(element: PsiElement) = element match {
    case RealPsiClass(c) => "matched: RealPsiClass(c)"
    case x: ScNamedElement => "matched: x: ScNamedElement"
    // This is matched if element is a ScTypeParam, should have been the previous case.
    case x if x.isInstanceOf[ScNamedElement] => "matched: x if x.isInstanceOf[ScNamedElement]"
    case _ => "matched _"
  }
```

compiled against a r18583, then decompiled with JAD, gives: 
```scala
  public String matchBroken(PsiElement element) {
    PsiClass temp2;
    if (element instanceof PsiClass) {
      if (RealPsiClass$$.MODULE$$.unapply(temp2 = (PsiClass) element).isEmpty()) {
        if (gd1$$1(temp2)) {
          return "matched: x if x.isInstanceOf[ScNamedElement]";
        } else {
          return "matched _";
        }
      } else {
        return "matched: RealPsiClass(c)";
      }
    }
    else if (element instanceof ScNamedElement) {
      return "matched: x: ScNamedElement";
    } else if (gd1$$1(element)) {
      return "matched: x if x.isInstanceOf[ScNamedElement]";
    }
    return "matched _";
  }
```

Removing the first case, which uses an extractor object, fixes the problem.

When I tried to make this a stand-alone example, replacing all referenced types with scala traits, the problem disappears. Maybe having a java super-interface has some impact.

Still digging :(
