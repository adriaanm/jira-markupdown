The clash may be unavoidable, but it doesn't follow that it can't be fixed. The conflicting bridge method is being created to forward to the method with which it is conflicting. What is the problem with just not generating the bridge, if the implementation has the same signature?

Here, this has the same problem without value class involvement. The bridge method, were it to be generated, will conflict with the definition of the member itself.
{code}
class Bippy {
  val test: Object => Object = x => x
  // Only gets (Object)Object
}
{code}
But it isn't a problem, because we use the implementation to satisfy the requirement for an (Object)Object method. In all other cases, there is a bridge:
{code}
class Dingo {
  val test: String => String = x => x
  // Gets (String)String and (Object)Object
}
{code}
