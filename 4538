As brought up on the mailing list, this still appears to be a problem.  Here are the implicits in trunk.
```scala
implicit def asJavaCollection[A](i : Iterable[A]): ju.Collection[A] 
implicit def asJavaConcurrentMap[A, B](m: mutable.ConcurrentMap[A, B]): juc.ConcurrentMap[A, B] 
implicit def asJavaDictionary[A, B](m : mutable.Map[A, B]): ju.Dictionary[A, B] 
implicit def asJavaEnumeration[A](i : Iterator[A]): ju.Enumeration[A] 
implicit def asJavaIterable[A](i : Iterable[A]): jl.Iterable[A] 
implicit def asJavaIterator[A](i : Iterator[A]): ju.Iterator[A] 
implicit def asJavaList[A](b : Seq[A]): ju.List[A] 
implicit def asJavaList[A](b : mutable.Buffer[A]): ju.List[A] 
implicit def asJavaList[A](b : mutable.Seq[A]): ju.List[A] 
implicit def asJavaMap[A, B](m : Map[A, B]): ju.Map[A, B] 
implicit def asJavaMap[A, B](m : mutable.Map[A, B]): ju.Map[A, B] 
implicit def asJavaSet[A](s : mutable.Set[A]): ju.Set[A] 
implicit def asJavaSet[A](s: Set[A]): ju.Set[A] 
implicit def asScalaBuffer[A](l : ju.List[A]): mutable.Buffer[A] 
implicit def asScalaConcurrentMap[A, B](m: juc.ConcurrentMap[A, B]): mutable.ConcurrentMap[A, B] 
implicit def asScalaIterable[A](i : jl.Iterable[A]): Iterable[A] 
implicit def asScalaIterable[A](i : ju.Collection[A]): Iterable[A] 
implicit def asScalaIterator[A](i : ju.Iterator[A]): Iterator[A] 
implicit def asScalaMap(p: ju.Properties): mutable.Map[String, String] 
implicit def asScalaMap[A, B](m : ju.Map[A, B]): mutable.Map[A, B] 
implicit def asScalaSet[A](s : ju.Set[A]): mutable.Set[A]   
```

That reveals duplicates for asJavaList, asJavaMap, asJavaSet, asScalaIterable, and asScalaMap.
