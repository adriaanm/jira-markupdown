```scala
import scala.reflect.mirror._

object Test extends App {
  def fooNoTypeTagHK[C[_], T] = {
    println(implicitly[TypeTag[C[T]]])
    println(implicitly[TypeTag[List[C[T]]]])
  }
  fooNoTypeTagHK[List, Int]
}
```
```scala
materializing requested reflect.mirror.type.TypeTag[C[T]] using `package`.this.materializeTypeTag[C[T]](scala.reflect.`package`.mirror)
looking for macro implementation: macro method materializeTypeTag
macroDef is annotated with: List(scala.reflect.makro.internal.macroImpl(`package`.this.materializeTypeTag_impl[T]))
resolved implementation method materializeTypeTag_impl at NoPosition
primary macro mirror: initializing from -cp: List(file:/c:/PROGRA~1/Java/JDK16~1.0_2/jre/lib/resources.jar, file:/c:/PROGRA~1/Java/JDK16~1.0_2/jre/lib/rt.jar, file:/c:/PROGRA~1/Java/JDK16~1.0_2/jre/lib/jsse.jar, file:/c:/PROGRA~1/Java/JDK16~1.0_2/jre/lib/jce.jar, file:/c:/PROGRA~1/Java/JDK16~1.0_2/jre/lib/charsets.jar, file:/c:/PROGRA~1/Java/JDK16~1.0_2/jre/lib/ext/dnsns.jar, file:/c:/PROGRA~1/Java/JDK16~1.0_2/jre/lib/ext/localedata.jar, file:/c:/PROGRA~1/Java/JDK16~1.0_2/jre/lib/ext/sunjce_provider.jar, file:/C:/Projects/Kepler/lib/fjbg.jar, file:/C:/Projects/Kepler/build/locker/classes/compiler/, file:/C:/Projects/Kepler/build/locker/classes/library/, file:/C:/Projects/ScalaQuery/bin/scalaquery_2.9.1-0.10.0-SNAPSHOT.jar, file:/C:/Projects/Kepler/test/pending/run/macro-reify-typetag-hktypeparams-notags/./, file:/C:/PROGRA~2/QUICKT~1/QTSystem/QTJava.zip, file:/c:/PROGRA~1/Java/JDK16~1.0_2/lib/tools.jar, file:/C:/Program%20Files%20(x86)/QuickTime/QTSystem/QTJava.zip, file:/C:/Program%20Files%20(x86)/Java/jre6/lib/ext/QTJava.zip)
loading implementation class from <primary macro mirror>: scala.reflect.makro.internal.package
classloader is: Cl#1220876398 of type class scala.tools.nsc.util.ScalaClassLoader$URLClassLoader
classpath is: [file:/c:/PROGRA~1/Java/JDK16~1.0_2/jre/lib/resources.jar,file:/c:/PROGRA~1/Java/JDK16~1.0_2/jre/lib/rt.jar,file:/c:/PROGRA~1/Java/JDK16~1.0_2/jre/lib/jsse.jar,file:/c:/PROGRA~1/Java/JDK16~1.0_2/jre/lib/jce.jar,file:/c:/PROGRA~1/Java/JDK16~1.0_2/jre/lib/charsets.jar,file:/c:/PROGRA~1/Java/JDK16~1.0_2/jre/lib/ext/dnsns.jar,file:/c:/PROGRA~1/Java/JDK16~1.0_2/jre/lib/ext/localedata.jar,file:/c:/PROGRA~1/Java/JDK16~1.0_2/jre/lib/ext/sunjce_provider.jar,file:/C:/Projects/Kepler/lib/fjbg.jar,file:/C:/Projects/Kepler/build/locker/classes/compiler/,file:/C:/Projects/Kepler/build/locker/classes/library/,file:/C:/Projects/ScalaQuery/bin/scalaquery_2.9.1-0.10.0-SNAPSHOT.jar,file:/C:/Projects/Kepler/test/pending/run/macro-reify-typetag-hktypeparams-notags/./,file:/C:/PROGRA~2/QUICKT~1/QTSystem/QTJava.zip,file:/c:/PROGRA~1/Java/JDK16~1.0_2/lib/tools.jar,file:/C:/Program%20Files%20(x86)/QuickTime/QTSystem/QTJava.zip,file:/C:/Program%20Files%20(x86)/Java/jre6/lib/ext/QTJava.zip]
implClassSymbol is: scala.reflect.makro.internal.package
implClass is class scala.reflect.makro.internal.package$ from (file:/C:/Projects/Kepler/build/locker/classes/library/ <no signer certificates>)
implClassLoader is sun.misc.Launcher$AppClassLoader@4aad3ba4 with classpath [file:/C:/Projects/Kepler/lib/fjbg.jar,file:/C:/Projects/Kepler/build/locker/classes/compiler/,file:/C:/Projects/Kepler/build/locker/classes/library/]
implObjSymbol is: scala.reflect.makro.internal.package
implMethSymbol is: scala.reflect.makro.internal.materializeTypeTag_impl
jimplMethSymbol is: public scala.reflect.api.Exprs$Expr scala.reflect.makro.internal.package$.materializeTypeTag_impl(scala.reflect.makro.Context,scala.reflect.api.Exprs$Expr,scala.reflect.api.TypeTags$TypeTag)
successfully loaded macro impl as (scala.reflect.makro.internal.package$@1a83e35b, method materializeTypeTag_impl)
calculateUndetparams: Set()
typechecking macro expansion `package`.this.materializeTypeTag[C[T]](scala.reflect.`package`.mirror) at source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-5,offset=113
argss: List(List(MacroContext(materializeTypeTag@source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-5,offset=113 +0)), List(Expr[Nothing](scala.reflect.`package`.mirror)))
paramss: List(List(value c), List(value u), List(value evidence$4))
resolved tparam type T as C[T]
rawArgs: List(MacroContext(materializeTypeTag@source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-5,offset=113 +0), Expr[Nothing](scala.reflect.`package`.mirror), TypeTag[C[T]])
inferring implicit value of type scala.reflect.Manifest[C[T]], macros = true
materializing requested scala.reflect.package.mirror.type.ConcreteTypeTag[C[T]] using `package`.this.materializeConcreteTypeTag[C[T]](`package`.this.mirror)
Test.scala:5: `package`.this.materializeConcreteTypeTag[C[T]](`package`.this.mirror) is not a valid implicit value for scala.reflect.package.mirror.ConcreteTypeTag[C[T]] because:
macros are disabled
    println(implicitly[TypeTag[C[T]]])
                      ^
implicit search has failed. to find out the reason, turn on -Xlog-implicits
reifying = C[T]
prefix = scala.reflect.`package`.mirror
splicing C[T]
splicing has been cancelled: spliceTypesEnabled = false
Free type: type C (type)
tough type: [_] (PolyType)
Sym def: type _ (type)
Sym def: type C (type)
Locatable: method fooNoTypeTagHK (method) owned by object Test (module class) at Test
splicing T
launching implicit search for scala.reflect.`package`.mirror.TypeTag[T]
materializing requested reflect.mirror.type.TypeTag[T] using `package`.this.materializeTypeTag[T](scala.reflect.`package`.mirror)
calculateUndetparams: Set()
typechecking macro expansion `package`.this.materializeTypeTag[T](scala.reflect.`package`.mirror) at source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-5,offset=113
argss: List(List(MacroContext(materializeTypeTag@source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-5,offset=113 +1)), List(Expr[Nothing](scala.reflect.`package`.mirror)))
paramss: List(List(value c), List(value u), List(value evidence$4))
resolved tparam type T as T
rawArgs: List(MacroContext(materializeTypeTag@source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-5,offset=113 +1), Expr[Nothing](scala.reflect.`package`.mirror), TypeTag[T])
inferring implicit value of type scala.reflect.Manifest[T], macros = true
materializing requested scala.reflect.package.mirror.type.ConcreteTypeTag[T] using `package`.this.materializeConcreteTypeTag[T](`package`.this.mirror)
Test.scala:5: `package`.this.materializeConcreteTypeTag[T](`package`.this.mirror) is not a valid implicit value for scala.reflect.package.mirror.ConcreteTypeTag[T] because:
macros are disabled
    println(implicitly[TypeTag[C[T]]])
                      ^
implicit search has failed. to find out the reason, turn on -Xlog-implicits
reifying = T
prefix = scala.reflect.`package`.mirror
splicing T
splicing has been cancelled: spliceTypesEnabled = false
Free type: type T (type)
materializing requested scala.reflect.type.ErasureTag[T] using `package`.this.materializeErasureTag[T](`package`.this.mirror)
Test.scala:5: `package`.this.materializeErasureTag[T](`package`.this.mirror) is not a valid implicit value for scala.reflect.ErasureTag[T] because:
macros are disabled
    println(implicitly[TypeTag[C[T]]])
                      ^
materializing requested scala.reflect.type.ArrayTag[T] using `package`.this.materializeArrayTag[T](`package`.this.mirror)
Test.scala:5: `package`.this.materializeArrayTag[T](`package`.this.mirror) is not a valid implicit value for scala.reflect.ArrayTag[T] because:
macros are disabled
    println(implicitly[TypeTag[C[T]]])
                      ^
Filling in: type T (type)
reified = {
  val $mr: scala.reflect.`package`.mirror.type = scala.reflect.`package`.mirror;
  val free$T1 = $mr.newFreeType("T", $mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor), $mr.TypeTag[T](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:28");
  $mr.TypeTag[T]($mr.TypeRef($mr.NoPrefix, free$T1, scala.collection.immutable.List.apply()), Predef.this.classOf[Object])
}
typechecking {
  val $mr: scala.reflect.`package`.mirror.type = scala.reflect.`package`.mirror;
  val free$T1 = $mr.newFreeType("T", $mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor), $mr.TypeTag[T](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:28");
  $mr.TypeTag[T]($mr.TypeRef($mr.NoPrefix, free$T1, scala.collection.immutable.List.apply()), Predef.this.classOf[Object])
} with expected type ?, implicit views = true, macros = true
undetParam added: type A
undetParam inferred: type A as Nothing
{
  val $mr: reflect.mirror.type = scala.reflect.`package`.mirror;
  val free$T1: $mr.Symbol = $mr.newFreeType("T", $mr.TypeBounds.apply($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor), $mr.TypeTag.apply[T](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:28");
  $mr.TypeTag.apply[T]($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil), classOf[java.lang.Object])
}
original:
{
  val $mr: reflect.mirror.type = scala.reflect.`package`.mirror;
  val free$T1: $mr.Symbol = $mr.newFreeType("T", $mr.TypeBounds.apply($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor), $mr.TypeTag.apply[T](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:28");
  $mr.TypeTag.apply[T]($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil), classOf[java.lang.Object])
}
Block(List(ValDef(Modifiers(), newTermName("$mr"), TypeTree().setType(reflect.mirror.type), Select(Select(Select(Ident(newTermName("scala")), newTermName("reflect")), newTermName("package")), newTermName("mirror"))), ValDef(Modifiers(), newTermName("free$T1"), TypeTree().setType($mr.Symbol), Apply(Select(Ident(newTermName("$mr")), newTermName("newFreeType")), List(Literal(Constant("T")), Apply(Select(Select(Ident(newTermName("$mr")), newTermName("TypeBounds")), newTermName("apply")), List(Select(Apply(Select(Ident(newTermName("$mr")), newTermName("staticClass")), List(Literal(Constant("scala.Nothing")))), newTermName("asTypeConstructor")), Select(Apply(Select(Ident(newTermName("$mr")), newTermName("staticClass")), List(Literal(Constant("scala.Any")))), newTermName("asTypeConstructor")))), Apply(TypeApply(Select(Select(Ident(newTermName("$mr")), newTermName("TypeTag")), newTermName("apply")), List(TypeTree().setType(T))), List(Literal(Constant(null)), Literal(Constant(null)))), Literal(Constant(8208)), Literal(Constant("defined by fooNoTypeTagHK in Test.scala:4:28")))))), Apply(TypeApply(Select(Select(Ident(newTermName("$mr")), newTermName("TypeTag")), newTermName("apply")), List(TypeTree().setType(T))), List(Apply(Select(Select(Ident(newTermName("$mr")), newTermName("TypeRef")), newTermName("apply")), List(Select(Ident(newTermName("$mr")), newTermName("NoPrefix")), Ident(newTermName("free$T1")), Select(This(newTypeName("immutable")), newTermName("Nil")))), Literal(Constant(Object)))))
typechecking1 against reflect.mirror.TypeTag[T]: {
  val $mr: reflect.mirror.type = scala.reflect.`package`.mirror;
  val free$T1: $mr.Symbol = $mr.newFreeType("T", $mr.TypeBounds.apply($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor), $mr.TypeTag.apply[T](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:28");
  $mr.TypeTag.apply[T]($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil), classOf[java.lang.Object])
}
typechecked1:
{
  val $mr: reflect.mirror.type = scala.reflect.`package`.mirror;
  val free$T1: $mr.Symbol = $mr.newFreeType("T", $mr.TypeBounds.apply($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor), $mr.TypeTag.apply[T](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:28");
  $mr.TypeTag.apply[T]($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil), classOf[java.lang.Object])
}
Block(List(ValDef(Modifiers(), newTermName("$mr"), TypeTree().setType(reflect.mirror.type), Select(Select(Select(Ident(newTermName("scala")), newTermName("reflect")), newTermName("package")), newTermName("mirror"))), ValDef(Modifiers(), newTermName("free$T1"), TypeTree().setType($mr.Symbol), Apply(Select(Ident(newTermName("$mr")), newTermName("newFreeType")), List(Literal(Constant("T")), Apply(Select(Select(Ident(newTermName("$mr")), newTermName("TypeBounds")), newTermName("apply")), List(Select(Apply(Select(Ident(newTermName("$mr")), newTermName("staticClass")), List(Literal(Constant("scala.Nothing")))), newTermName("asTypeConstructor")), Select(Apply(Select(Ident(newTermName("$mr")), newTermName("staticClass")), List(Literal(Constant("scala.Any")))), newTermName("asTypeConstructor")))), Apply(TypeApply(Select(Select(Ident(newTermName("$mr")), newTermName("TypeTag")), newTermName("apply")), List(TypeTree().setType(T))), List(Literal(Constant(null)), Literal(Constant(null)))), Literal(Constant(8208)), Literal(Constant("defined by fooNoTypeTagHK in Test.scala:4:28")))))), Apply(TypeApply(Select(Select(Ident(newTermName("$mr")), newTermName("TypeTag")), newTermName("apply")), List(TypeTree().setType(T))), List(Apply(Select(Select(Ident(newTermName("$mr")), newTermName("TypeRef")), newTermName("apply")), List(Select(Ident(newTermName("$mr")), newTermName("NoPrefix")), Ident(newTermName("free$T1")), Select(This(newTypeName("immutable")), newTermName("Nil")))), Literal(Constant(Object)))))
typechecking2 against ?: {
  val $mr: reflect.mirror.type = scala.reflect.`package`.mirror;
  val free$T1: $mr.Symbol = $mr.newFreeType("T", $mr.TypeBounds.apply($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor), $mr.TypeTag.apply[T](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:28");
  $mr.TypeTag.apply[T]($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil), classOf[java.lang.Object])
}
typechecked2:
{
  val $mr: reflect.mirror.type = scala.reflect.`package`.mirror;
  val free$T1: $mr.Symbol = $mr.newFreeType("T", $mr.TypeBounds.apply($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor), $mr.TypeTag.apply[T](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:28");
  $mr.TypeTag.apply[T]($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil), classOf[java.lang.Object])
}
Block(List(ValDef(Modifiers(), newTermName("$mr"), TypeTree().setType(reflect.mirror.type), Select(Select(Select(Ident(newTermName("scala")), newTermName("reflect")), newTermName("package")), newTermName("mirror"))), ValDef(Modifiers(), newTermName("free$T1"), TypeTree().setType($mr.Symbol), Apply(Select(Ident(newTermName("$mr")), newTermName("newFreeType")), List(Literal(Constant("T")), Apply(Select(Select(Ident(newTermName("$mr")), newTermName("TypeBounds")), newTermName("apply")), List(Select(Apply(Select(Ident(newTermName("$mr")), newTermName("staticClass")), List(Literal(Constant("scala.Nothing")))), newTermName("asTypeConstructor")), Select(Apply(Select(Ident(newTermName("$mr")), newTermName("staticClass")), List(Literal(Constant("scala.Any")))), newTermName("asTypeConstructor")))), Apply(TypeApply(Select(Select(Ident(newTermName("$mr")), newTermName("TypeTag")), newTermName("apply")), List(TypeTree().setType(T))), List(Literal(Constant(null)), Literal(Constant(null)))), Literal(Constant(8208)), Literal(Constant("defined by fooNoTypeTagHK in Test.scala:4:28")))))), Apply(TypeApply(Select(Select(Ident(newTermName("$mr")), newTermName("TypeTag")), newTermName("apply")), List(TypeTree().setType(T))), List(Apply(Select(Select(Ident(newTermName("$mr")), newTermName("TypeRef")), newTermName("apply")), List(Select(Ident(newTermName("$mr")), newTermName("NoPrefix")), Ident(newTermName("free$T1")), Select(This(newTypeName("immutable")), newTermName("Nil")))), Literal(Constant(Object)))))
implicit search has produced a result: {
  val $mr: reflect.mirror.type = scala.reflect.`package`.mirror;
  val free$T1: $mr.Symbol = $mr.newFreeType("T", $mr.TypeBounds.apply($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor), $mr.TypeTag.apply[T](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:28");
  $mr.TypeTag.apply[T]($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil), classOf[java.lang.Object])
}
Filling in: type C (type)
Filling in: type _ (type)
Filling in: type C (type)
inlined the splicee: $mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil)
materializing requested scala.reflect.type.ErasureTag[C[T]] using `package`.this.materializeErasureTag[C[T]](`package`.this.mirror)
Test.scala:5: `package`.this.materializeErasureTag[C[T]](`package`.this.mirror) is not a valid implicit value for scala.reflect.ErasureTag[C[T]] because:
macros are disabled
    println(implicitly[TypeTag[C[T]]])
                      ^
materializing requested scala.reflect.type.ArrayTag[C[T]] using `package`.this.materializeArrayTag[C[T]](`package`.this.mirror)
Test.scala:5: `package`.this.materializeArrayTag[C[T]](`package`.this.mirror) is not a valid implicit value for scala.reflect.ArrayTag[C[T]] because:
macros are disabled
    println(implicitly[TypeTag[C[T]]])
                      ^
Filling in: type C (type)
tough type: [_] (PolyType)
Filling in: type _ (type)
Filling in: type T (type)
reified = {
  val $mr: scala.reflect.`package`.mirror.type = scala.reflect.`package`.mirror;
  val symdef$C1 = $mr.selectTerm($mr.staticModule("Test").moduleClass, "fooNoTypeTagHK").newNestedSymbol($mr.newTypeName("C"), $mr.NoPosition, 8208L, false);
  val symdef$_1 = symdef$C1.newNestedSymbol($mr.newTypeName("_"), $mr.NoPosition, 8208L, false);
  val free$T1: $mr.Symbol = $mr.newFreeType("T", $mr.TypeBounds.apply($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor), $mr.TypeTag.apply[T](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:28");
  symdef$C1.setTypeSignature($mr.PolyType(scala.collection.immutable.List.apply(symdef$_1), $mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor)));
  symdef$_1.setTypeSignature($mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor));
  $mr.TypeTag[C[T]]($mr.TypeRef($mr.NoPrefix, free$C1, scala.collection.immutable.List.apply($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil))), Predef.this.classOf[Object])
}
typechecking {
  val $mr: scala.reflect.`package`.mirror.type = scala.reflect.`package`.mirror;
  val symdef$C1 = $mr.selectTerm($mr.staticModule("Test").moduleClass, "fooNoTypeTagHK").newNestedSymbol($mr.newTypeName("C"), $mr.NoPosition, 8208L, false);
  val symdef$_1 = symdef$C1.newNestedSymbol($mr.newTypeName("_"), $mr.NoPosition, 8208L, false);
  val free$T1: $mr.Symbol = $mr.newFreeType("T", $mr.TypeBounds.apply($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor), $mr.TypeTag.apply[T](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:28");
  symdef$C1.setTypeSignature($mr.PolyType(scala.collection.immutable.List.apply(symdef$_1), $mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor)));
  symdef$_1.setTypeSignature($mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor));
  $mr.TypeTag[C[T]]($mr.TypeRef($mr.NoPrefix, free$C1, scala.collection.immutable.List.apply($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil))), Predef.this.classOf[Object])
} with expected type ?, implicit views = true, macros = true
undetParam added: type A
undetParam inferred: type A as $mr.Symbol
undetParam added: type A
undetParam inferred: type A as $mr.Type
undetParam added: type A
undetParam inferred: type A as $mr.Type
not found: value free$C1
Test.scala:5: cannot materialize TypeTag[C[T]] because:
scala.reflect.internal.Types$TypeError: not found: value free$C1
    println(implicitly[TypeTag[C[T]]])
                      ^
macro expansion has failed: No TypeTag available for C[T] at source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-5,offset=113
Test.scala:5: `package`.this.materializeTypeTag[C[T]](scala.reflect.`package`.mirror) is not a valid implicit value for reflect.mirror.TypeTag[C[T]] because:
failed to typecheck the materialized typetag: 
No TypeTag available for C[T]
    println(implicitly[TypeTag[C[T]]])
                      ^
materializing requested reflect.mirror.type.TypeTag[C[T]] using `package`.this.materializeTypeTag[C[T]](scala.reflect.`package`.mirror)
calculateUndetparams: Set()
typechecking macro expansion `package`.this.materializeTypeTag[C[T]](scala.reflect.`package`.mirror) at source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-5,offset=113
argss: List(List(MacroContext(materializeTypeTag@source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-5,offset=113 +0)), List(Expr[Nothing](scala.reflect.`package`.mirror)))
paramss: List(List(value c), List(value u), List(value evidence$4))
resolved tparam type T as C[T]
rawArgs: List(MacroContext(materializeTypeTag@source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-5,offset=113 +0), Expr[Nothing](scala.reflect.`package`.mirror), TypeTag[C[T]])
inferring implicit value of type scala.reflect.Manifest[C[T]], macros = true
materializing requested scala.reflect.package.mirror.type.ConcreteTypeTag[C[T]] using `package`.this.materializeConcreteTypeTag[C[T]](`package`.this.mirror)
Test.scala:5: `package`.this.materializeConcreteTypeTag[C[T]](`package`.this.mirror) is not a valid implicit value for scala.reflect.package.mirror.ConcreteTypeTag[C[T]] because:
macros are disabled
    println(implicitly[TypeTag[C[T]]])
                      ^
implicit search has failed. to find out the reason, turn on -Xlog-implicits
reifying = C[T]
prefix = scala.reflect.`package`.mirror
splicing C[T]
splicing has been cancelled: spliceTypesEnabled = false
Free type: type C (type)
tough type: [_] (PolyType)
Sym def: type _ (type)
Sym def: type C (type)
Locatable: method fooNoTypeTagHK (method) owned by object Test (module class) at Test
splicing T
cache hit: $mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil)
materializing requested scala.reflect.type.ErasureTag[C[T]] using `package`.this.materializeErasureTag[C[T]](`package`.this.mirror)
Test.scala:5: `package`.this.materializeErasureTag[C[T]](`package`.this.mirror) is not a valid implicit value for scala.reflect.ErasureTag[C[T]] because:
macros are disabled
    println(implicitly[TypeTag[C[T]]])
                      ^
materializing requested scala.reflect.type.ArrayTag[C[T]] using `package`.this.materializeArrayTag[C[T]](`package`.this.mirror)
Test.scala:5: `package`.this.materializeArrayTag[C[T]](`package`.this.mirror) is not a valid implicit value for scala.reflect.ArrayTag[C[T]] because:
macros are disabled
    println(implicitly[TypeTag[C[T]]])
                      ^
Filling in: type C (type)
Filling in: type _ (type)
Filling in: type C (type)
reified = {
  val $mr: scala.reflect.`package`.mirror.type = scala.reflect.`package`.mirror;
  val symdef$C2 = $mr.selectTerm($mr.staticModule("Test").moduleClass, "fooNoTypeTagHK").newNestedSymbol($mr.newTypeName("C"), $mr.NoPosition, 8208L, false);
  val symdef$_2 = symdef$C2.newNestedSymbol($mr.newTypeName("_"), $mr.NoPosition, 8208L, false);
  val free$C2 = $mr.newFreeType("C", $mr.PolyType(scala.collection.immutable.List.apply(symdef$_2), $mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor)), $mr.TypeTag[C](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:22");
  symdef$_2.setTypeSignature($mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor));
  $mr.TypeTag[C[T]]($mr.TypeRef($mr.NoPrefix, free$C2, scala.collection.immutable.List.apply($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil))), Predef.this.classOf[Object])
}
typechecking {
  val $mr: scala.reflect.`package`.mirror.type = scala.reflect.`package`.mirror;
  val symdef$C2 = $mr.selectTerm($mr.staticModule("Test").moduleClass, "fooNoTypeTagHK").newNestedSymbol($mr.newTypeName("C"), $mr.NoPosition, 8208L, false);
  val symdef$_2 = symdef$C2.newNestedSymbol($mr.newTypeName("_"), $mr.NoPosition, 8208L, false);
  val free$C2 = $mr.newFreeType("C", $mr.PolyType(scala.collection.immutable.List.apply(symdef$_2), $mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor)), $mr.TypeTag[C](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:22");
  symdef$_2.setTypeSignature($mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor));
  $mr.TypeTag[C[T]]($mr.TypeRef($mr.NoPrefix, free$C2, scala.collection.immutable.List.apply($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil))), Predef.this.classOf[Object])
} with expected type ?, implicit views = true, macros = true
undetParam added: type A
undetParam inferred: type A as $mr.Symbol
undetParam added: type A
undetParam inferred: type A as $mr.Symbol
undetParam added: type A
type C takes type parameters
Test.scala:5: cannot materialize TypeTag[C[T]] because:
scala.reflect.internal.Types$TypeError: type C takes type parameters
    println(implicitly[TypeTag[C[T]]])
                      ^
macro expansion has failed: No TypeTag available for C[T] at source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-5,offset=113
Test.scala:5: `package`.this.materializeTypeTag[C[T]](scala.reflect.`package`.mirror) is not a valid implicit value for reflect.mirror.TypeTag[C[T]] because:
failed to typecheck the materialized typetag: 
No TypeTag available for C[T]
    println(implicitly[TypeTag[C[T]]])
                      ^
materializing requested reflect.mirror.type.TypeTag[C[T]] using `package`.this.materializeTypeTag[C[T]](scala.reflect.`package`.mirror)
calculateUndetparams: Set()
typechecking macro expansion `package`.this.materializeTypeTag[C[T]](scala.reflect.`package`.mirror) at source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-5,offset=113
argss: List(List(MacroContext(materializeTypeTag@source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-5,offset=113 +0)), List(Expr[Nothing](scala.reflect.`package`.mirror)))
paramss: List(List(value c), List(value u), List(value evidence$4))
resolved tparam type T as C[T]
rawArgs: List(MacroContext(materializeTypeTag@source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-5,offset=113 +0), Expr[Nothing](scala.reflect.`package`.mirror), TypeTag[C[T]])
inferring implicit value of type scala.reflect.Manifest[C[T]], macros = true
materializing requested scala.reflect.package.mirror.type.ConcreteTypeTag[C[T]] using `package`.this.materializeConcreteTypeTag[C[T]](`package`.this.mirror)
Test.scala:5: `package`.this.materializeConcreteTypeTag[C[T]](`package`.this.mirror) is not a valid implicit value for scala.reflect.package.mirror.ConcreteTypeTag[C[T]] because:
macros are disabled
    println(implicitly[TypeTag[C[T]]])
                      ^
implicit search has failed. to find out the reason, turn on -Xlog-implicits
reifying = C[T]
prefix = scala.reflect.`package`.mirror
splicing C[T]
splicing has been cancelled: spliceTypesEnabled = false
Free type: type C (type)
tough type: [_] (PolyType)
Sym def: type _ (type)
Sym def: type C (type)
Locatable: method fooNoTypeTagHK (method) owned by object Test (module class) at Test
splicing T
cache hit: $mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil)
materializing requested scala.reflect.type.ErasureTag[C[T]] using `package`.this.materializeErasureTag[C[T]](`package`.this.mirror)
Test.scala:5: `package`.this.materializeErasureTag[C[T]](`package`.this.mirror) is not a valid implicit value for scala.reflect.ErasureTag[C[T]] because:
macros are disabled
    println(implicitly[TypeTag[C[T]]])
                      ^
materializing requested scala.reflect.type.ArrayTag[C[T]] using `package`.this.materializeArrayTag[C[T]](`package`.this.mirror)
Test.scala:5: `package`.this.materializeArrayTag[C[T]](`package`.this.mirror) is not a valid implicit value for scala.reflect.ArrayTag[C[T]] because:
macros are disabled
    println(implicitly[TypeTag[C[T]]])
                      ^
Filling in: type C (type)
Filling in: type _ (type)
Filling in: type C (type)
reified = {
  val $mr: scala.reflect.`package`.mirror.type = scala.reflect.`package`.mirror;
  val symdef$C3 = $mr.selectTerm($mr.staticModule("Test").moduleClass, "fooNoTypeTagHK").newNestedSymbol($mr.newTypeName("C"), $mr.NoPosition, 8208L, false);
  val symdef$_3 = symdef$C3.newNestedSymbol($mr.newTypeName("_"), $mr.NoPosition, 8208L, false);
  val free$C3 = $mr.newFreeType("C", $mr.PolyType(scala.collection.immutable.List.apply(symdef$_3), $mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor)), $mr.TypeTag[C](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:22");
  symdef$_3.setTypeSignature($mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor));
  $mr.TypeTag[C[T]]($mr.TypeRef($mr.NoPrefix, free$C3, scala.collection.immutable.List.apply($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil))), Predef.this.classOf[Object])
}
typechecking {
  val $mr: scala.reflect.`package`.mirror.type = scala.reflect.`package`.mirror;
  val symdef$C3 = $mr.selectTerm($mr.staticModule("Test").moduleClass, "fooNoTypeTagHK").newNestedSymbol($mr.newTypeName("C"), $mr.NoPosition, 8208L, false);
  val symdef$_3 = symdef$C3.newNestedSymbol($mr.newTypeName("_"), $mr.NoPosition, 8208L, false);
  val free$C3 = $mr.newFreeType("C", $mr.PolyType(scala.collection.immutable.List.apply(symdef$_3), $mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor)), $mr.TypeTag[C](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:22");
  symdef$_3.setTypeSignature($mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor));
  $mr.TypeTag[C[T]]($mr.TypeRef($mr.NoPrefix, free$C3, scala.collection.immutable.List.apply($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil))), Predef.this.classOf[Object])
} with expected type ?, implicit views = true, macros = true
undetParam added: type A
undetParam inferred: type A as $mr.Symbol
undetParam added: type A
undetParam inferred: type A as $mr.Symbol
undetParam added: type A
type C takes type parameters
Test.scala:5: cannot materialize TypeTag[C[T]] because:
scala.reflect.internal.Types$TypeError: type C takes type parameters
    println(implicitly[TypeTag[C[T]]])
                      ^
macro expansion has failed: No TypeTag available for C[T] at source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-5,offset=113
Test.scala:5: `package`.this.materializeTypeTag[C[T]](scala.reflect.`package`.mirror) is not a valid implicit value for reflect.mirror.TypeTag[C[T]] because:
failed to typecheck the materialized typetag: 
No TypeTag available for C[T]
    println(implicitly[TypeTag[C[T]]])
                      ^
Test.scala:5: error: No TypeTag available for C[T]
    println(implicitly[TypeTag[C[T]]])
                      ^
materializing requested reflect.mirror.type.TypeTag[List[C[T]]] using `package`.this.materializeTypeTag[List[C[T]]](scala.reflect.`package`.mirror)
calculateUndetparams: Set()
typechecking macro expansion `package`.this.materializeTypeTag[List[C[T]]](scala.reflect.`package`.mirror) at source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-6,offset=152
argss: List(List(MacroContext(materializeTypeTag@source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-6,offset=152 +0)), List(Expr[Nothing](scala.reflect.`package`.mirror)))
paramss: List(List(value c), List(value u), List(value evidence$4))
resolved tparam type T as List[C[T]]
rawArgs: List(MacroContext(materializeTypeTag@source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-6,offset=152 +0), Expr[Nothing](scala.reflect.`package`.mirror), TypeTag[List[C[T]]])
inferring implicit value of type scala.reflect.Manifest[List[C[T]]], macros = true
materializing requested scala.reflect.package.mirror.type.ConcreteTypeTag[List[C[T]]] using `package`.this.materializeConcreteTypeTag[List[C[T]]](`package`.this.mirror)
Test.scala:6: `package`.this.materializeConcreteTypeTag[List[C[T]]](`package`.this.mirror) is not a valid implicit value for scala.reflect.package.mirror.ConcreteTypeTag[List[C[T]]] because:
macros are disabled
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
materializing requested scala.reflect.package.mirror.type.ConcreteTypeTag[C[T]] using `package`.this.materializeConcreteTypeTag[C[T]](`package`.this.mirror)
`package`.this.materializeConcreteTypeTag[C[T]](`package`.this.mirror) is not a valid implicit value for scala.reflect.package.mirror.ConcreteTypeTag[C[T]] because:
macros are disabled
implicit search has failed. to find out the reason, turn on -Xlog-implicits
reifying = List[C[T]]
prefix = scala.reflect.`package`.mirror
splicing C[T]
launching implicit search for scala.reflect.`package`.mirror.TypeTag[C[T]]
materializing requested reflect.mirror.type.TypeTag[C[T]] using `package`.this.materializeTypeTag[C[T]](scala.reflect.`package`.mirror)
calculateUndetparams: Set()
typechecking macro expansion `package`.this.materializeTypeTag[C[T]](scala.reflect.`package`.mirror) at source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-6,offset=152
argss: List(List(MacroContext(materializeTypeTag@source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-6,offset=152 +1)), List(Expr[Nothing](scala.reflect.`package`.mirror)))
paramss: List(List(value c), List(value u), List(value evidence$4))
resolved tparam type T as C[T]
rawArgs: List(MacroContext(materializeTypeTag@source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-6,offset=152 +1), Expr[Nothing](scala.reflect.`package`.mirror), TypeTag[C[T]])
inferring implicit value of type scala.reflect.Manifest[C[T]], macros = true
materializing requested scala.reflect.package.mirror.type.ConcreteTypeTag[C[T]] using `package`.this.materializeConcreteTypeTag[C[T]](`package`.this.mirror)
Test.scala:6: `package`.this.materializeConcreteTypeTag[C[T]](`package`.this.mirror) is not a valid implicit value for scala.reflect.package.mirror.ConcreteTypeTag[C[T]] because:
macros are disabled
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
implicit search has failed. to find out the reason, turn on -Xlog-implicits
reifying = C[T]
prefix = scala.reflect.`package`.mirror
splicing C[T]
splicing has been cancelled: spliceTypesEnabled = false
Free type: type C (type)
tough type: [_] (PolyType)
Sym def: type _ (type)
Sym def: type C (type)
Locatable: method fooNoTypeTagHK (method) owned by object Test (module class) at Test
splicing T
cache hit: $mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil)
materializing requested scala.reflect.type.ErasureTag[C[T]] using `package`.this.materializeErasureTag[C[T]](`package`.this.mirror)
Test.scala:6: `package`.this.materializeErasureTag[C[T]](`package`.this.mirror) is not a valid implicit value for scala.reflect.ErasureTag[C[T]] because:
macros are disabled
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
materializing requested scala.reflect.type.ArrayTag[C[T]] using `package`.this.materializeArrayTag[C[T]](`package`.this.mirror)
Test.scala:6: `package`.this.materializeArrayTag[C[T]](`package`.this.mirror) is not a valid implicit value for scala.reflect.ArrayTag[C[T]] because:
macros are disabled
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
Filling in: type C (type)
Filling in: type _ (type)
Filling in: type C (type)
reified = {
  val $mr: scala.reflect.`package`.mirror.type = scala.reflect.`package`.mirror;
  val symdef$C4 = $mr.selectTerm($mr.staticModule("Test").moduleClass, "fooNoTypeTagHK").newNestedSymbol($mr.newTypeName("C"), $mr.NoPosition, 8208L, false);
  val symdef$_4 = symdef$C4.newNestedSymbol($mr.newTypeName("_"), $mr.NoPosition, 8208L, false);
  val free$C4 = $mr.newFreeType("C", $mr.PolyType(scala.collection.immutable.List.apply(symdef$_4), $mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor)), $mr.TypeTag[C](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:22");
  symdef$_4.setTypeSignature($mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor));
  $mr.TypeTag[C[T]]($mr.TypeRef($mr.NoPrefix, free$C4, scala.collection.immutable.List.apply($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil))), Predef.this.classOf[Object])
}
typechecking {
  val $mr: scala.reflect.`package`.mirror.type = scala.reflect.`package`.mirror;
  val symdef$C4 = $mr.selectTerm($mr.staticModule("Test").moduleClass, "fooNoTypeTagHK").newNestedSymbol($mr.newTypeName("C"), $mr.NoPosition, 8208L, false);
  val symdef$_4 = symdef$C4.newNestedSymbol($mr.newTypeName("_"), $mr.NoPosition, 8208L, false);
  val free$C4 = $mr.newFreeType("C", $mr.PolyType(scala.collection.immutable.List.apply(symdef$_4), $mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor)), $mr.TypeTag[C](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:22");
  symdef$_4.setTypeSignature($mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor));
  $mr.TypeTag[C[T]]($mr.TypeRef($mr.NoPrefix, free$C4, scala.collection.immutable.List.apply($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil))), Predef.this.classOf[Object])
} with expected type ?, implicit views = true, macros = true
undetParam added: type A
undetParam inferred: type A as $mr.Symbol
undetParam added: type A
undetParam inferred: type A as $mr.Symbol
undetParam added: type A
type C takes type parameters
Test.scala:6: cannot materialize TypeTag[C[T]] because:
scala.reflect.internal.Types$TypeError: type C takes type parameters
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
macro expansion has failed: No TypeTag available for C[T] at source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-6,offset=152
Test.scala:6: `package`.this.materializeTypeTag[C[T]](scala.reflect.`package`.mirror) is not a valid implicit value for reflect.mirror.TypeTag[C[T]] because:
failed to typecheck the materialized typetag: 
No TypeTag available for C[T]
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
implicit search was fruitless
Free type: type C (type)
tough type: [_] (PolyType)
Sym def: type _ (type)
Sym def: type C (type)
Locatable: method fooNoTypeTagHK (method) owned by object Test (module class) at Test
splicing T
cache hit: $mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil)
materializing requested scala.reflect.type.ErasureTag[List[C[T]]] using `package`.this.materializeErasureTag[List[C[T]]](`package`.this.mirror)
Test.scala:6: `package`.this.materializeErasureTag[List[C[T]]](`package`.this.mirror) is not a valid implicit value for scala.reflect.ErasureTag[List[C[T]]] because:
macros are disabled
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
materializing requested scala.reflect.type.ArrayTag[List[C[T]]] using `package`.this.materializeArrayTag[List[C[T]]](`package`.this.mirror)
Test.scala:6: `package`.this.materializeArrayTag[List[C[T]]](`package`.this.mirror) is not a valid implicit value for scala.reflect.ArrayTag[List[C[T]]] because:
macros are disabled
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
Filling in: type C (type)
Filling in: type _ (type)
Filling in: type C (type)
reified = {
  val $mr: scala.reflect.`package`.mirror.type = scala.reflect.`package`.mirror;
  val symdef$C5 = $mr.selectTerm($mr.staticModule("Test").moduleClass, "fooNoTypeTagHK").newNestedSymbol($mr.newTypeName("C"), $mr.NoPosition, 8208L, false);
  val symdef$_5 = symdef$C5.newNestedSymbol($mr.newTypeName("_"), $mr.NoPosition, 8208L, false);
  val free$C5 = $mr.newFreeType("C", $mr.PolyType(scala.collection.immutable.List.apply(symdef$_5), $mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor)), $mr.TypeTag[C](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:22");
  symdef$_5.setTypeSignature($mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor));
  $mr.TypeTag[List[C[T]]]($mr.TypeRef($mr.thisModuleType("scala.collection.immutable"), $mr.staticClass("scala.collection.immutable.List"), scala.collection.immutable.List.apply($mr.TypeRef($mr.NoPrefix, free$C5, scala.collection.immutable.List.apply($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil))))), Predef.this.classOf[List[Any]])
}
typechecking {
  val $mr: scala.reflect.`package`.mirror.type = scala.reflect.`package`.mirror;
  val symdef$C5 = $mr.selectTerm($mr.staticModule("Test").moduleClass, "fooNoTypeTagHK").newNestedSymbol($mr.newTypeName("C"), $mr.NoPosition, 8208L, false);
  val symdef$_5 = symdef$C5.newNestedSymbol($mr.newTypeName("_"), $mr.NoPosition, 8208L, false);
  val free$C5 = $mr.newFreeType("C", $mr.PolyType(scala.collection.immutable.List.apply(symdef$_5), $mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor)), $mr.TypeTag[C](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:22");
  symdef$_5.setTypeSignature($mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor));
  $mr.TypeTag[List[C[T]]]($mr.TypeRef($mr.thisModuleType("scala.collection.immutable"), $mr.staticClass("scala.collection.immutable.List"), scala.collection.immutable.List.apply($mr.TypeRef($mr.NoPrefix, free$C5, scala.collection.immutable.List.apply($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil))))), Predef.this.classOf[List[Any]])
} with expected type ?, implicit views = true, macros = true
undetParam added: type A
undetParam inferred: type A as $mr.Symbol
undetParam added: type A
undetParam inferred: type A as $mr.Symbol
undetParam added: type A
undetParam added: type A
type C takes type parameters
Test.scala:6: cannot materialize TypeTag[List[C[T]]] because:
scala.reflect.internal.Types$TypeError: type C takes type parameters
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
macro expansion has failed: No TypeTag available for List[C[T]] at source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-6,offset=152
Test.scala:6: `package`.this.materializeTypeTag[List[C[T]]](scala.reflect.`package`.mirror) is not a valid implicit value for reflect.mirror.TypeTag[List[C[T]]] because:
failed to typecheck the materialized typetag: 
No TypeTag available for List[C[T]]
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
materializing requested reflect.mirror.type.TypeTag[List[C[T]]] using `package`.this.materializeTypeTag[List[C[T]]](scala.reflect.`package`.mirror)
calculateUndetparams: Set()
typechecking macro expansion `package`.this.materializeTypeTag[List[C[T]]](scala.reflect.`package`.mirror) at source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-6,offset=152
argss: List(List(MacroContext(materializeTypeTag@source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-6,offset=152 +0)), List(Expr[Nothing](scala.reflect.`package`.mirror)))
paramss: List(List(value c), List(value u), List(value evidence$4))
resolved tparam type T as List[C[T]]
rawArgs: List(MacroContext(materializeTypeTag@source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-6,offset=152 +0), Expr[Nothing](scala.reflect.`package`.mirror), TypeTag[List[C[T]]])
inferring implicit value of type scala.reflect.Manifest[List[C[T]]], macros = true
materializing requested scala.reflect.package.mirror.type.ConcreteTypeTag[List[C[T]]] using `package`.this.materializeConcreteTypeTag[List[C[T]]](`package`.this.mirror)
Test.scala:6: `package`.this.materializeConcreteTypeTag[List[C[T]]](`package`.this.mirror) is not a valid implicit value for scala.reflect.package.mirror.ConcreteTypeTag[List[C[T]]] because:
macros are disabled
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
materializing requested scala.reflect.package.mirror.type.ConcreteTypeTag[C[T]] using `package`.this.materializeConcreteTypeTag[C[T]](`package`.this.mirror)
`package`.this.materializeConcreteTypeTag[C[T]](`package`.this.mirror) is not a valid implicit value for scala.reflect.package.mirror.ConcreteTypeTag[C[T]] because:
macros are disabled
implicit search has failed. to find out the reason, turn on -Xlog-implicits
reifying = List[C[T]]
prefix = scala.reflect.`package`.mirror
splicing C[T]
cache hit: <empty>
Free type: type C (type)
tough type: [_] (PolyType)
Sym def: type _ (type)
Sym def: type C (type)
Locatable: method fooNoTypeTagHK (method) owned by object Test (module class) at Test
splicing T
cache hit: $mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil)
materializing requested scala.reflect.type.ErasureTag[List[C[T]]] using `package`.this.materializeErasureTag[List[C[T]]](`package`.this.mirror)
Test.scala:6: `package`.this.materializeErasureTag[List[C[T]]](`package`.this.mirror) is not a valid implicit value for scala.reflect.ErasureTag[List[C[T]]] because:
macros are disabled
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
materializing requested scala.reflect.type.ArrayTag[List[C[T]]] using `package`.this.materializeArrayTag[List[C[T]]](`package`.this.mirror)
Test.scala:6: `package`.this.materializeArrayTag[List[C[T]]](`package`.this.mirror) is not a valid implicit value for scala.reflect.ArrayTag[List[C[T]]] because:
macros are disabled
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
Filling in: type C (type)
Filling in: type _ (type)
Filling in: type C (type)
reified = {
  val $mr: scala.reflect.`package`.mirror.type = scala.reflect.`package`.mirror;
  val symdef$C6 = $mr.selectTerm($mr.staticModule("Test").moduleClass, "fooNoTypeTagHK").newNestedSymbol($mr.newTypeName("C"), $mr.NoPosition, 8208L, false);
  val symdef$_6 = symdef$C6.newNestedSymbol($mr.newTypeName("_"), $mr.NoPosition, 8208L, false);
  val free$C6 = $mr.newFreeType("C", $mr.PolyType(scala.collection.immutable.List.apply(symdef$_6), $mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor)), $mr.TypeTag[C](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:22");
  symdef$_6.setTypeSignature($mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor));
  $mr.TypeTag[List[C[T]]]($mr.TypeRef($mr.thisModuleType("scala.collection.immutable"), $mr.staticClass("scala.collection.immutable.List"), scala.collection.immutable.List.apply($mr.TypeRef($mr.NoPrefix, free$C6, scala.collection.immutable.List.apply($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil))))), Predef.this.classOf[List[Any]])
}
typechecking {
  val $mr: scala.reflect.`package`.mirror.type = scala.reflect.`package`.mirror;
  val symdef$C6 = $mr.selectTerm($mr.staticModule("Test").moduleClass, "fooNoTypeTagHK").newNestedSymbol($mr.newTypeName("C"), $mr.NoPosition, 8208L, false);
  val symdef$_6 = symdef$C6.newNestedSymbol($mr.newTypeName("_"), $mr.NoPosition, 8208L, false);
  val free$C6 = $mr.newFreeType("C", $mr.PolyType(scala.collection.immutable.List.apply(symdef$_6), $mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor)), $mr.TypeTag[C](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:22");
  symdef$_6.setTypeSignature($mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor));
  $mr.TypeTag[List[C[T]]]($mr.TypeRef($mr.thisModuleType("scala.collection.immutable"), $mr.staticClass("scala.collection.immutable.List"), scala.collection.immutable.List.apply($mr.TypeRef($mr.NoPrefix, free$C6, scala.collection.immutable.List.apply($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil))))), Predef.this.classOf[List[Any]])
} with expected type ?, implicit views = true, macros = true
undetParam added: type A
undetParam inferred: type A as $mr.Symbol
undetParam added: type A
undetParam inferred: type A as $mr.Symbol
undetParam added: type A
undetParam added: type A
type C takes type parameters
Test.scala:6: cannot materialize TypeTag[List[C[T]]] because:
scala.reflect.internal.Types$TypeError: type C takes type parameters
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
macro expansion has failed: No TypeTag available for List[C[T]] at source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-6,offset=152
Test.scala:6: `package`.this.materializeTypeTag[List[C[T]]](scala.reflect.`package`.mirror) is not a valid implicit value for reflect.mirror.TypeTag[List[C[T]]] because:
failed to typecheck the materialized typetag: 
No TypeTag available for List[C[T]]
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
materializing requested reflect.mirror.type.TypeTag[List[C[T]]] using `package`.this.materializeTypeTag[List[C[T]]](scala.reflect.`package`.mirror)
calculateUndetparams: Set()
typechecking macro expansion `package`.this.materializeTypeTag[List[C[T]]](scala.reflect.`package`.mirror) at source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-6,offset=152
argss: List(List(MacroContext(materializeTypeTag@source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-6,offset=152 +0)), List(Expr[Nothing](scala.reflect.`package`.mirror)))
paramss: List(List(value c), List(value u), List(value evidence$4))
resolved tparam type T as List[C[T]]
rawArgs: List(MacroContext(materializeTypeTag@source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-6,offset=152 +0), Expr[Nothing](scala.reflect.`package`.mirror), TypeTag[List[C[T]]])
inferring implicit value of type scala.reflect.Manifest[List[C[T]]], macros = true
materializing requested scala.reflect.package.mirror.type.ConcreteTypeTag[List[C[T]]] using `package`.this.materializeConcreteTypeTag[List[C[T]]](`package`.this.mirror)
Test.scala:6: `package`.this.materializeConcreteTypeTag[List[C[T]]](`package`.this.mirror) is not a valid implicit value for scala.reflect.package.mirror.ConcreteTypeTag[List[C[T]]] because:
macros are disabled
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
materializing requested scala.reflect.package.mirror.type.ConcreteTypeTag[C[T]] using `package`.this.materializeConcreteTypeTag[C[T]](`package`.this.mirror)
`package`.this.materializeConcreteTypeTag[C[T]](`package`.this.mirror) is not a valid implicit value for scala.reflect.package.mirror.ConcreteTypeTag[C[T]] because:
macros are disabled
implicit search has failed. to find out the reason, turn on -Xlog-implicits
reifying = List[C[T]]
prefix = scala.reflect.`package`.mirror
splicing C[T]
cache hit: <empty>
Free type: type C (type)
tough type: [_] (PolyType)
Sym def: type _ (type)
Sym def: type C (type)
Locatable: method fooNoTypeTagHK (method) owned by object Test (module class) at Test
splicing T
cache hit: $mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil)
materializing requested scala.reflect.type.ErasureTag[List[C[T]]] using `package`.this.materializeErasureTag[List[C[T]]](`package`.this.mirror)
Test.scala:6: `package`.this.materializeErasureTag[List[C[T]]](`package`.this.mirror) is not a valid implicit value for scala.reflect.ErasureTag[List[C[T]]] because:
macros are disabled
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
materializing requested scala.reflect.type.ArrayTag[List[C[T]]] using `package`.this.materializeArrayTag[List[C[T]]](`package`.this.mirror)
Test.scala:6: `package`.this.materializeArrayTag[List[C[T]]](`package`.this.mirror) is not a valid implicit value for scala.reflect.ArrayTag[List[C[T]]] because:
macros are disabled
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
Filling in: type C (type)
Filling in: type _ (type)
Filling in: type C (type)
reified = {
  val $mr: scala.reflect.`package`.mirror.type = scala.reflect.`package`.mirror;
  val symdef$C7 = $mr.selectTerm($mr.staticModule("Test").moduleClass, "fooNoTypeTagHK").newNestedSymbol($mr.newTypeName("C"), $mr.NoPosition, 8208L, false);
  val symdef$_7 = symdef$C7.newNestedSymbol($mr.newTypeName("_"), $mr.NoPosition, 8208L, false);
  val free$C7 = $mr.newFreeType("C", $mr.PolyType(scala.collection.immutable.List.apply(symdef$_7), $mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor)), $mr.TypeTag[C](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:22");
  symdef$_7.setTypeSignature($mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor));
  $mr.TypeTag[List[C[T]]]($mr.TypeRef($mr.thisModuleType("scala.collection.immutable"), $mr.staticClass("scala.collection.immutable.List"), scala.collection.immutable.List.apply($mr.TypeRef($mr.NoPrefix, free$C7, scala.collection.immutable.List.apply($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil))))), Predef.this.classOf[List[Any]])
}
typechecking {
  val $mr: scala.reflect.`package`.mirror.type = scala.reflect.`package`.mirror;
  val symdef$C7 = $mr.selectTerm($mr.staticModule("Test").moduleClass, "fooNoTypeTagHK").newNestedSymbol($mr.newTypeName("C"), $mr.NoPosition, 8208L, false);
  val symdef$_7 = symdef$C7.newNestedSymbol($mr.newTypeName("_"), $mr.NoPosition, 8208L, false);
  val free$C7 = $mr.newFreeType("C", $mr.PolyType(scala.collection.immutable.List.apply(symdef$_7), $mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor)), $mr.TypeTag[C](null, null), 8208L, "defined by fooNoTypeTagHK in Test.scala:4:22");
  symdef$_7.setTypeSignature($mr.TypeBounds($mr.staticClass("scala.Nothing").asTypeConstructor, $mr.staticClass("scala.Any").asTypeConstructor));
  $mr.TypeTag[List[C[T]]]($mr.TypeRef($mr.thisModuleType("scala.collection.immutable"), $mr.staticClass("scala.collection.immutable.List"), scala.collection.immutable.List.apply($mr.TypeRef($mr.NoPrefix, free$C7, scala.collection.immutable.List.apply($mr.TypeRef.apply($mr.NoPrefix, free$T1, immutable.this.Nil))))), Predef.this.classOf[List[Any]])
} with expected type ?, implicit views = true, macros = true
undetParam added: type A
undetParam inferred: type A as $mr.Symbol
undetParam added: type A
undetParam inferred: type A as $mr.Symbol
undetParam added: type A
undetParam added: type A
type C takes type parameters
Test.scala:6: cannot materialize TypeTag[List[C[T]]] because:
scala.reflect.internal.Types$TypeError: type C takes type parameters
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
macro expansion has failed: No TypeTag available for List[C[T]] at source-C:\Projects\Kepler\test\pending\run\macro-reify-typetag-hktypeparams-notags\Test.scala,line-6,offset=152
Test.scala:6: `package`.this.materializeTypeTag[List[C[T]]](scala.reflect.`package`.mirror) is not a valid implicit value for reflect.mirror.TypeTag[List[C[T]]] because:
failed to typecheck the materialized typetag: 
No TypeTag available for List[C[T]]
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
Test.scala:6: error: No TypeTag available for List[C[T]]
    println(implicitly[TypeTag[List[C[T]]]])
                      ^
two errors found
```
