I've basically been able to reproduce your remarks but maybe the additional comments will save time. 

Let's start with the last expression. It's where implicits should be applied: 

{code}
  /* for programs that typecheck, the arguments to the aFunc call below are always expanded like this: 
   *
   *    X.this.aFunc[Float, Int](  
   *                                X.this.conv1(scala.Some.apply[Float](4.0)), 
   *                                X.this.conv2(0)
   *                            ) 
   *
   * attempts to convert the result of aFunc's call lead to ambiguity 
   * if all of conv3, conv5, and the aFunc overload taking NN's (line 24) are uncommented.
   *
   */

  bFunc( 
         aFunc( 
                  Some(4F)   , /* after conversion: NE[Option[Float]] */
                  0            /* after conversion: NE[Int]           */
              ) 
       ) 
{code}

As the comment suggests, I see a problem when some members are in scope (conv3, conv5, and the 2nd aFunc overload). However, that's not sufficient for the error: they may be in scope but all goes well if just the conversions to aFunc's call are applied manually: 

{code}
  bFunc( 
         aFunc( 
                  new NE[Option[Float]]    , 
                  new NE[Int]             
              ) 
       )
{code}

Anyway, the example is about what happens if conv1 and conv2 convert from {{Some(4F)}} and {{0}}. 


Although uncommenting all three members below leads to ambiguity, that's also strange because the aFunc overload that takes NN's shouldn't be picked anyway: 

{code}
  /* Uncommenting all three of the members below causes ambiguity among conversion of aFunc's result */

  // conv3 is a candidate to convert the result of the aFunc overload above into bFunc's argument 
  implicit def conv3(op: AA[Byte,Byte]     ) = new N[Byte] 
  implicit def conv5(e : BB[java.util.Date]) = new NN[java.util.Date]

  def aFunc[A]  (a: NN[Option[A]], b: NN[A]) = new BB[A] 
  // the aFunc overload above is never picked because 
  //    conv1, conv2 return NE's not NN's 
  // and 
  //    there are no other conversions into NN's from the args to aFunc's call below. 
{code}

I also tried with {{-Xlog-implicits}} but that didn't make me any wiser.

