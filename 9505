Some breadcrumbs:

{code}
def normalTypedApply(tree: Tree, fun: Tree, args: List[Tree]) = {
        val stableApplication = (fun.symbol ne null) && fun.symbol.isMethod && fun.symbol.isStable
        if (stableApplication && isPatternMode) {
          // treat stable function applications f() as expressions.
          typed1(tree, mode & ~PATTERNmode | EXPRmode, pt)
        
{code}

{code}
     def typedIdentOrWildcard(tree: Ident) = {
        val name = tree.name
        if (Statistics.canEnable) Statistics.incCounter(typedIdentCount)
        if ((name == nme.WILDCARD && (mode & (PATTERNmode | FUNmode)) == PATTERNmode) ||
            (name == tpnme.WILDCARD && (mode & TYPEmode) != 0))
          tree setType makeFullyDefined(pt)
        else
          typedIdent(tree, name)
      }
{code}

In the original type check, we get to:

{noformat}
normalTypedApply(tree = << ::((x @ _), (xs @ _)) >>, fun = << :: >>, ...)
{noformat}

After a reset, the retypecheck gets to: 

{noformat}
normalTypedApply(tree = << scala.`package`.::((x @ _), (xs @ _)) >>, fun = << scala.`package`.:: >>, ...)
{noformat}

The function is treated as a stable application, and the application is typed in expression mode, rather than pattern mode. Under this mode, the ident {{_}} does not typecheck.

I'm not sure yet what changed from 2.10.0 to 2.10.1 to lead us down this path.
