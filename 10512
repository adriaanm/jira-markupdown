Normalize isn't supposed to change abstract types (even those equivalent to aliases), so this looks correct to me:
```scala
scala> typeOf[Baz.type].members filter (_.isType) map (x => (x, typeOf[Baz.type] memberType x normalize) )
warning: there were 1 feature warning(s); re-run with -feature for details
res0: Iterable[($r.intp.global.Symbol, $r.intp.global.Type)] = List(
(type B2,Int), (type B1,Baz.in.A1), (type A2,Int), (type A1,Baz.in.A1))

scala> typeOf[Baz.type].members filter (_.isType) map (x => (x, (typeOf[Baz.type] memberType x normalize) bounds) )
warning: there were 2 feature warning(s); re-run with -feature for details
res1: Iterable[($r.intp.global.Symbol, $r.intp.global.TypeBounds)] = List(
(type B2, >: Int <: Int), (type B1, >: Int <: Int), (type A2, >: Int <: Int), (type A1, >: Int <: Int))
```
