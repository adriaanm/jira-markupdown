But only if the former is an abstract trait member implemented by a subtype:

{code}
trait Bunny {
  def foo(a: Int = 4, b: Int = 2): String
  def foo: String = foo()
}

object Little extends Bunny {
  def foo(a: Int, b: Int) = a.toString + b.toString
}

object Test {
  Little.foo // ambiguous reference to overloaded definition
}
{code}

However:

{code}
trait Bunny {
  def foo(a: Int = 4, b: Int = 2): String = a.toString + b.toString
  def foo: String = foo()
}

object Little extends Bunny

object Test {
  Little.foo // no error
}
{code}
